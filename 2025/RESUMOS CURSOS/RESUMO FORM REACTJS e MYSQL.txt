////////////////////////////////////////////////////// &&& ###
TIPOS DE CONEXÃO

const mysql = require('mysql');
const db = mysql.createConnection({
  host     : 'localhost',
  user     : 'root',
  password : 'password',
  database : 'schema',
});

When you create a connection with mysql.createConnection, you only have one connection, and it lasts until you close it OR connection closed by MySQL.
A single connection is blocking. While executing one query, it cannot execute others. Hence, your application will not perform good.
PODE CRIAR UM CONGESTIONAMENTO

----------

const mysql = require('mysql');
const db = mysql.createPool({
  connectionLimit : 10,                   //quantidade de conexões permitidas ao mesmo tempo
  host     : 'localhost',
  user     : 'root',
  password : 'password',
  database : 'schema',
});

mysql.createPool is a place where connections get stored.
When you request a connection from a pool,you will receive a connection that is not currently being used, or a new connection.
If you’re already at the connection limit, it will wait until a connection is available before it continues.

In a pool while one connection is busy running a query, others can be used to execute subsequent queries. Hence, your application will perform good.
NÃO CRIA CONGESTIONAMENTO

const mysql = require('mysql2/promise');         // Use promise-based version for async/await

  const db = mysql.createPool({ 
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'schema',
    waitForConnections: true,
    connectionLimit: 10,                 // Adjust as needed
    queueLimit: 0,
  });

  // Test the database connection
  async function testConnection() {
    try {
      const connection = await pool.getConnection();
      console.log('Conectado ao MySQL');
      connection.release();                         // Release the connection back to the pool
    } catch (err) {
      console.error('Erro ao conectar ao MySQL:', err);
    }
  }

  testConnection();


///////////////////////////////////////////////////// &&& ###
ASYNC/AWAIT

try{
  const response = await axios.get(request)
  return response
}
catch(err){
  return err
}

É IGUAL A:

const response = axios.get(request)
  .then(res => return res)
  .catch(err => return err);


///////////////////////////////////////////////////// &&& ###
IMPORTANDO DADOS DO MYSQL (BASICO DO BASICO)

Arquivo Consulta.jsx:

import React, { useState, useEffect } from 'react';
import axios from 'axios';

export default function Cadastro() {
  const [message, setMessage] = useState([]);

  useEffect(() => {
    const consulta = async () => {
      try {
        const response = await axios.get('http://localhost:3000/usuarios');
        setMessage(response.data);
        console.log(response.status);        //Caso queira saber o numero do status
      } catch (err) {
        setMessage('Erro: ', err);
      } 
    };
    consulta();
  }, []);

  return (
    <div>
      <div>
        {message.map((usuario) => (
          <div key={usuario.id}>
            <p>{usuario.email}</p>                 //Serão listados os email do todos os usuarios
          </div>
        ))}
      </div>
    </div>
  );
}

-----

Caso queira o email do primeiro usuario cadastrado:

...
      <div>
        {message[1].email}
      </div>
...

---------- 

-Arquivo server.js:

const express = require('express');
const mysql = require('mysql2');

const app = express();
const PORT = 3000;

app.use(express.json());

const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja',
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.get('/usuarios', (req, res) => {
  const sql = 'SELECT * FROM usuarios';               
  db.query(sql, (err, result) => {
    if (err) throw err;                            
    res.json(result);                              
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});



///////////////////////////////////////////////////////// &&& ###

REACT COM INPUT MASK PARA FORMULARIOS
VIDEO: https://www.youtube.com/embed/8CpVaDeSmCk?autoplay=1

Instalação:
npm i react-input-mask

Importar:
import InputMask from 'react-input-mask';

...
  <InputMask mask="(99) 99999-9999" maskChar=" " />         //celular
...

...
  <InputMask mask="999.999.999-99" maskChar=" " />         //cpf
...

...
  <InputMask mask="+55 (21) 99999-9999" maskChar=" " />         //celular de codigo de país e ddd do RJ fixo
...

9 significa que aceita todos os numeros de 1 a 9

Se quiser travar o 9:
...
  <InputMask mask="+55 (\92) 99999-9999" maskChar=" " />       
...
// \9 significará para travar o numero 9 e não que aceita numeros de 1 a 9


REGEX:
\d all digit characters
\w which matches all word characters (a-z, A-Z, 0-9, and _)
\D which matches all non-digit characters. It is the opposite of \d
\W which matches all non-word characters
\s which matches all white spaces including the spacebar, tab, and return


Alfanumérico com 1 ou mais caracteres = [a-zA-Z0-9]+
Username com 1 a 20 caracteres = ^[a-zA-Z]{1,20}$    ou    ^[a-zA-Z0-9_.]{1,20}$
Password (precisa ter maiúsculas, minúsculas e número) = ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s).*$
Senha com 6 digitos: [a-zA-Z0-9]{6}
Password com no mínimo 8 caracteres (precisa ter maiúsculas, minúsculas e número/caractere especial) = (?=^.{8,}$)((?=.*\d)|(?=.*\W+))(?![.\n])(?=.*[A-Z])(?=.*[a-z]).*$
Número de cartão de crédito = [0-9]{13,16}
Número de cartão de crédito AMEX = [0-9]{4} *[0-9]{6} *[0-9]{5}
CEP = [0-9]{5}[\-]?[0-9]{3}
Data (DD.MM.AAAA) = (0[1-9]|1[0-9]|2[0-9]|3[01]).(0[1-9]|1[012]).[0-9]{4}
Validação completa de data (DD-MM-AAAA)= (?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))-(?:(?:0[1-9]|1[0-2])-(?:19|20)[0-9]{2}
Hora (hh:mm:ss) : (0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}
Telefone (+99(99)9999-9999) = [\+]\d{2}[\(]\d{2}[\)]\d{4}[\-]\d{4} 
Celular ((99)99999-9999) = \([0-9]{2}\)[9]{1}[0-9]{4}-[0-9]{4}
CPF (999.999.999-99) = [0-9]{3}[\.?][0-9]{3}[\.?][0-9]{3}[\-?][0-9]{2} 
Email (não use pattern) = <input type="email" name="" value="" required />
Número com ou sem decimal (Ex: 9 ou 9.9 ou 9,9) = [-+]?[0-9]*[.,]?[0-9]+
Preço (1.00) = \d+(\.\d{2})?
Preço (1,00) = \d+(,\d{2})?

/////////////////////////////////////////////////////////&&& ###
FORMULARIO DE CADASTRO COM FORMIK, YUP, AXIOS, EXPRESS, MYSQL2, CORS

Estrutura basica do arquivo cadastro.jsx:

import React, { useState } from 'react';
import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import axios from 'axios';

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const initialValues = {
    campo: '',
  };

  const validationSchema = yup.object().shape({
    campo: yup
    ...
  });

  const handleSubmit = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem(response.data.message);
      setResultSubmit('success');
      resetForm();
    } catch (error) {
      setMensagem(error.response?.data?.message || 'Erro ao cadastrar usuário');
      setResultSubmit('error');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <Formik
        initialValues={initialValues}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({ isSubmitting }) => (          //OU   {({ isSubmitting, values, setFieldValue }) => (
          <Form>
            <div>
              <Field type="text" id="campo" name="campo" placeholder="Digite... " />
              <ErrorMessage name="campo" component="div" />
            </div>

            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
            </button>
          </Form>
        )}
      </Formik>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

----------- ###

Estrutura basica do arquivo server.js:   (com createConnection e callbacks no mysql)

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
//const bcrypt = require('bcrypt');             

const app = express();
const PORT = 3000;

app.use(cors());                                
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'schema'
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.post('/cadastro', async (req, res) => {
  try {
    const { CAMPO } = req.body;

    if (!CAMPO) {
      return res.status(400).json({ error: 'É obrigatório preencher' });
    }

    db.execute('INSERT INTO tabela (CAMPO) VALUES (?)', [CAMPO], (err, results) => {
      if (err) {
        console.error('Erro ao cadastrar:', err);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }
      res.status(201).json({ message: 'Cadastrado com sucesso' });
    });
  } catch (error) {
    console.error('Erro no registro:', error);
    return res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

----------- ###

Estrutura basica do arquivo server.js:   (com createPool e promises no mysql)

const express = require('express');
const mysql = require('mysql2/promise');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

const db = mysql.createPool({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'schema',
  waitForConnections: true,
  connectionLimit: 10,                             // Adjust as needed
  queueLimit: 0,
});

async function testConnection() {
  try {
    const connection = await db.getConnection();
    console.log('Conectado ao MySQL');
    connection.release();                                 // Release the connection back to the pool
  } catch (err) {
    console.error('Erro ao conectar ao MySQL:', err);
  }
}

testConnection();

app.post('/cadastro', async (req, res) => {
  try {
    const { CAMPO } = req.body;

    if (!CAMPO) {
      return res.status(400).json({ error: 'É obrigatório preencher' });
    }

    try {
      const [results] = await db.execute('INSERT INTO tabela (CAMPO) VALUES (?)', [CAMPO]);
      res.status(201).json({ message: 'Cadastrado com sucesso' });
    } catch (err) {
      console.error('Erro ao cadastrar:', err);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  } catch (error) {
    console.error('Erro no registro:', error);
    return res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

----------------------- ###

Username:
username VARCHAR(16) UNIQUE NOT NULL

  const validationSchema = yup.object().shape({
    username: yup
      .string()
      .required('É obrigatório preencher')
      .matches(/^\S*$/, 'Não pode conter espaços')
      .matches(/[A-Z]/, 'Deve conter pelo menos 1 letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'Deve conter pelo menos 1 caractere especial')
      .min(6, "Deve conter no mínimo 6 caracteres.")
      .max(16, "Deve conter no máximo 16 caracteres.")
  });

           <div>
              <Field type="text" id="username" name="username" />
              <ErrorMessage name="username" component="div" />
            </div>

  Username com 1 a 20 caracteres = ^[a-zA-Z]{1,20}$    ou    ^[a-zA-Z0-9_.]{1,20}$

----------- ###









------------- ###

CPF/CNPJ:

import React, { useState } from 'react';
import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import axios from 'axios';

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const initialValues = {
    campo: '',
  };

  const validationSchema = yup.object().shape({
    campo: yup.string()
      .required('CPF ou CNPJ é obrigatório')
      .test('cpf-cnpj-format', 'Deve conter 11 dígitos (CPF) ou 14 dígitos (CNPJ)', (value) => {
        if (!value) return false;
        const numbersOnly = value.replace(/\D/g, '');
        return numbersOnly.length === 11 || numbersOnly.length === 14;
      })
      .test('cpf-cnpj-valid', 'CPF ou CNPJ inválido', (value) => {
        if (!value) return false;
        const numbersOnly = value.replace(/\D/g, '');

        // Validação básica para evitar números repetidos
        if (numbersOnly.length === 11) {
          return !(/^(\d)\1{10}$/.test(numbersOnly)); // CPF não pode ter todos os dígitos iguais
        } else if (numbersOnly.length === 14) {
          return !(/^(\d)\1{13}$/.test(numbersOnly)); // CNPJ não pode ter todos os dígitos iguais
        }
        return false;
      }),
  });

  const handleSubmit = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem(response.data.message);
      setResultSubmit('success');
      resetForm();
    } catch (error) {
      setMensagem(error.response?.data?.message || 'Erro ao cadastrar usuário');
      setResultSubmit('error');
    } finally {
      setSubmitting(false);
    }
  };


  const formatCpfCnpj = (value) => {
    const numbersOnly = value.replace(/\D/g, '');

    if (numbersOnly.length <= 11) {
      // Formato CPF: 000.000.000-00
      return numbersOnly
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d{1,2})/, '$1-$2');
    } else {
      // Formato CNPJ: 00.000.000/0000-00
      return numbersOnly
        .replace(/(\d{2})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1/$2')
        .replace(/(\d{4})(\d{1,2})/, '$1-$2');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <Formik
        initialValues={initialValues}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({ isSubmitting, values, setFieldValue }) => (
          <Form>
              <div>
                <Field 
                  name="campo" 
                  value={values.campo}
                  onChange={(e) => {
                    const formatted = formatCpfCnpj(e.target.value);
                    setFieldValue('campo', formatted);
                  }}
                  maxLength={18} // Máximo para CNPJ formatado
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="campo"
                />
              </div>

            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
            </button>
          </Form>
        )}
      </Formik>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

---------------------------- ###

Celular com DDD:

import React, { useState } from 'react';
import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import axios from 'axios';

const formatCel = (value) => {
  if (!value) return value;

  const celOnlyNumber = value.replace(/[^\d]/g, '');

  if (celOnlyNumber.length < 3) return celOnlyNumber;

  if (celOnlyNumber.length < 7) {
    return `(${celOnlyNumber.slice(0, 2)}) ${celOnlyNumber.slice(2)}`;
  }

  if (celOnlyNumber.length < 11) {
    return `(${celOnlyNumber.slice(0, 2)}) ${celOnlyNumber.slice(2, 7)}-${celOnlyNumber.slice(7)}`;
  }

  return `(${celOnlyNumber.slice(0, 2)}) ${celOnlyNumber.slice(2, 7)}-${celOnlyNumber.slice(7, 11)}`;
};


export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const initialValues = {
    cel: '',
  };

  const validationSchema = yup.object().shape({
    cel: yup
      .string()
      .required('É obrigatório')
      .test('len', 'Deve ser um número de celular válido', (val) => val && val.replace(/\D/g, '').length === 11),
  })


  const handleSubmit = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem(response.data.message);
      setResultSubmit('success');
      resetForm();
    } catch (error) {
      setMensagem(error.response?.data?.message || 'Erro ao cadastrar usuário');
      setResultSubmit('error');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <Formik
        initialValues={initialValues}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({ isSubmitting, values, setFieldValue }) => (
          <Form>
              <div>
                <Field 
                  name="cel" 
                  value={values.cel}
                  onChange={(e) => {
                    const formatted = formatCel(e.target.value);
                    setFieldValue('cel', formatted);
                  }}
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="cel"
                />
              </div>

            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
            </button>
          </Form>
        )}
      </Formik>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

-----

Outra forma mais simples de fazer a formatação:

  const formatCel = (value) => {

    if (!value) {
      return '';
    }

    const OnlyNum = value.replace(/\D/g, '');

    const ddd = OnlyNum.slice(0, 2);
    const parte1 = OnlyNum.slice(2, 7);
    const parte2 = OnlyNum.slice(7, 11);

    if (OnlyNum.length <= 2) {
      return ddd;
    }

    if (OnlyNum.length <= 7) {
      return `(${ddd}) ${parte1}`;
    }

    return `(${ddd}) ${parte1}-${parte2}`;
  };


  const validationSchema = yup.object().shape({
    cel: yup
      .string()
      .required('É obrigatório')
      .min(15, 'Deve ter no mínimo 11 dígitos')
  })

      ...
                <div>
                <Field 
                  name="cel" 
                  value={values.cel}
                  onChange={(e) => {
                    const formatted = formatCel(e.target.value);
                    setFieldValue('cel', formatted);
                  }}
                  maxLength={15}               // (99) 99999-9999 = 11 digitos + 3 caracteres + 1 espaço
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="cel"
                />
              </div>
        ...

----------------------- ###

CEP:

const formatCep = (value) => {

  if (!value) {
    return '';
  }

  const OnlyNum = value.replace(/\D/g, '');

  const parte1 = OnlyNum.slice(0, 5);
  const parte2 = OnlyNum.slice(5, 8);

  if (OnlyNum.length <= 5) {
    return `${parte1}`;
  }

  return `${parte1}-${parte2}`;
};

  const validationSchema = yup.object().shape({
    cep: yup
      .string()
      .required('É obrigatório')
      .min(9, 'Deve ter no mínimo 8 dígitos')
  })

  return (
    ...
              <div>
                <Field 
                  name="cep" 
                  value={values.cep}
                  onChange={(e) => {
                    const formatted = formatCep(e.target.value);
                    setFieldValue('cep', formatted);
                  }}
                  maxLength={9}                       // 99999-999 = 8 digitos + 1 hifen
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="cep"
                />
              </div>
    ...
  );
};


//////////////////////////////////////////////////////////// &&& ###
FORMULARIOS COM REACT HOOK FORM

Instalação:
npm install react-hook-form

Importar:
import { useForm, SubmitHandler } from "react-hook-form"

import React from "react";
import { useForm } from "react-hook-form";

-------------

export default function Cadastro() {
	const { register, handleSubmit, formState: { errors } } = useForm();
	
	const onSubmit = data => {
		alert(JSON.stringify(data));         //OU alert(data)
	};
	
return (
	<form onSubmit={handleSubmit(onSubmit)}>
		<input {...register("name", { required: "O campo nome é obrigatório" })} />
    {errors.name && <div>{errors.name.message}</div>}
		<button type="submit">Enviar</button>
	</form>
	);
}

------------- ###

REACT HOOK FORM COM VALIDAÇÃO E RESOLVERS (YUP e ZOD):

Instalação:
npm install zod
ou
npm install yup

Instalação dos resolvers para o zod ou yup:
npm install @hookform/resolvers

Importar:
import { yupResolver } from '@hookform/resolvers/yup';
ou
import { zodResolver } from "@hookform/resolvers/zod";

ZOD:
TypeScript-first with JavaScript compatibility
Modern TypeScript projects, tRPC, Next.js
tRPC, React Hook Form, Next.js, Remix

YUP:
JavaScript-first with TypeScript support
React, especially with Formik
Formik, React Hook Form, MUI

----------------- ###

LISTA DE VALIDAÇõES YUP:

Here are the most commonly used Yup validations for forms:

String Validations:
string().required() - Ensures field is a string and not empty
string().email() - Validates email format
string().min(length) - Minimum character length
string().max(length) - Maximum character length
string().matches(regex) - Custom regex pattern matching
string().url() - Validates URL format
string().trim() - Removes whitespace from both ends

Number Validations:
number().required() - Ensures field is a number and exists
number().min(value) - Minimum numeric value
number().max(value) - Maximum numeric value
number().positive() - Must be positive number
number().integer() - Must be an integer

Boolean Validations:
boolean().required() - Must be true or false
boolean().oneOf([true]) - Must be true (useful for required checkboxes)

Array Validations:
array().required() - Must be an array
array().min(length) - Minimum array length
array().of(schema) - Validates each array item against a schema

Date Validations:
date().required() - Must be a valid date
date().min(date) - Must be after specified date
date().max(date) - Must be before specified date

Conditional Validations:
when(field, condition) - Conditional validation based on other fields
oneOf([values]) - Must match one of the specified values
notOneOf([values]) - Must not match any of the specified values

Common Patterns:
string().nullable() - Allows null values
string().optional() - Field is not required
mixed().test() - Custom validation function

------

.reach()
.addMethod
.ref()
.lazy()

Para todos (.string(), .number(), etc...):
.clone()
.label(label: string)
.meta(metadata: object)
.describe()
.concat(schema: Schema)
.validate(value: any, options?: object): Promise<any, ValidationError>
.validateSync(value: any, options?: object)
.validateAt(path: string, value: any, options?: object): Promise<any, ValidationError>
.validateSyncAt(path: string, value: any, options?: object)
.isValid(value: any, options?: object): Promise<boolean>
.isType(value: any): boolean
.strict(isStrict: boolean = false)
.strip(stripField: boolean = true)
.default(value: any)
.getDefault(options?: object)
.nullable(isNullable: boolean = true)
.required(message?: string | function)
.notRequired(): Schema Alias: optional()
.defined()
.typeError(message: string)
.oneOf(arrayOfValues: Array<any>, message?: string | function)
.notOneOf(arrayOfValues: Array<any>, message?: string | function)
.when(keys: string | Array<string>, builder: object | (value, schema)=> Schema)
.test(name: string, message: string | function, test: function)
.test(options: object)
.transform((currentValue: any, originalValue: any) => any)

Para apenas .string() :
.required(message?: string | function)
.length(limit: number | Ref, message?: string | function)
.min(limit: number | Ref, message?: string | function)
.max(limit: number | Ref, message?: string | function)
.matches(regex: Regex, message?: string | function)
.matches(regex: Regex, options: { message: string, excludeEmptyString: bool })
.email(message?: string | function)
.url(message?: string | function)
.uuid(message?: string | function)
.ensure()
.trim(message?: string | function)
.lowercase(message?: string | function)
.uppercase(message?: string | function) 

-Para apenas .number() :
.min(limit: number | Ref, message?: string | function)
.max(limit: number | Ref, message?: string | function)
.lessThan(max: number | Ref, message?: string | function)
.moreThan(min: number | Ref, message?: string | function)
.positive(message?: string | function)
.negative(message?: string | function)
.integer(message?: string | function)
.truncate()
.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round')

.boolean()

Para apenas .date() :
.min(limit: Date | string | Ref, message?: string | function)
.max(limit: Date | string | Ref, message?: string | function)

-Para apenas .array() :
.of(type: Schema)
.length(length: number | Ref, message?: string | function)
.min(limit: number | Ref, message?: string | function)
.max(limit: number | Ref, message?: string | function)
.ensure()
.compact(rejector: (value) => boolean)

--------- ###

React-hook-form + YUP:

import React from "react";
import { useForm } from "react-hook-form";
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

export default function Cadastro() {
  
  const validationSchema = yup.object().shape({
    name: yup
      .string()
      .required('É obrigatório')
      .min(3, 'Deve ter no mínimo 3 caracteres')
  });

  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: yupResolver(validationSchema)
  });

  const onSubmit = data => {
    alert(JSON.stringify(data));         //OU alert(data)
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>

      <input {...register("name")} />

      {errors.name && <div>{errors.name.message}</div>}

      <button type="submit">Enviar</button>

    </form>
  );

}

------------- ###

React-hook-form + ZOD:

import React from "react";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

export default function Cadastro() {
  
  const validationSchema = z.object({
    name: z
      .string()
      .nonempty('É obrigatório')                       // .required() no yup
      .min(3, 'Deve ter no mínimo 3 caracteres')
  });

  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(validationSchema)
  });

  const onSubmit = (data) => {
    alert(JSON.stringify(data));         //OU alert(data)
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>

      <input {...register("name")} />

      {errors.name && <div>{errors.name.message}</div>}

      <button type="submit">Enviar</button>

    </form>
  );

}

///////////////////////////////////////////////// &&& ###
Formulario React-hook-form + yup:


Idade:

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';


  const formatIdade = (value) => {

    if (!value) {
      return '';
    }

    const OnlyNum = value.replace(/\D/g, '');

    return OnlyNum;
  };


export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    idade: yup
      .string()
      .required('É obrigatório')
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      idade: '',
    },
  });


  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            type="text"               //opcional
            name="idade"
            {...register('idade')}
            onChange={(e) => {
              const formatted = formatIdade(e.target.value);
              setValue('idade', formatted);
            }}
            maxLength={3}
            disabled={false}
          />
          {errors.idade && <span>{errors.idade.message}</span>}
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

----

Outra forma mais abreviada:


import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    idade: yup
      .string()
      .required('É obrigatório')
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      idade: '',
    },
  });


  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="idade"
            {...register('idade')}
            onChange={(e) => {
              setValue('idade', e.target.value.replace(/\D/g, ''));
            }}
            maxLength={3}
            disabled={false}
          />
          {errors.idade && <span>{errors.idade.message}</span>}
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

---------- 

Idade com condições:


import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';


export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    idade: yup
      .string()
      .required('Idade é obrigatória')
      .test('min', 'Idade deve ser maior ou igual a 18', val => parseInt(val, 10) >= 18)
      .test('max', 'Idade deve ser menor que 100', val => parseInt(val, 10) < 100),
  }).required();

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      idade: '',
    },
  });


  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="idade"
            {...register('idade')}
            onChange={(e) => {
              setValue('idade', e.target.value.replace(/\D/g, ''));           //Não deixa digitar algo além de números
            }}
            maxLength={3}
            disabled={false}
          />
          {errors.idade && <span>{errors.idade.message}</span>}
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

----

Outra forma:
(Deixará o usuario digitar letras e outros caracteres, mas não deixará submeter o envio)

  const validationSchema = yup.object().shape({
    idade: yup
      .string()
      .required('Idade é obrigatória')
      .matches(/^[0-9]+$/, 'Idade deve conter apenas números')
      .test('min', 'Idade deve ser maior ou igual a 18', val => parseInt(val, 10) >= 18)
      .test('max', 'Idade deve ser menor que 100', val => parseInt(val, 10) < 100)
  }).required();

    ...
          <input
            name="idade"
            {...register('idade')}
            onChange={(e) => {
              setValue('idade', e.target.value);
            }}
            maxLength={3}
            disabled={false}
          />
    ...

------------ ###

Celular:

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';


  const formatCel = (value) => {

    if (!value) {
      return '';
    }

    const OnlyNum = value.replace(/\D/g, '');

    const ddd = OnlyNum.slice(0, 2);
    const parte1 = OnlyNum.slice(2, 7);
    const parte2 = OnlyNum.slice(7, 11);

    if (OnlyNum.length <= 2) {
      return ddd;
    }

    if (OnlyNum.length <= 7) {
      return `(${ddd}) ${parte1}`;
    }

    return `(${ddd}) ${parte1}-${parte2}`;
  };


export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    cel: yup
      .string()
      .required('É obrigatório')
      .min(15, 'Deve ter no mínimo 11 dígitos')
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      cel: '',
    },
  });


  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            type="text"
            name="cel"
            {...register('cel')}
            onChange={(e) => {
              const formatted = formatCel(e.target.value);
              setValue('cel', formatted);
            }}
            maxLength={15}
            disabled={false}
          />
          {errors.cel && <span>{errors.cel.message}</span>}
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

-------------------- ###

Preço:

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';

const formatPreco = (value) => {

  const OnlyNum = value.replace(/\D/g, '');

  // Formata como moeda (R$ X.XXX,XX)
  const formattedValue = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  }).format(OnlyNum / 100);                    // Divide por 100 para converter centavos em reais

  return formattedValue;
};


export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    preco: yup
      .string()
      .required('É obrigatório')
      //.matches(/^R\$\s\d{1,3}(\.\d{3})*,\d{2}$/, 'Formato inválido')
      .test('min', 'O valor mínimo é R$ 0,01', (value) =>    
        parseFloat(value.replace(/[^\d,]/g, '').replace(',', '.')) >= 0.01
      )
  }).required();

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      preco: '',
    },
  });


  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="preco"
            {...register('preco')}
            onChange={(e) => {
              const formatted = formatPreco(e.target.value);
              setValue('preco', formatted);
            }}
            maxLength={10}
            placeholder="R$ 0,00"
            disabled={false}
          />
          {errors.preco && <span>{errors.preco.message}</span>}
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

---------

// Função para aplicar máscara de preço
const formatPreco = (value) => {
  if (!value) return '';
  
  // Remove todos os caracteres não numéricos
  const digits = value.replace(/\D/g, '');
  
  // Converte para número e divide por 100 para ter os centavos
  const number = parseFloat(digits) / 100;
  
  // Formata o número no padrão brasileiro
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
    minimumFractionDigits: 2
  }).format(number);
};

---------------

const formatPreco = (value) => {
  // Remove todos os caracteres que não são dígitos
  const digits = value.replace(/\D/g, '');
  
  // Se não há dígitos, retorna vazio
  if (!digits) return '';
  
  // Converte para número e divide por 100 para ter os centavos
  const number = parseInt(digits) / 100;
  
  // Formata como moeda brasileira
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(number);
};

----------------- ###

PREÇO: (OUTRA FORMA) Talvez tenha problemas???

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';

const formatPreco = (value) => {
  // Remove todos os caracteres que não são dígitos
  const digits = value.replace(/\D/g, '');
  
  // Se não há dígitos, retorna vazio
  if (!digits) return '';

  const centavo = digits.slice(-2)
  const real = digits.slice(-5, -2)
  const mil = digits.slice(-8, -5)

  if (digits.length <= 2) {
    return `R$ ${centavo}`
  }

  if (digits.length <= 5) {
    return `R$ ${real},${centavo}`;
  }

  return `R$ ${mil}.${real},${centavo}`;
};

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    preco: yup
      .string()
      .required('É obrigatório')
      //.matches(/^R\$\s\d{1,3}(\.\d{3})*,\d{2}$/, 'Formato inválido')
      .test('min', 'O valor mínimo é R$ 0,01', (value) =>    
        parseFloat(value.replace(/[^\d,]/g, '').replace(',', '.')) >= 0.01
      )
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      preco: '',
    },
  });

  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="preco"
            {...register('preco')}
            onChange={(e) => {
              const formatted = formatPreco(e.target.value);
              setValue('preco', formatted);
            }}
            maxLength={13}
            placeholder="R$ 0,00"
            disabled={false}
          />
          {errors.preco && <span>{errors.preco.message}</span>}          //OU <p>{errors.preco?.message}</p>
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

---------- ###

Para converter o resultado em float:

  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      const precoLimpo = values.preco.replace(/[R$\.]/g, '');      //Remove R$, ponto e espaço
      const precoStrLimpo = precoLimpo.replace(',', '.')           //Substitui a virgula por ponto
      const precoFloat = parseFloat(precoStrLimpo);                //Converte em number
      const tipoPreco = typeof precoFloat                          //Para saber o tipo
      alert(precoFloat)
      setMensagem(tipoPreco)                                       //tipo number
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

----

Abreviação para remover as coisas extras e converter em number:
const val = parseFloat(values.preco.replace(/[R\$\.\s]/g, '').replace(',', '.'))

OBS:
alert(JSON.stringify(values.preco.replace(/R\$\s?/,'')))       //Mostrar apenas números, ponto e virgula

----

Para converter de volta para string:
const valNum = parseFloat(values.preco.replace(/[R\$\.\s]/g, '').replace(',', '.'))     //converteu para number

const valStr = valNum.toString().replace('.', ',')       //converteu de volta para string

const valor1 = valStr.length <= 2 ? `${valStr.slice(-2)},00` : valStr;
const valor2 = valor1.length > 6 ? `R$ ${valStr.slice(-9, -6)}.${valStr.slice(-6, -3)},${valStr.slice(-2)}` : `R$ ${valor1}`;

alert(valor2)

-------------------  ###

DATA:

import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';

const formatData = (value) => {

  let formattedValue = value.replace(/\D/g, ''); // Remove non-digit characters
  
  formattedValue = formattedValue.slice(0, 8); // Limit to 8 characters (DDMMYYYY)

  if (formattedValue.length > 2) {
    formattedValue = formattedValue.substring(0, 2) + '/' + formattedValue.substring(2);
  }
  if (formattedValue.length > 5) {
    formattedValue = formattedValue.substring(0, 5) + '/' + formattedValue.substring(5);
  }

  return formattedValue;
};

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    data: yup
      .string()
      .required('É obrigatório')
      .test(
        'is-valid-date',
        'Data inválida. Use o formato DD/MM/AAAA',
        (value) => {
          if (!value) return true; // Allow empty values if not required
          const regex = /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[012])\/(19|20)\d\d$/;
          return regex.test(value);
        }
      )
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      data: '',
    },
  });

  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="data"
            {...register('data')}
            onChange={(e) => {
              const formatted = formatData(e.target.value);
              setValue('data', formatted);
            }}
            maxLength={10}
            placeholder="01/01/2025"
            disabled={false}
          />
          {errors.data && <span>{errors.data.message}</span>}        
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};

---------- ###

Outra forma (não tão completa):


import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';
import axios from 'axios';

const formatData = (value) => {
  // Remove todos os caracteres que não são dígitos
  const digits = value.replace(/\D/g, '');
  
  // Se não há dígitos, retorna vazio
  if (!digits) return '';

  const dia = digits.slice(0, 2)
  const mes = digits.slice(2, 4)
  const ano = digits.slice(4, 9)

  if (digits.length <= 2) {
    return `${dia}/`
  }

  if (digits.length <= 4) {
    return `${dia}/${mes}/`;
  }

  return `${dia}/${mes}/${ano}`;
};

export default function Cadastro(){

  const [mensagem, setMensagem] = useState('');
  const [resultSubmit, setResultSubmit] = useState('');

  const validationSchema = yup.object().shape({
    data: yup
      .string()
      .required('É obrigatório')
      .min(10, "Informe uma data completa")
  });

  const { register, handleSubmit, setValue, formState: { errors, isSubmitting }, reset } = useForm({
    resolver: yupResolver(validationSchema),
    defaultValues: {
      data: '',
    },
  });

  const onSubmit = async (values) => {
    try {
      //const response = await axios.post('http://localhost:3000/cadastro', values);
      setMensagem("Deu certo");
      setResultSubmit('success');
      reset();
    } catch (error) {
      setMensagem('Erro ao cadastrar usuário');
      setResultSubmit('error');
    }
  };

  return (
    <div>
      <h1>Cadastro</h1>
      <form onSubmit={handleSubmit(onSubmit)}>
        <div>
          <input
            name="data"
            {...register('data')}
            onChange={(e) => {
              const formatted = formatData(e.target.value);
              setValue('data', formatted);
            }}
            maxLength={10}
            placeholder="01/01/2025"
            disabled={false}
          />
          {errors.data && <span>{errors.data.message}</span>}        
        </div>

        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
        </button>
      </form>

      {mensagem && (
        <div style={{ color: resultSubmit === 'success' ? 'green' : 'red' }}>
          {mensagem}
        </div>
      )}
    </div>
  );
};


////////////////////////////////////////////////////////// &&& ###
MASCARAS DE FORMULARIOS COM REACT NUMBER FORMAT
VIDEO: https://www.youtube.com/embed/NvlkMAcwpOg?autoplay=1
(tive problemas com o .required() do Yup)

Instalação:
npm i react-number-format

Importação:
import { NumericFormat } from 'react-number-format';        //Para numeros
ou
import { PatternFormat } from 'react-number-format';        //Para padrões


Modo pattern:   

import { PatternFormat } from 'react-number-format';

export default function Pattern() {
  return (
    <>
      <PatternFormat 

        patternChar = '#'                //Qual caractere será substituido  

        format = '(##) #####-####'       //Formato

        mask = '_'             //O que será mostrado no lugar de patterChar: (__) _____-____

        allowEmptyFormatting  

      />
    </>
  )
}

-----------------

Modo numeric:

<NumericFormat
  {...register("preco")}
  onValueChange={(val) => {
    setValue(val.value); 
  }}
  allowLeadingZeros= {false}
  allowNegative= {false}
  decimalScale= {2}
  fixedDecimalScale= {true}
  decimalSeparator= ','
  allowedDecimalSeparators= {['.']}
  prefix= 'R$ '
  thousandSeparator= '.'
  //thousandGroupStyle= 'thousand'
  required                                  //Tive problemas com o .required() do Yup. Então removi lá e coloquei aqui
/>

------------------







































































//////////////////////////////////////////////////////////// &&& 
ANTIGO


////////////////////////////////////////////////////////////////&&&
MYSQL
VIDEO: https://www.youtube.com/embed/BgUxpPKw2LI?autoplay=1

-Para baixar o mysql:
https://dev.mysql.com/downloads/

-Escolha MySQL Installer for Windows
-Escolha a versão mais atual
-Baixe a versão completa (maior tamanho)
(não precisa fazer login. Só clique em No, thanks)

-Ao instalar, escolha a versão full
-Ao chegar em Type and Networking, como estamos apenas desenvolvendo, escolha a opção development computer
-Em Authentication Method, clique em RECOMMENDED
-Na proxima tela digite uma senha para o Banco de Dados
-No final da instalação, em Connect to Server, digite a senha que criou e clique em check e depois Next

O Painel do MySQL é acessado pelo MySQL Workbench.

-Ao abrir o MySQL Workbench, clique MySQL Connections e digite sua senha

OBS: Pode-se alterar o tamanho da fonte nas preferencias





////////////////////////////////////////////////////////////////&&&
FORMULARIO SIMPLES COM REACT, NODE E MYSQL
(CLAUDE AI)

-Configuração do Front-End:

-Crie uma pasta chamada client dentro da pasta do projeto. Crie uma pasta chamada components dentro de src. Nela crie o arquivo do componente para o formulario (Ex: FormularioAlunos.jsx)

-No arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {

  const [formData, setFormData] = useState({
    nome: '',
    email: ''
  });

  const [loading, setLoading] = useState(false);     //opcional
  const [message, setMessage] = useState('');

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();                             //Não é necessário caso esteja usando o Formik
    setLoading(true);                               //opcional
    setMessage('');

    console.log("Nome: " + formData.nome)           //opcional
    console.log("E-mail: " + formData.email)        //opcional

    try {
      const response = await axios.post('http://localhost:3001/api/alunos', formData);
      
      if (response.status === 201) {

        setMessage('Dados enviados com sucesso!');

        setFormData({ 
          nome: '', 
          email: '' 
        });
        
      }
    } catch (error) {                                                 //OU  } .catch ((err) => { ???
      if (error.response) {
        setMessage(`Erro: ${error.response.data.error}`);             //OU setMessage(err.response.data.mensagem) ???
      } else {
        setMessage('Erro de conexão: ' + error.message);
      }
    } finally {                        //opcional
      setLoading(false);
    }

  };

  return (
    <div>
      <h2>Formulário de Alunos</h2>
      
      <div onSubmit={handleSubmit}>
        <div>
          <label htmlFor="nome">Nome:</label>
          <input
            type="text"
            id="nome"
            name="nome"
            value={formData.nome}
            onChange={handleChange}
            required
          />
        </div>

        <div>
          <label htmlFor="email">Email:</label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            required
          />
        </div>

        <button 
          onClick={handleSubmit}
          disabled={loading}                    //opcional
          style={{
            cursor: loading ? 'not-allowed' : 'pointer'       //opcional
          }}
        >
          {loading ? 'Enviando...' : 'Enviar'}               //opcional
        </button>
      </div>

      <div>
        {message ? <p>{message}</p> : ""}                 //Para mostrar na tela se deu certo ou não
      </div>

    </div>
  );
}


OBS: Outra forma de mostrar na tela se o cadastro deu certo ou não mudando as cores da mensagem. Caso a mensagem tenha ou não a palavra sucesso no texto, terá uma cor diferente:

    <div>
      {message && (
        <div style={{  
          backgroundColor: message.includes('sucesso') ? '#d4edda' : '#f8d7da',
          border: `1px solid ${message.includes('sucesso') ? '#c3e6cb' : '#f5c6cb'}`,
        }}>
          {message}
        </div>
      )}
    </div>

----

Outra forma de lidar com o handleChange:

  const [formData, setFormData] = useState();

  const handleChange = (e) => {
    setFormData( (valores) => ({
      ...valores,
      [e.target.name]: e.target.value
    }));
  };

----

Forma simples do handleSubmit:

  const [formData, setFormData] = useState();

  const handleSubmit = () => {
    Axios.post("http://localhost:3000/api/alunos", {
      nome: formData.nome,
      email: formData.email
    })
    .then((response)=> {
      console.log(response)
    })
  }

------------

-No arquivo App.jsx dentro da pasta client:

import React from 'react'
import FormularioAlunos from './components/FormularioAlunos'

export default function App() {
  return (
    <>
      <FormularioAlunos />
    </>
  )
}

-Execute o arquivo App.jsx digitando no terminal:
npm run dev

Na url http://localhost:5173/ (usando o Vite) aparecerá o conteúdo

------------

-Configuração do Backend:

Crie a pasta server 

No terminal (dentro da pasta server) digite:
npm init   
(será instalado o arquivo package.json)

No terminal (dentro da pasta server) digite:
npm install express
(será instalado o express)

No terminal (dentro da pasta server) digite:
npm install cors
(será instalado o cors)

No terminal (dentro da pasta server) digite:
npm install mysql2
(será instalado o mysql2)

No terminal (dentro da pasta server) digite:
npm install nodemon
(será instalado o nodemon)

-No arquivo package.json altere a seguinte parte do codigo:

...
"scripts": {
  "dev": "nodemon server.js",
  "test": "echo \"Error: no test specified\" && exit 1"
}
...

-Com isso, para iniciar o servidor e ele ser atualizado automaticamente por causa do nodemon, pode-se usar no terminal os comandos:
yarn dev           (caso esteja usando o yarn)   TEM QUE INSTALAR O YARN
OU
npm run dev        (caso esteja usando o npm)    PADRÃO

-----

Dentro da pasta server, crie o arquivo server.js

No terminal (dentro da pasta server) digite:
node server.js

O servidor começará a rodar na porta escolhida no codigo (no caso a porta 3000)
Ela pode ser acessada pela url:  http://localhost:3000/
O numero da porta escolhida não é o mesmo onde o App.js do lado cliente é rodado (porta 5173 caso esteja usando o Vite)

-Vamos começar testando se o servidor conecta e recebe os dados do mysql.
-No arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                 
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root',                                    //usuário padrão do mysql
  password: 'password',                            //senha criada ao instalar o mysql para acessar o banco de dados
  database: 'world'                                //schema com dados que já existe no mysql por padrão
});

app.get('/', (req, res) => {
	return res.json("Conteúdo da url http://localhost:3000/");
})

app.get('/city', (req, res) => {
  const sql = 'SELECT * FROM city';                //tabela que existe dentro do schema world
  db.query(sql, (err, result) => {
    if (err) throw err;                            //OU if (err) return res.json(err);
    res.json(result);                              //OU return res.json(data);      
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

-Ao entrar na url http://localhost:3000/city os dados em JSON que estão no mysql aparecerão 

-----

Vamos agora adicionar o metodo POST e o resto codigo:
-No arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                 // Ou app.use(cors) ???
app.use(express.json());

const db = mysql.createConnection({              // Ou mysql.createPool() 
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'escola'
});

db.connect((err) => {                                    //Opcional
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.post('/api/alunos', (req, res) => {
  const { nome, email } = req.body;

  if (!nome || !email) {                                                        //Opcional
    return res.status(400).json({ error: 'Nome e email são obrigatórios' });
  }

  const query = 'INSERT INTO alunos (nome, email) VALUES (?, ?)';
  
  db.query(query, [nome, email], (err, result) => {
    if (err) {
      console.error('Erro ao inserir dados:', err);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
    
    res.status(201).json({ 
      message: 'Dados inseridos com sucesso', 
      id: result.insertId 
    });
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

------

Forma mais simples do app.post:

app.post("/api/produtos"), (req, res) => {
  const { nome, email } = req.body;

  const query = 'INSERT INTO usuarios (nome, email) VALUES (?, ?)';

  db.query(query, [nome, email], (err, result) {
    if (err) console.log(err);
    else res.send(result);
  })
};

----------------

-Crie o banco de dados (schema) chamado escola no MySQL.
-Crie a tabela alunos
-Adicione as colunas:
  id  = será INT e AI PK
  nome = será VARCHAR(255) e NN
  email = será VARCHAR(255) e NN UN

-Ou execute o codigo abaixo no MySQL:

CREATE DATABASE IF NOT EXISTS escola;

USE escola;

CREATE TABLE IF NOT EXISTS alunos (
  id INT AUTO_INCREMENT PRIMARY KEY,
  nome VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--------

-No diretório do seu projeto backend, instale as dependencias executando o codigo abaixo no terminal:

npm init -y
npm install express mysql2 cors

--------

-Como usar:

1- Configure o MySQL: Certifique-se de que o MySQL está rodando e ajuste as credenciais no server.js
2- Execute o backend: node server.js
3- Execute o React: O componente React acima já está configurado para enviar dados para http://localhost:3000

O formulário React irá capturar nome e email, e ao clicar em "Enviar", os dados serão enviados para o backend que os inserirá na tabela usuarios do banco Produtos01.

--------

-Para usar o fetch ao invés do axios, faça as alterações no codigo:

...
    try {
      const response = await fetch('http://localhost:3000/api/alunos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData)
      });

      if (response.ok) {
        setMessage('Dados enviados com sucesso!');
        setFormData({ nome: '', email: '' });
      } else {
        setMessage('Erro ao enviar dados');
      }
    } catch (error) {
      setMessage('Erro de conexão: ' + error.message);
    } finally {
      setLoading(false);                                 
    }
...

--------------

-Para deletar algum dado do MySql:

Arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                 
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'escola'
});

app.delete('/api/delete/:id', (req, res) => {

  const id = req.params.id;               // OU  const {id} = req.params;
  
  const query = 'DELETE FROM alunos WHERE id = ?';
  
  db.query(query, [id], (err, result) => {
    if (err) {
      return res.status(500).json({ message: 'Erro ao deletar' });
    }
    
    res.json({                            // Retorna informação sobre quantos registros foram afetados
      message: result.affectedRows > 0 ? 'Deletado com sucesso' : 'ID não encontrado',
      affectedRows: result.affectedRows 
    });
  });

});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

-------

-Arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {

  const [id, setId] = useState('');
  const [message, setMessage] = useState('');

  const handleDelete = async () => {

    setMessage('');

    try {
      const response = await axios.delete(`http://localhost:3000/api/delete/${id}`);
      
      if (response.status === 200) {
        if (response.data && response.data.affectedRows === 0) {
          setMessage('Nenhum aluno encontrado com esse ID');
        } else if (response.data && response.data.affectedRows > 0) {
          setMessage('Aluno deletado com sucesso!');
          setId(''); 
        } else {
          setMessage('Operação realizada com sucesso!');
          setId('');
        }
      }
    } catch (error) {
      if (error.response) {              // Erro do servidor (4xx, 5xx)
        setMessage(`Erro: ${error.response.data.message || 'Falha ao deletar aluno'}`);
      } else if (error.request) {        // Erro de rede
        setMessage('Erro de conexão com o servidor');
      } else {                           // Outros erros
        setMessage('Erro inesperado');
      }
      console.error('Erro ao deletar aluno:', error);
    } 
  };

  return (

      <div>
        <div>
          <input
            type="text"
            id="id"
            name="id"
            value={id}
            placeholder='Digite o id'
            onChange={(e) => setId(e.target.value)}
            required
          />
        </div>

        <button onClick={handleDelete}>DELETAR</button>

        {message && (
          <div>
            {message}
          </div>
        )}

      </div>

  );
}


------

Codigo mais elaborado:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {
  const [id, setId] = useState('');
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState('');

  const handleDelete = async () => {
    if (!id) {
      setMessage('Por favor, informe o ID do aluno');
      return;
    }

    setLoading(true);
    setMessage('');

    try {
      const response = await axios.delete(`http://localhost:3000/api/delete/${id}`);
      
      if (response.status === 200) {
        if (response.data && response.data.affectedRows === 0) {
          setMessage('Nenhum aluno encontrado com esse ID');
        } else if (response.data && response.data.affectedRows > 0) {
          setMessage('Aluno deletado com sucesso!');
          setId(''); 
        } else {
          setMessage('Operação realizada com sucesso!');
          setId('');
        }
      }
    } catch (error) {
      if (error.response) {              // Erro do servidor (4xx, 5xx)
        setMessage(`Erro: ${error.response.data.message || 'Falha ao deletar aluno'}`);
      } else if (error.request) {        // Erro de rede
        setMessage('Erro de conexão com o servidor');
      } else {                           // Outros erros
        setMessage('Erro inesperado');
      }
      console.error('Erro ao deletar aluno:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <div>
        <div>
          <label htmlFor="id">Id:</label>
          <input
            type="text"
            id="id"
            name="id"
            value={id}
            onChange={(e) => setId(e.target.value)}
            disabled={loading}
            required
          />
        </div>

        <button 
          onClick={handleDelete}
          disabled={loading || !id}
        >
          {loading ? 'Deletando...' : 'Delete'}
        </button>

        {message && (
          <div style={{ 
            marginTop: '10px', 
            padding: '8px', 
            borderRadius: '4px',
            backgroundColor: message.includes('sucesso') ? '#d4edda' : '#f8d7da',
            color: message.includes('sucesso') ? '#155724' : '#721c24'
          }}>
            {message}
          </div>
        )}
      </div>
    </div>
  );
}

---------------------------------

Para deletar os dados de um banco de dados MySQL:  (Usando o Fetch)

-Arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';

export default function FormularioAlunos() {

  const [id, setId] = useState('');
  const [message, setMessage] = useState('');

  const handleDelete = async () => {
    try {
      const response = await fetch(`http://localhost:3000/api/alunos/${id}`, {
        method: 'DELETE',
      });
      const data = await response.json();
      setMessage(data.message);
      setId('');
    } catch (error) {
      setMessage('Erro ao deletar aluno');
    }
  };

  return (
    <div>

      <div>
        <input
          type="number"
          value={id}
          onChange={(e) => setId(e.target.value)}
          placeholder="Digite o ID do aluno"
        />
      </div>

      <div>
        <button onClick={handleDelete}>Deletar</button>
      </div>

      {message && <div>{message}</div>}
      
    </div>
  );
}


-Arquivo server.js:

const express = require('express');
const cors = require('cors');
const mysql = require('mysql2');

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());

const db = mysql.createConnection({
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'escola' 
});

db.connect((err) => {
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.delete('/api/alunos/:id', (req, res) => {
  const { id } = req.params;
  
  const query = 'DELETE FROM alunos WHERE id = ?';
  
  db.query(query, [id], (err, result) => {
    if (err) {
      console.error('Erro ao deletar aluno:', err);
      return res.status(500).json({ message: 'Erro ao deletar aluno' });
    }
    
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Aluno não encontrado' });
    }
    
    res.json({ message: 'Aluno deletado com sucesso' });
  });
});

app.listen(port, () => {
  console.log(`Servidor rodando na porta ${port}`);
});

--------------------------------

Para editar os dados de um banco de dados MySQL:  (FORMA MAIS SIMPLES usando axios)

-Arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {
  
  const [id, setId] = useState('');
  const [nome, setNome] = useState('');
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      const response = await axios.put('http://localhost:3000/api/alunos', {
        id: parseInt(id),
        nome,
        email
      });
      
      setMessage('Dados editados com sucesso!');
      console.log('Item atualizado: ', response.data);
    } catch (error) {
      setMessage('Erro ao editar os dados');
      console.log('Erro: ', error);
    }
  };

  return (
    <div>
      <h2>Editar Aluno</h2>
      <div>
        <div>
          <label>ID:</label>
          <input
            type="number"
            value={id}
            onChange={(e) => setId(e.target.value)}
            required
          />
        </div>
        
        <div>
          <label>Nome:</label>
          <input
            type="text"
            value={nome}
            onChange={(e) => setNome(e.target.value)}
            required
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        
        <button onClick={handleSubmit}>Editar</button>

      </div>
      
      {message && <p>{message}</p>}

    </div>
  );
}


-Arquivo server.js:

const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());

const db = {
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'escola'
};

app.put('/api/alunos', async (req, res) => {
  const { id, nome, email } = req.body;
  
  try {
    const connection = await mysql.createConnection(db);
    
    const [result] = await connection.execute(
      'UPDATE alunos SET nome = ?, email = ? WHERE id = ?',
      [nome, email, id]
    );
    
    await connection.end();
    
    if (result.affectedRows > 0) {
      res.json({ success: true, message: 'Aluno atualizado com sucesso' });
    } else {
      res.status(404).json({ success: false, message: 'Aluno não encontrado' });
    }
    
  } catch (error) {
    console.error('Erro ao atualizar aluno:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.listen(port, () => {
  console.log(`Servidor rodando na porta ${port}`);
});

--------

Para editar os dados usando fetch ao invés do axios:

-Arquivo FormularioAlunos.jsx:

...
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      const response = await fetch('http://localhost:3000/api/alunos', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          id: parseInt(id),
          nome,
          email
        })
      });
      
      if (response.ok) {
        setMessage('Dados editados com sucesso!');
      } else {
        setMessage('Erro ao editar os dados');
      }
    } catch (error) {
      setMessage('Erro ao editar os dados');
    }
  };
...

-----------

Outra forma de fazer o codigo server.js:

A diferença principal é que:
Com mysql2/promise usamos async/await                                       // const mysql = require('mysql2/promise');
Com mysql2 normal usamos callbacks no estilo tradicional do Node.js         // const mysql = require('mysql2');

const mysql = require('mysql2');
Usa callbacks para lidar com a resposta da query MySQL, que é o padrão quando se usa mysql2 sem a versão promise.

const express = require('express');
const cors = require('cors');
const mysql = require('mysql2');

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());

const dbConfig = {
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'escola'
};

app.put('/api/alunos', async (req, res) => {
  const { id, nome, email } = req.body;
  
  try {
    const connection = await mysql.createConnection(dbConfig);
    
    const [result] = await connection.execute(
      'UPDATE alunos SET nome = ?, email = ? WHERE id = ?',
      [nome, email, id]
    );
    
    await connection.end();
    
    if (result.affectedRows > 0) {
      res.json({ success: true, message: 'Aluno atualizado com sucesso' });
    } else {
      res.status(404).json({ success: false, message: 'Aluno não encontrado' });
    }
    
  } catch (error) {
    console.error('Erro ao atualizar aluno:', error);
    res.status(500).json({ success: false, message: 'Erro interno do servidor' });
  }
});

app.listen(port, () => {
  console.log(`Servidor rodando na porta ${port}`);
});


--------------------------------

Para editar os dados de um banco de dados MySQL:  (FORMA MAIS COMPLICADA)

-Arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {

  const [formData, setFormData] = useState({
    id: '',
    nome: '',
    email: ''
  });

  const [message, setMessage] = useState('');

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };


  const handleEdit = async () => {

    if (!formData.id || !formData.nome || !formData.email) {
      setMessage('Todos os campos são obrigatórios');
      return;
    }

    setLoading(true);
    try {
      const response = await axios.put(`http://localhost:3000/api/delete/${formData.id}`, {
        nome: formData.nome,
        email: formData.email
      });

      if (response.data.success) {
        setMessage('Aluno editado com sucesso!');
      } else {
        setMessage('Erro ao editar aluno');
      }
    } catch (error) {
      console.error('Erro ao editar aluno:', error);
      setMessage('Erro ao editar aluno');
    }

  };

  const limparFormulario = () => {
    setFormData({
      id: '',
      nome: '',
      email: ''
    });
    setMessage('');   
  };

  return (

    <div>
      
      <div>
        <div>
          <input
            type="number"
            id="id"
            name="id"
            value={formData.id}
            placeholder="Digite o ID do aluno"
            onChange={handleChange}
            required
          />

          <button onClick={buscarAluno}>BUSCAR</button>

        </div>

        <div>
          <input
            type="text"
            id="nome"
            name="nome"
            value={formData.nome}
            placeholder="Digite o nome"
            onChange={handleChange}
            required
          />
        </div>

        <div>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            placeholder="Digite o email"
            onChange={handleChange}
            required
          />          
        </div>

      </div>

      <div>
        <button onClick={handleEdit}>EDITAR</button>
        <button onClick={limparFormulario}>LIMPAR</button>
      </div>

      {message && (
        <div>
          {message}
        </div>
      )}
    </div>
  );
}


-Arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                 
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'escola'
});


app.put('/api/delete/:id', (req, res) => {                           // Rota para atualizar um aluno

  const { id } = req.params;
  const { nome, email } = req.body;
  
  if (!nome || !email) {                                          // Validação dos dados
    return res.status(400).json({ 
      success: false, 
      message: 'Nome e email são obrigatórios' 
    });
  }
  
  const checkQuery = 'SELECT id FROM alunos WHERE id = ?';        // Verificar se o aluno existe
  
  db.query(checkQuery, [id], (err, results) => {
    if (err) {
      console.error('Erro ao verificar aluno:', err);
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    if (results.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aluno não encontrado' 
      });
    }
    
    const updateQuery = 'UPDATE alunos SET nome = ?, email = ? WHERE id = ?';         // Atualizar o aluno
    
    db.query(updateQuery, [nome, email, id], (err, result) => {
      if (err) {
        console.error('Erro ao atualizar aluno:', err);
        
        // Verificar se o erro é de email duplicado
        if (err.code === 'ER_DUP_ENTRY') {
          return res.status(400).json({ 
            success: false, 
            message: 'Este email já está sendo usado por outro aluno' 
          });
        }
        
        return res.status(500).json({ 
          success: false, 
          message: 'Erro interno do servidor' 
        });
      }
      
      res.json({ 
        success: true, 
        message: 'Aluno atualizado com sucesso',
        affectedRows: result.affectedRows
      });
    });
  });
});


app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});



------

Codigo mais elaborado:

-Arquivo FormularioAlunos.jsx:

import React, { useState } from 'react';
import axios from 'axios';

export default function FormularioAlunos() {
  const [formData, setFormData] = useState({
    id: '',
    nome: '',
    email: ''
  });

  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(false);

  // Função para atualizar os campos do formulário
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Função para buscar dados do aluno pelo ID
  const buscarAluno = async () => {
    if (!formData.id) {
      setMessage('Digite um ID para buscar o aluno');
      return;
    }

    setLoading(true);
    try {
      const response = await axios.get(`http://localhost:3000/alunos/${formData.id}`);
      
      if (response.data.success) {
        setFormData({
          id: response.data.aluno.id,
          nome: response.data.aluno.nome,
          email: response.data.aluno.email
        });
        setMessage('Aluno encontrado! Você pode editar os dados.');
      } else {
        setMessage('Aluno não encontrado');
      }
    } catch (error) {
      console.error('Erro ao buscar aluno:', error);
      setMessage('Erro ao buscar aluno');
    } finally {
      setLoading(false);
    }
  };

  // Função para editar os dados do aluno
  const handleEdit = async () => {
    if (!formData.id || !formData.nome || !formData.email) {
      setMessage('Todos os campos são obrigatórios');
      return;
    }

    setLoading(true);
    try {
      const response = await axios.put(`http://localhost:3000/alunos/${formData.id}`, {
        nome: formData.nome,
        email: formData.email
      });

      if (response.data.success) {
        setMessage('Aluno editado com sucesso!');
      } else {
        setMessage('Erro ao editar aluno');
      }
    } catch (error) {
      console.error('Erro ao editar aluno:', error);
      setMessage('Erro ao editar aluno');
    } finally {
      setLoading(false);
    }
  };

  // Função para limpar o formulário
  const limparFormulario = () => {
    setFormData({
      id: '',
      nome: '',
      email: ''
    });
    setMessage('');
  };

  return (
    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto' }}>
      <h2>Editar Aluno</h2>
      
      <div style={{ marginBottom: '20px' }}>
        <div style={{ marginBottom: '10px' }}>
          <input
            type="number"
            id="id"
            name="id"
            value={formData.id}
            placeholder="Digite o ID do aluno"
            onChange={handleChange}
            style={{ 
              width: '200px', 
              padding: '8px', 
              marginRight: '10px',
              border: '1px solid #ccc',
              borderRadius: '4px'
            }}
            required
          />
          <button 
            onClick={buscarAluno}
            disabled={loading}
            style={{
              padding: '8px 12px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            {loading ? 'Buscando...' : 'Buscar'}
          </button>
        </div>

        <div style={{ marginBottom: '10px' }}>
          <input
            type="text"
            id="nome"
            name="nome"
            value={formData.nome}
            placeholder="Digite o nome"
            onChange={handleChange}
            style={{ 
              width: '100%', 
              padding: '8px',
              border: '1px solid #ccc',
              borderRadius: '4px'
            }}
            required
          />
        </div>

        <div style={{ marginBottom: '10px' }}>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            placeholder="Digite o email"
            onChange={handleChange}
            style={{ 
              width: '100%', 
              padding: '8px',
              border: '1px solid #ccc',
              borderRadius: '4px'
            }}
            required
          />
        </div>
      </div>

      <div style={{ marginBottom: '20px' }}>
        <button 
          onClick={handleEdit}
          disabled={loading || !formData.id}
          style={{
            padding: '10px 20px',
            backgroundColor: '#28a745',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            marginRight: '10px',
            opacity: loading || !formData.id ? 0.6 : 1
          }}
        >
          {loading ? 'Editando...' : 'EDITAR'}
        </button>

        <button 
          onClick={limparFormulario}
          style={{
            padding: '10px 20px',
            backgroundColor: '#6c757d',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        >
          LIMPAR
        </button>
      </div>

      {message && (
        <div style={{
          padding: '10px',
          backgroundColor: message.includes('sucesso') ? '#d4edda' : '#f8d7da',
          color: message.includes('sucesso') ? '#155724' : '#721c24',
          border: `1px solid ${message.includes('sucesso') ? '#c3e6cb' : '#f5c6cb'}`,
          borderRadius: '4px'
        }}>
          {message}
        </div>
      )}
    </div>
  );
}

-Arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                 
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'escola'
});

db.connect((err) => {                                    
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

// Rota para buscar um aluno específico pelo ID
app.get('/alunos/:id', (req, res) => {
  const { id } = req.params;
  
  const query = 'SELECT * FROM alunos WHERE id = ?';
  
  db.query(query, [id], (err, results) => {
    if (err) {
      console.error('Erro ao buscar aluno:', err);
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    if (results.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aluno não encontrado' 
      });
    }
    
    res.json({ 
      success: true, 
      aluno: results[0] 
    });
  });
});

// Rota para listar todos os alunos
app.get('/alunos', (req, res) => {
  const query = 'SELECT * FROM alunos ORDER BY id';
  
  db.query(query, (err, results) => {
    if (err) {
      console.error('Erro ao buscar alunos:', err);
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    res.json({ 
      success: true, 
      alunos: results 
    });
  });
});

// Rota para atualizar um aluno
app.put('/alunos/:id', (req, res) => {
  const { id } = req.params;
  const { nome, email } = req.body;
  
  // Validação dos dados
  if (!nome || !email) {
    return res.status(400).json({ 
      success: false, 
      message: 'Nome e email são obrigatórios' 
    });
  }
  
  // Verificar se o aluno existe
  const checkQuery = 'SELECT id FROM alunos WHERE id = ?';
  
  db.query(checkQuery, [id], (err, results) => {
    if (err) {
      console.error('Erro ao verificar aluno:', err);
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    if (results.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aluno não encontrado' 
      });
    }
    
    // Atualizar o aluno
    const updateQuery = 'UPDATE alunos SET nome = ?, email = ? WHERE id = ?';
    
    db.query(updateQuery, [nome, email, id], (err, result) => {
      if (err) {
        console.error('Erro ao atualizar aluno:', err);
        
        // Verificar se o erro é de email duplicado
        if (err.code === 'ER_DUP_ENTRY') {
          return res.status(400).json({ 
            success: false, 
            message: 'Este email já está sendo usado por outro aluno' 
          });
        }
        
        return res.status(500).json({ 
          success: false, 
          message: 'Erro interno do servidor' 
        });
      }
      
      res.json({ 
        success: true, 
        message: 'Aluno atualizado com sucesso',
        affectedRows: result.affectedRows
      });
    });
  });
});

// Rota para criar um novo aluno
app.post('/alunos', (req, res) => {
  const { nome, email } = req.body;
  
  // Validação dos dados
  if (!nome || !email) {
    return res.status(400).json({ 
      success: false, 
      message: 'Nome e email são obrigatórios' 
    });
  }
  
  const query = 'INSERT INTO alunos (nome, email) VALUES (?, ?)';
  
  db.query(query, [nome, email], (err, result) => {
    if (err) {
      console.error('Erro ao criar aluno:', err);
      
      // Verificar se o erro é de email duplicado
      if (err.code === 'ER_DUP_ENTRY') {
        return res.status(400).json({ 
          success: false, 
          message: 'Este email já está cadastrado' 
        });
      }
      
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    res.status(201).json({ 
      success: true, 
      message: 'Aluno criado com sucesso',
      id: result.insertId
    });
  });
});

// Rota para deletar um aluno
app.delete('/alunos/:id', (req, res) => {
  const { id } = req.params;
  
  // Verificar se o aluno existe
  const checkQuery = 'SELECT id FROM alunos WHERE id = ?';
  
  db.query(checkQuery, [id], (err, results) => {
    if (err) {
      console.error('Erro ao verificar aluno:', err);
      return res.status(500).json({ 
        success: false, 
        message: 'Erro interno do servidor' 
      });
    }
    
    if (results.length === 0) {
      return res.status(404).json({ 
        success: false, 
        message: 'Aluno não encontrado' 
      });
    }
    
    // Deletar o aluno
    const deleteQuery = 'DELETE FROM alunos WHERE id = ?';
    
    db.query(deleteQuery, [id], (err, result) => {
      if (err) {
        console.error('Erro ao deletar aluno:', err);
        return res.status(500).json({ 
          success: false, 
          message: 'Erro interno do servidor' 
        });
      }
      
      res.json({ 
        success: true, 
        message: 'Aluno deletado com sucesso',
        affectedRows: result.affectedRows
      });
    });
  });
});

// Middleware para tratar rotas não encontradas
app.use('*', (req, res) => {
  res.status(404).json({ 
    success: false, 
    message: 'Rota não encontrada' 
  });
});

// Middleware para tratamento de erros
app.use((err, req, res, next) => {
  console.error('Erro não tratado:', err);
  res.status(500).json({ 
    success: false, 
    message: 'Erro interno do servidor' 
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

// Tratar o fechamento gracioso da aplicação
process.on('SIGINT', () => {
  console.log('Fechando conexão com o banco de dados...');
  db.end(() => {
    console.log('Conexão fechada. Encerrando aplicação.');
    process.exit(0);
  });
});

////////////////////////////////////////////////////////////////&&& ***
LOGIN COM REACT, MYSQL, FORMIK E YUP
VIDEO: https://www.youtube.com/embed/F_mXVI8Dalg?autoplay=1


Instale o formik e o yup na pasta client:
npm install axios
npm install formik --save
npm install yup --save

------

Formulario de Login:

-Arquivo Login.jsx:

import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';

export default function Login(){

  const handleClickLogin = (values) => console.log(values);

  const validationLogin = yup.object().shape({
    email: yup
      .string()
      .email("Não é um email")
      .required("Este campo é obrigatório"),
    senha: yup
      .string()
      .min(8, "A senha deve ter 8 caracteres")
      .required("Este campo é obrigatório"),
  });

  return (
    <div>

      <div className="container-login">
        <h1>Login</h1>

        <Formik 
          initialValues={{}} 
          onSubmit={handleClickLogin}
          validationSchema={validationLogin}
        >

          <Form className="login-form">

            <div className="login-form-group">
              <Field 
                name="email" 
                className="form-field"
                placeholder="Digite seu email"
              />
              <ErrorMessage
                component="span"
                name="email"
                className="form-error"
              />
            </div>

            <div className="login-form-group">
              <Field 
                name="senha" 
                className="form-field"
                placeholder="Digite sua senha"
                type="password"
              />
              <ErrorMessage
                component="span"
                name="senha"
                className="form-error"
              />
            </div>

            <button className="button" type="submit">Login</button>

          </Form>
        </Formik>
      </div>
      
    </div>
  )
}

-------

Formulario de Cadastro:

-Arquivo Cadastro.jsx:

import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import Axios from 'axios';

export default function Cadastro(){

  const handleClickCadastro = (values) => {
    Axios.post("http://localhost:3000/cadastro", {
      email: values.email,
      senha: values.senha,
    }) 
    .then ((response) => {
      console.log(response);
    });
  };

  const validationCadastro = yup.object().shape({
    email: yup
      .string()
      .email("Não é um email")
      .required("Este campo é obrigatório"),
    senha: yup
      .string()
      .min(8, "A senha deve ter 8 caracteres")
      .required("Este campo é obrigatório"),
    confirmSenha: yup
      .string()
      .oneOf([yup.ref("senha"), null], "As senhas não são iguais"),          //para checar se é o mesmo digitado na senha
  });

  return (
    <div>

      <div className="container-cadastro">
        <h1>Cadastro</h1>

        <Formik 
          initialValues={{}} 
          onSubmit={handleClickCadastro}
          validationSchema={validationCadastro}
        >

          <Form className="cadastro-form">

            <div className="login-cadastro-group">
              <Field 
                name="email" 
                className="form-field"
                placeholder="Digite seu email"
              />
              <ErrorMessage
                component="span"
                name="email"
                className="form-error"
              />
            </div>

            <div className="cadastro-form-group">
              <Field 
                name="senha" 
                className="form-field"
                placeholder="Digite sua senha"
                type= "password"
              />
              <ErrorMessage
                component="span"
                name="senha"
                className="form-error"
              />
            </div>

            <div className="cadastro-form-group">
              <Field 
                name="confirmSenha" 
                className="form-field"
                placeholder="Confirme a sua senha"
                type= "password"
              />
              <ErrorMessage
                component="span"
                name="confirmSenha"
                className="form-error"
              />
            </div>

            <button className="button" type="submit">Cadastro</button>

          </Form>
        </Formik>
      </div>
      
    </div>
  )
}

-----------------

Crie uma tabela no MySQL:

Nome do schema: loja
Nome da tabela: usuarios
Campos da tabela usuarios:
id = INT = PK NN AI
email = VARCHAR(45) = NN
password = VARCHAR(200) = NN           //200 pois será criado uma chave criptografada


------------------

BACKEND:

Dentro da pasta server:
npm init
npm 

Instale o express, cors, mysql2 e nodemon na pasta server:
npm install express
npm install cors
npm install mysql2
npm install nodemon

------

No arquivo server.js:
(para checar se o servidor está funcionando)

const express = require('express');
const app = express();
const mysql = require('mysql2');

const PORT = 3000;

app.get('/', (req, res) => {
	return res.json("SERVIDOR FUNCIONANDO");
})

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});


para rodar o servidor:
node server.js
ou npm run dev                 (caso use o nodemon e tenha editado o script em package.json)

--------

Adicionando o banco de dados MySQL ao servidor:

-Arquivo server.js:
const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'loja'
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.post('/cadastro', (req, res) => {
  const { email, senha } = req.body;

  const SQLconsulta = "SELECT * FROM usuarios WHERE email = ?";

  db.query(SQLconsulta, [email], (err, result) => {
    if (err) {
      console.log(err);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
    
    if (result.length == 0) {
      const SQLpost = 'INSERT INTO usuarios (email, senha) VALUES (?, ?)';

      db.query(SQLpost, [email, senha], (err, result) => {
        if (err) {
          alert(err);
          return res.status(500).json({ error: 'Erro ao cadastrar usuário' });
        }
        alert("Cadastrado com sucesso!");
        res.status(201).json({ message: 'Usuário cadastrado com sucesso!' });
      });
    } else {
      alert("Usuário já cadastrado!");
      res.status(409).json({ error: 'Usuário já cadastrado!' });
    }
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

//////////////////////////////////////
LOGIN E CADASTRO COM MYSQL, FORMIK E YUP
(CLAUDE AI)

-Arquivo login.jsx: 

import React, {useState} from 'react'
import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import axios from 'axios';

export default function Login(){

  const [loginError, setLoginError] = useState('');

const handleClickLogin = async (values) => {
  try {

    setLoginError('');               // Limpar erro anterior
    
    const response = await axios.post('http://localhost:3000/login', {
      email: values.email,
      senha: values.senha
    });
    
    if (response.status === 200) {                           // Verificar se a resposta foi bem-sucedida
      if (response.data.token) {                             // Armazenar token de autenticação (se fornecido)
        localStorage.setItem('token', response.data.token);
      }
      
      window.location.href = 'https://www.google.com';       // Redirecionar para página principal ou dashboard
      // navigate('/dashboard');                             // usando react-router-dom:
      
      console.log('Login realizado com sucesso!');
      
    } else {
      setLoginError('Erro no servidor. Tente novamente.');
    }
    
  } catch (error) {
    if (error.response) {
      const status = error.response.status;                     // Erro retornado pelo servidor
      
      if (status === 401) {
        setLoginError('Email ou senha incorretos.');
      } else if (status === 400) {
        setLoginError('Dados inválidos. Verifique os campos.');
      } else if (status === 500) {
        setLoginError('Erro interno do servidor. Tente novamente mais tarde.');
      } else {
        setLoginError('Erro ao fazer login. Tente novamente.');
      }
    } else if (error.request) {
      setLoginError('Erro de conexão. Verifique sua internet.');      // Erro de rede
    } else {
      setLoginError('Erro inesperado. Tente novamente.');             // Outros erros
    }
    
    console.error('Erro no login:', error);
  }
};

  const validationLogin = yup.object().shape({
    email: yup
      .string()
      .email("Não é um email")
      .required("Este campo é obrigatório"),
    senha: yup
      .string()
      .min(8, "A senha deve ter 8 caracteres")
      .required("Este campo é obrigatório"),
  });

  return (
    <div>

      <div className="container-login">
        <h1>Login</h1>

        <Formik 
          initialValues={{email: '', senha: ''}} 
          onSubmit={handleClickLogin}
          validationSchema={validationLogin}
        >

          <Form className="login-form">

            <div className="login-form-group">
              <Field 
                name="email" 
                className="form-field"
                placeholder="Digite seu email"
                type="email"
              />
              <ErrorMessage
                component="span"
                name="email"
                className="form-error"
              />
            </div>

            <div className="login-form-group">
              <Field 
                name="senha" 
                className="form-field"
                placeholder="Digite sua senha"
                type="password"
              />
              <ErrorMessage
                component="span"
                name="senha"
                className="form-error"
              />
            </div>

            <button className="button" type="submit">Login</button>

          </Form>
        </Formik>
      </div>

      <div>
        {loginError && <p style={{color: 'red'}}>{loginError}</p>}
      </div>
      
    </div>
  ) }

-----

Arquivo server.js (para o login):

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'loja'
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});


// Login route
app.post('/login', (req, res) => {
  try {
    const { email, senha } = req.body;

    if (!email || !senha) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios' });
    }

    db.execute('SELECT * FROM usuarios WHERE email = ?', [email], (err, results) => {
      if (err) {
        console.error('Erro ao buscar usuário:', err);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }

      if (results.length === 0) {
        return res.status(401).json({ error: 'Email ou senha incorretos' });
      }

      const user = results[0];

      if (senha !== user.senha) {
        return res.status(401).json({ error: 'Email ou senha incorretos' });
      }

      res.status(200).json({
        message: 'Login realizado com sucesso',
        user: {
          id: user.id,
          email: user.email
        }
      });
    });
  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

-----------------

-Arquivo cadastro.jsx:

import React, { useState } from 'react';
import {Formik, Form, Field, ErrorMessage} from 'formik';
import * as yup from 'yup';
import Axios from 'axios';

export default function Cadastro(){

  const [cadastroError, setCadastroError] = useState('');

  const handleClickCadastro = async (values) => {
    try {
      setCadastroError(''); // Limpa erros anteriores
      
      const response = await Axios.post('http://localhost:3000/cadastro', {
        email: values.email,
        senha: values.senha
      });

      if (response.status === 201) {
        alert('Usuário cadastrado com sucesso!');
        // URL('/login')                             // ou limpar o formulário
      }

    } catch (error) {
      if (error.response && error.response.data && error.response.data.error) {
        setCadastroError(error.response.data.error);
      } else {
        setCadastroError('Erro ao cadastrar usuário. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationCadastro = yup.object().shape({
    email: yup
      .string()
      .email("Não é um email")
      .required("Este campo é obrigatório"),
    senha: yup
      .string()
      .min(8, "A senha deve ter 8 caracteres")
      .required("Este campo é obrigatório"),
    confirmSenha: yup
      .string()
      .oneOf([yup.ref("senha"), null], "As senhas não são iguais"),          //para checar se é o mesmo digitado na senha
  });

  return (
  
    <div>

      <div className="container-cadastro">
        <h1>Cadastro</h1>

        <Formik 
          initialValues={{email: '', senha: '', confirmSenha: ''}} 
          onSubmit={handleClickCadastro}
          validationSchema={validationCadastro}
        >

          <Form className="cadastro-form">

            <div className="cadastro-form-group">
              <Field 
                name="email" 
                className="form-field"
                placeholder="Digite seu email"
              />
              <ErrorMessage
                component="span"
                name="email"
                className="form-error"
              />
            </div>

            <div className="cadastro-form-group">
              <Field 
                name="senha" 
                className="form-field"
                placeholder="Digite sua senha"
                type= "password"
              />
              <ErrorMessage
                component="span"
                name="senha"
                className="form-error"
              />
            </div>

            <div className="cadastro-form-group">
              <Field 
                name="confirmSenha" 
                className="form-field"
                placeholder="Confirme a sua senha"
                type= "password"
              />
              <ErrorMessage
                component="span"
                name="confirmSenha"
                className="form-error"
              />
            </div>

            <button className="button" type="submit">Cadastro</button>

          </Form>
        </Formik>
      </div>

      <div>
        {cadastroError && <p style={{color: 'red'}}>{cadastroError}</p>}
      </div>

    </div>
  )
}

----------

-Arquivo server.js: (para o cadastro)

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');

const app = express();
const PORT = 3000;

app.use(cors());                                
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'loja'
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.post('/cadastro', (req, res) => {
  try {
    const { email, senha } = req.body;

    if (!email || !senha) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios' });
    }

    if (senha.length < 8) {
      return res.status(400).json({ error: 'A senha deve ter pelo menos 8 caracteres' });
    }

    db.execute('SELECT * FROM usuarios WHERE email = ?', [email], (err, results) => {
      if (err) {
        console.error('Erro ao verificar usuário:', err);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }

      if (results.length > 0) {
        return res.status(400).json({ error: 'Usuário já existe' });
      }

      db.execute(
        'INSERT INTO usuarios (email, senha) VALUES (?, ?)',
        [email, senha],
        (err, results) => {
          if (err) {
            console.error('Erro ao criar usuário:', err);
            return res.status(500).json({ error: 'Erro interno do servidor' });
          }

          res.status(201).json({ message: 'Usuário criado com sucesso' });
        }
      );
    });
  } catch (error) {
    console.error('Erro no registro:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

-----------
///////////////////////////////////////////////&&& ###
LOGIN E CADASTRO COM JWT E BCRYPT

Instalação na pasta server:
npm install bcrypt                  (para login e cadastro)
npm install jasonwebtoken           (para login)


---------- ###

-Arquivo server.js: (codigo para cadastrar)

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bcrypt = require('bcrypt');             

const app = express();
const PORT = 3000;

app.use(cors());                                
app.use(express.json());

const db = mysql.createConnection({              
  host: 'localhost',
  user: 'root', 
  password: 'password', 
  database: 'loja'
});

db.connect((err) => {                                   
  if (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});


// Register route
app.post('/cadastro', async (req, res) => {
  try {
    const { email, senha } = req.body;

    if (!email || !senha) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios' });
    }

    if (senha.length < 8) {
      return res.status(400).json({ error: 'A senha deve ter pelo menos 8 caracteres' });
    }

    db.execute('SELECT * FROM usuarios WHERE email = ?', [email], async (err, results) => {
      if (err) {
        console.error('Erro ao verificar usuário:', err);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }

      if (results.length > 0) {
        return res.status(400).json({ error: 'Usuário já existe' });
      }

      const hashedPassword = await bcrypt.hash(senha, 10);          // Hash password

      db.execute(
        'INSERT INTO usuarios (email, senha) VALUES (?, ?)',
        [email, hashedPassword],
        (err, results) => {
          if (err) {
            console.error('Erro ao criar usuário:', err);
            return res.status(500).json({ error: 'Erro interno do servidor' });
          }

          res.status(201).json({ message: 'Usuário criado com sucesso' });
        }
      );
    });
  } catch (error) {
    console.error('Erro no registro:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});


app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

---------- ### &&&

You can generate a token in the console by running this command:

node -e "console.log(require('crypto').randomBytes(32).toString('hex'));"

If the generated string is a1b2c3d4e5f6..., you would add the following line to your .env file:
JWT_SECRET=a1b2c3d4e5f6...

And in your code, you would access it like this:
const jwtSecret = process.env.JWT_SECRET;

-----
Para colocar algumas informações privadas separadamente dentro do arquivo .env

Instale o dotenv:
npm i dotenv

-Arquivo .env:

# React App Variables
API_BASE_URL = http://localhost:3000/api
JWT_SECRET = your_jwt_secret_key

# MySQL Database Variables (for a Node.js/Express backend)
DB_HOST = localhost
DB_USER = your_user
DB_PASSWORD = your_password
DB_NAME = your_schema
DB_PORT = 3000

OBS: Depois de criar o arquivo .env, lembre-se de não enviá-lo para o GitHub, já que ele pode conter dados confidenciais, como chaves de autenticação e senhas. Adicione o arquivo ao .gitignore para evitar de enviá-lo a um repositório público por acidente.

-Arquivo server.js:

const dotenv = require('dotenv').config()

const PORT = process.env.DB_PORT;

const db = mysql.createConnection({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME
});

const jwtSecret = process.env.JWT_SECRET;

app.listen(process.env.DB_PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});


------- ### ***

CODIGO COM LOGIN E CADASTRO:

-Arquivo Login.jsx:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Login() {

  const [loginMessage, setLoginMessage] = useState('');
  const [registerMessage, setRegisterMessage] = useState('');

  const loginValidationSchema = Yup.object({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    senha: Yup.string()
      .min(8, 'Senha deve ter no mínimo 8 caracteres')
      .matches(/[A-Z]/, 'Senha deve conter pelo menos uma letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'Senha deve conter pelo menos um caractere especial')
      .test('no-spaces', 'Senha não pode conter espaços', value => !value || !value.includes(' '))
      .required('Senha é obrigatória')
  });

  const registerValidationSchema = Yup.object({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    senha: Yup.string()
      .min(8, 'Senha deve ter no mínimo 8 caracteres')
      .matches(/[A-Z]/, 'Senha deve conter pelo menos uma letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'Senha deve conter pelo menos um caractere especial')
      .test('no-spaces', 'Senha não pode conter espaços', value => !value || !value.includes(' '))
      .required('Senha é obrigatória')
  });

  const handleLogin = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/login', values);
      setLoginMessage('Login realizado com sucesso!');
      resetForm();
    } catch (error) {
      alert(error);
      setLoginMessage(error.response?.data?.message || 'Erro ao fazer login');
    } finally {
      setSubmitting(false);
    }
  };

  const handleRegister = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/register', values);
      setRegisterMessage('Usuário cadastrado com sucesso!');
      resetForm();
    } catch (error) {
      setRegisterMessage(error.response?.data?.message || 'Erro ao cadastrar usuário');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <div>
        <h2>Login</h2>
        <Formik
          initialValues={{ email: '', senha: '' }}
          validationSchema={loginValidationSchema}
          onSubmit={handleLogin}
        >
          {({ isSubmitting }) => (
            <Form>
              <div>
                <Field
                  type="email"
                  name="email"
                  placeholder="Email"
                />
                <ErrorMessage name="email" component="div" />
              </div>
              <div>
                <Field
                  type="password"
                  name="senha"
                  placeholder="Senha"
                />
                <ErrorMessage name="senha" component="div" />
              </div>
              <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Entrando...' : 'Entrar'}
              </button>
            </Form>
          )}
        </Formik>
        {loginMessage && <div>{loginMessage}</div>}
      </div>

      <div>
        <h2>Cadastro</h2>
        <Formik
          initialValues={{ email: '', senha: '' }}
          validationSchema={registerValidationSchema}
          onSubmit={handleRegister}
        >
          {({ isSubmitting }) => (
            <Form>
              <div>
                <Field
                  type="email"
                  name="email"
                  placeholder="Email"
                />
                <ErrorMessage name="email" component="div" />
              </div>
              <div>
                <Field
                  type="password"
                  name="senha"
                  placeholder="Senha"
                />
                <ErrorMessage name="senha" component="div" />
              </div>
              <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Cadastrando...' : 'Cadastrar'}
              </button>
            </Form>
          )}
        </Formik>
        {registerMessage && <div>{registerMessage}</div>}
      </div>
    </div>
  );
};

------ ###

-Arquivo server.js:   

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = 3000;

// Configurações do banco de dados
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja'
  //charset: 'utf8mb4'             //opcional
});

// Middleware
app.use(cors());
app.use(express.json());

// Chave secreta JWT          //OU const JWT_SECRET = process.env.JWT_SECRET;
const JWT_SECRET = '4864d6f2e6dcd8c6b322de6cc2158acd69c1b2984d1a30116afb2da294299c86';   

// Conectar ao banco de dados
db.connect((err) => {
  if (err) {
    console.error('Erro ao conectar ao banco de dados:', err);
    return;                                                         //Ou process.exit(1);
  }
  console.log('Conectado ao banco de dados MySQL');
});

// Rota para cadastro de usuário
app.post('/register', (req, res) => {
  const { email, senha } = req.body;

  // Verificar se o usuário já existe
  const checkUserQuery = 'SELECT * FROM usuarios WHERE email = ?';
  db.query(checkUserQuery, [email], (err, results) => {
    if (err) {
      console.error('Erro ao verificar usuário:', err);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }

    if (results.length > 0) {
      return res.status(400).json({ message: 'Usuário já existe' });
    }

    // Criptografar a senha
    bcrypt.hash(senha, 10, (err, hashedPassword) => {
      if (err) {
        console.error('Erro ao criptografar senha:', err);
        return res.status(500).json({ message: 'Erro interno do servidor' });
      }

      // Inserir o usuário no banco
      const insertUserQuery = 'INSERT INTO usuarios (email, senha) VALUES (?, ?)';
      db.query(insertUserQuery, [email, hashedPassword], (err, results) => {
        if (err) {
          console.error('Erro ao inserir usuário:', err);
          return res.status(500).json({ message: 'Erro ao cadastrar usuário' });
        }

        res.status(201).json({ message: 'Usuário cadastrado com sucesso' });
      });
    });
  });
});

// Rota para login
app.post('/login', (req, res) => {
  const { email, senha } = req.body;

  // Buscar o usuário no banco
  const getUserQuery = 'SELECT * FROM usuarios WHERE email = ?';
  db.query(getUserQuery, [email], (err, results) => {
    if (err) {
      console.error('Erro ao buscar usuário:', err);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }

    // Verificar se o usuário existe
    if (results.length === 0) {
      return res.status(401).json({ message: 'Email ou senha inválidos' });
    }

    const user = results[0];

    // Verificar a senha
    bcrypt.compare(senha, user.senha, (err, isValid) => {
      if (err) {
        console.error('Erro ao comparar senha:', err);
        return res.status(500).json({ message: 'Erro interno do servidor' });
      }

      if (!isValid) {
        return res.status(401).json({ message: 'Email ou senha incorretos' });
      }

      // Gerar token JWT
      const token = jwt.sign(
        { id: user.id, email: user.email },
        JWT_SECRET,
        { expiresIn: '1h' }      // Token válido por 1 hora
      );

      // Resposta de sucesso
      res.json({
        message: 'Login realizado com sucesso',
        token,
        user: {
          id: user.id,
          email: user.email
        }
      });
    });
  });
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

------------ ###

Apenas o login:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Login() {

  const [loginMessage, setLoginMessage] = useState('');

  const loginValidationSchema = Yup.object({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    senha: Yup.string()
      .min(8, 'Senha deve ter no mínimo 8 caracteres')
      .matches(/[A-Z]/, 'Senha deve conter pelo menos uma letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'Senha deve conter pelo menos um caractere especial')
      .test('no-spaces', 'Senha não pode conter espaços', value => !value || !value.includes(' '))
      .required('Senha é obrigatória')
  });

  const handleLogin = async (values, { setSubmitting, resetForm }) => {
    try {
      const response = await axios.post('http://localhost:3000/login', values);
      setLoginMessage('Login realizado com sucesso!');
      resetForm();
    } catch (error) {
      alert(error);
      setLoginMessage(error.response?.data?.message || 'Erro ao fazer login');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <div>
        <h2>Login</h2>
        <Formik
          initialValues={{ email: '', senha: '' }}
          validationSchema={loginValidationSchema}
          onSubmit={handleLogin}
        >
          {({ isSubmitting }) => (
            <Form>
              <div>
                <Field
                  type="email"
                  name="email"
                  placeholder="Email"
                />
                <ErrorMessage name="email" component="div" />
              </div>
              <div>
                <Field
                  type="password"
                  name="senha"
                  placeholder="Senha"
                />
                <ErrorMessage name="senha" component="div" />
              </div>
              <button type="submit" disabled={isSubmitting}>
                {isSubmitting ? 'Entrando...' : 'Entrar'}
              </button>
            </Form>
          )}
        </Formik>
        {loginMessage && <div>{loginMessage}</div>}
      </div>
      
    </div>
  );
};

-------- ###

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = 3000;

// Configurações do banco de dados
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja'
});

// Middleware
app.use(cors());
app.use(express.json());

// Chave secreta JWT
const JWT_SECRET = 'dde4b11c5283c8239738b1a824ca4519a716e562253083b1024ac7c532087576';

// Conectar ao banco de dados
db.connect((err) => {
  if (err) {
    console.error('Erro ao conectar ao banco de dados:', err);
    return;
  }
  console.log('Conectado ao banco de dados MySQL');
});

// Rota para login
app.post('/login', (req, res) => {
  const { email, senha } = req.body;

  // Buscar o usuário no banco
  const getUserQuery = 'SELECT * FROM usuarios WHERE email = ?';
  db.query(getUserQuery, [email], (err, results) => {
    if (err) {
      console.error('Erro ao buscar usuário:', err);
      return res.status(500).json({ message: 'Erro interno do servidor' });
    }

    if (results.length === 0) {
      return res.status(401).json({ message: 'Email ou senha inválidos' });
    }

    const user = results[0];

    // Verificar a senha
    bcrypt.compare(senha, user.senha, (err, isValid) => {
      if (err) {
        console.error('Erro ao comparar senha:', err);
        return res.status(500).json({ message: 'Erro interno do servidor' });
      }

      if (!isValid) {
        return res.status(401).json({ message: 'Email ou senha inválidos' });
      }

      // Gerar token JWT
      const token = jwt.sign(
        { id: user.id, email: user.email },
        JWT_SECRET,
        { expiresIn: '1h' }
      );

      res.json({
        message: 'Login realizado com sucesso',
        token,
        user: {
          id: user.id,
          email: user.email
        }
      });
    });
  });
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

--------------###

Rota de login alternativa usando async:


// Rota de login
app.post('/login', async (req, res) => {
  try {
    const { email, senha } = req.body;

    // Validação dos campos obrigatórios
    if (!email || !senha) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios' });
    }

    // Validação básica de email caso não tenha sido feito no Yup
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Email inválido' });
    }

    // Buscar usuário no banco de dados
    db.execute('SELECT * FROM usuarios WHERE email = ?', [email], async (err, results) => {
      if (err) {
        console.error('Erro ao buscar usuário:', err);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }

      // Verificar se o usuário existe
      if (results.length === 0) {
        return res.status(401).json({ error: 'Email ou senha incorretos' });
      }

      const user = results[0];

      // Comparar senha com hash (Verificar senha)
      try {
        const isPasswordValid = await bcrypt.compare(senha, user.senha);
        
        if (!isPasswordValid) {
          return res.status(401).json({ error: 'Email ou senha incorretos' });
        }

        // Gerar JWT token
        const token = jwt.sign(
          { 
            id: user.id, 
            email: user.email
          },
          JWT_SECRET,
          { expiresIn: '24h' } // Token válido por 24 horas
        );

        // Resposta de sucesso
        res.status(200).json({
          message: 'Login realizado com sucesso',
          token: token,
          user: {
            id: user.id,
            email: user.email
          }
        });

      } catch (bcryptError) {
        console.error('Erro ao comparar senha:', bcryptError);
        return res.status(500).json({ error: 'Erro interno do servidor' });
      }
    });

  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

----- ###

Conectando ao banco de dados de forma alternativa com async (que lança um try/catch):

const mysql = require('mysql2/promise');

const db = {
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja'
};

async function connectToDatabase() {
  try {
    const connection = await mysql.createConnection(db);
    console.log('Conectado ao MySQL');
    return connection;
  } catch (err) {
    console.error('Erro ao conectar ao MySQL:', err);
    throw err; // Re-throw the error to prevent the app from starting
  }
}

// Login route
app.post('/login', async (req, res) => {
  try {
    const { email, senha } = req.body;

    if (!email || !senha) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios' });
    }

    const connection = await connectToDatabase();

    try {
      const [results] = await connection.execute('SELECT * FROM usuarios WHERE email = ?', [email]);

      if (results.length === 0) {
        return res.status(401).json({ error: 'Email ou senha incorretos' });
      }

      const user = results[0];

      // Compare password
      const isPasswordValid = await bcrypt.compare(senha, user.senha);

      if (!isPasswordValid) {
        return res.status(401).json({ error: 'Email ou senha incorretos' });
      }

      // Generate JWT token
      const token = jwt.sign(
        { id: user.id, email: user.email },
        JWT_SECRET,
        { expiresIn: '1h' }
      );

      res.status(200).json({
        message: 'Login realizado com sucesso',
        token: token,
        user: {
          id: user.id,
          email: user.email
        }
      });
    } finally {
      await connection.end();
    }
  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Protected route example
app.get('/protected', (req, res) => {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token não fornecido' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    res.json({ message: 'Acesso autorizado', user: decoded });
  } catch (error) {
    res.status(401).json({ error: 'Token inválido' });
  }
});


async function startServer() {
  try {
    await connectToDatabase(); // Ensure database connection before starting the server
    app.listen(PORT, () => {
      console.log(`Servidor rodando na porta ${PORT}`);
    });
  } catch (error) {
    console.error("Falha ao iniciar o servidor:", error);
  }
}

startServer();


------------ ###

Coisas adicionais no arquivo server.js: 

// Middleware para verificar token JWT
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token de acesso requerido' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token inválido' });
    }
    req.user = user;
    next();
  });
};

// Rota protegida para testar o token
app.get('/perfil', authenticateToken, (req, res) => {
  res.json({
    message: 'Acesso autorizado',
    user: req.user
  });
});

// Rota de teste
app.get('/test', (req, res) => {
  res.json({ message: 'Servidor funcionando!' });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nFechando servidor...');
  db.end(() => {
    console.log('Conexão com MySQL encerrada.');
    process.exit(0);
  });
});

// Tratamento de erros não capturados
process.on('uncaughtException', (err) => {
  console.error('Erro não capturado:', err);
  process.exit(1);
});

process.on('unhandledRejection', (err) => {
  console.error('Promise rejeitada:', err);
  process.exit(1);
});

------------ ###

Para obter token (e guardar nos cookies???):


export default function Login() {
  const [loginMessage, setLoginMessage] = useState('');

  const handleClickLogin = async (values, { setSubmitting }) => {
    try {
      setLoginMessage('');
      
      console.log('Enviando dados de login:', { email: values.email });
      
      const response = await axios.post('http://localhost:3000/login', {
        email: values.email,
        senha: values.senha
      }, {
        timeout: 10000,                          
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (response.status === 200 && response.data.token) {
        // Armazenar token e dados do usuário
        localStorage.setItem('token', response.data.token);
        localStorage.setItem('user', JSON.stringify(response.data.user));
        
        setLoginMessage('Login realizado com sucesso!');
        console.log('Dados do usuário:', response.data.user);
        
        // Redirecionar para página principal
        // Para usar react-router-dom, descomente a linha abaixo:
        // navigate('/dashboard');
        
        // Redirecionamento simples
        //window.location.href = '/dashboard'; // ou a rota desejada
        
      } else {
        setLoginMessage('Erro no servidor. Tente novamente.');
      }
      
    } catch (error) {
      console.error('Erro no login:', error);
      
      if (error.response) {
        // Erro retornado pelo servidor
        const status = error.response.status;
        const errorMessage = error.response.data?.error || 'Erro desconhecido';
        
        switch (status) {
          case 401:
            setLoginMessage('Email ou senha incorretos.');
            break;
          case 400:
            setLoginMessage('Dados inválidos. Verifique os campos.');
            break;
          case 500:
            setLoginMessage('Erro interno do servidor. Tente novamente mais tarde.');
            break;
          default:
            setLoginMessage(`Erro: ${errorMessage}`);
        }
      } else if (error.request) {
        // Erro de rede
        setLoginMessage('Erro de conexão. Verifique se o servidor está rodando.');
      } else if (error.code === 'ECONNABORTED') {
        // Timeout
        setLoginMessage('Timeout na conexão. Tente novamente.');
      } else {
        // Outros erros
        setLoginMessage('Erro inesperado. Tente novamente.');
      }
    } finally {
      setSubmitting(false);
    }
  };

  const validationLogin = yup.object().shape({
    ...
  });

  return (
    ...
  )
}

// Função utilitária para verificar se o usuário está logado
export const isUserLoggedIn = () => {
  const token = localStorage.getItem('token');
  const user = localStorage.getItem('user');
  return token && user;
};

// Função utilitária para fazer logout
export const logout = () => {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  window.location.href = '/login';
};

// Função utilitária para obter dados do usuário
export const getCurrentUser = () => {
  try {
    const user = localStorage.getItem('user');
    return user ? JSON.parse(user) : null;
  } catch (error) {
    console.error('Erro ao obter dados do usuário:', error);
    return null;
  }
};

// Função utilitária para obter token
export const getToken = () => {
  return localStorage.getItem('token');
};

------------------ ###

Para alterar a senha cadastrada usando o email como identificador:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Login() {
  const [message, setMessage] = useState('');
  const [isSuccess, setIsSuccess] = useState(false);

  const validationSchema = Yup.object({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    senha: Yup.string()
      .min(8, 'A senha deve ter no mínimo 8 caracteres')
      .matches(/[A-Z]/, 'A senha deve conter pelo menos 1 letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'A senha deve conter pelo menos 1 caractere especial')
      .matches(/^\S*$/, 'A senha não pode conter espaços')
      .required('Senha é obrigatória')
  });

  const handleSubmit = async (values, { setSubmitting }) => {
    try {
      const response = await axios.post('http://localhost:3000/login', {
        email: values.email,
        senha: values.senha
      });

      if (response.data.success) {
        setMessage('Senha atualizada com sucesso!');
        setIsSuccess(true);
      } else {
        setMessage(response.data.message || 'Erro ao atualizar senha');
        setIsSuccess(false);
      }
    } catch (error) {
      if (error.response && error.response.data) {
        setMessage(error.response.data.message || 'Erro no servidor');
      } else {
        setMessage('Erro de conexão com o servidor');
      }
      setIsSuccess(false);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <h2>Alteração de Senha</h2>
      <Formik
        initialValues={{ email: '', senha: '' }}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({ isSubmitting }) => (
          <Form>
            <div>
              <label htmlFor="email">Email:</label>
              <Field type="email" id="email" name="email" />
              <ErrorMessage name="email" component="div" />
            </div>

            <div>
              <label htmlFor="senha">Nova Senha:</label>
              <Field type="password" id="senha" name="senha" />
              <ErrorMessage name="senha" component="div" />
            </div>

            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Processando...' : 'Atualizar Senha'}
            </button>
          </Form>
        )}
      </Formik>

      {message && (
        <div style={{ color: isSuccess ? 'green' : 'red', marginTop: '10px' }}>
          {message}
        </div>
      )}
    </div>
  );
};

--------

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = 3000;
const JWT_SECRET = '4864d6f2e6dcd8c6b322de6cc2158acd69c1b2984d1a30116afb2da294299c86';

// Middleware
app.use(cors());
app.use(express.json());

// Configuração do banco de dados MySQL
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja'
});

// Conectar ao banco de dados
db.connect((err) => {
  if (err) {
    console.error('Erro ao conectar ao banco de dados:', err);
    return;
  }
  console.log('Conectado ao banco de dados MySQL');
});

// Rota para login e alteração de senha
app.post('/login', (req, res) => {
  const { email, senha } = req.body;

  if (!email || !senha) {
    return res.status(400).json({
      success: false,
      message: 'Email e senha são obrigatórios'
    });
  }

  // Verificar se o usuário existe no banco de dados
  const query = 'SELECT * FROM usuarios WHERE email = ?';
  
  db.query(query, [email], (err, results) => {
    if (err) {
      console.error('Erro na consulta:', err);
      return res.status(500).json({
        success: false,
        message: 'Erro interno do servidor'
      });
    }

    if (results.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Usuário não encontrado'
      });
    }

    const usuario = results[0];

    // Criptografar a nova senha
    bcrypt.hash(senha, 10, (err, hashedPassword) => {
      if (err) {
        console.error('Erro ao criptografar senha:', err);
        return res.status(500).json({
          success: false,
          message: 'Erro ao processar senha'
        });
      }

      // Atualizar a senha no banco de dados
      const updateQuery = 'UPDATE usuarios SET senha = ? WHERE email = ?';
      
      db.query(updateQuery, [hashedPassword, email], (err, updateResults) => {
        if (err) {
          console.error('Erro ao atualizar senha:', err);
          return res.status(500).json({
            success: false,
            message: 'Erro ao atualizar senha'
          });
        }

        if (updateResults.affectedRows === 0) {
          return res.status(400).json({
            success: false,
            message: 'Não foi possível atualizar a senha'
          });
        }

        // Gerar token JWT
        const token = jwt.sign(
          { 
            id: usuario.id, 
            email: usuario.email 
          },
          JWT_SECRET,
          { expiresIn: '1h' }
        );

        res.json({
          success: true,
          message: 'Senha atualizada com sucesso',
          token: token,
          user: {
            id: usuario.id,
            email: usuario.email
          }
        });
      });
    });
  });
});

// Middleware para verificar token JWT
const verifyToken = (req, res, next) => {
  const token = req.headers['authorization'];

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Token não fornecido'
    });
  }

  jwt.verify(token.replace('Bearer ', ''), JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({
        success: false,
        message: 'Token inválido'
      });
    }

    req.user = decoded;
    next();
  });
};

// Rota protegida de exemplo
app.get('/api/protected', verifyToken, (req, res) => {
  res.json({
    success: true,
    message: 'Acesso autorizado',
    user: req.user
  });
});

// Iniciar o servidor
app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

// Tratamento de erros não capturados
process.on('uncaughtException', (err) => {
  console.error('Erro não capturado:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Rejeição não tratada:', reason);
  process.exit(1);
});

-------------------- ###

Formulario com email (para verificar conta), senha antiga (cadastrada no MySQL) e senha nova (que alterará a senha cadastrada):

-Arquivo Login.jsx:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Login() {
  const [message, setMessage] = useState('');
  const [isSuccess, setIsSuccess] = useState(false);

  const validationSchema = Yup.object({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    senhaAntiga: Yup.string()
      .required('Senha antiga é obrigatória'),
    senhaNova: Yup.string()
      .min(8, 'A senha deve ter no mínimo 8 caracteres')
      .matches(/[A-Z]/, 'A senha deve conter pelo menos 1 letra maiúscula')
      .matches(/[!@#$%^&*(),.?":{}|<>]/, 'A senha deve conter pelo menos 1 caractere especial')
      .matches(/^\S*$/, 'A senha não pode conter espaços')
      .required('Nova senha é obrigatória')
  });

  const handleSubmit = async (values, { setSubmitting }) => {
    try {
      const response = await axios.post('http://localhost:3000/login', {
        email: values.email,
        senhaAntiga: values.senhaAntiga,
        senhaNova: values.senhaNova
      });

      if (response.data.success) {
        setMessage('Senha atualizada com sucesso!');
        setIsSuccess(true);
      } else {
        setMessage(response.data.message || 'Erro ao atualizar senha');
        setIsSuccess(false);
      }
    } catch (error) {
      if (error.response && error.response.data) {
        setMessage(error.response.data.message || 'Erro no servidor');
      } else {
        setMessage('Erro de conexão com o servidor');
      }
      setIsSuccess(false);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div>
      <h2>Alteração de Senha</h2>
      <Formik
        initialValues={{ email: '', senhaAntiga: '', senhaNova: '' }}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({ isSubmitting }) => (
          <Form>
            <div>
              <label htmlFor="email">Email:</label>
              <Field type="email" id="email" name="email" />
              <ErrorMessage name="email" component="div" />
            </div>

            <div>
              <label htmlFor="senhaAntiga">Senha Atual:</label>
              <Field type="password" id="senhaAntiga" name="senhaAntiga" />
              <ErrorMessage name="senhaAntiga" component="div" />
            </div>

            <div>
              <label htmlFor="senhaNova">Nova Senha:</label>
              <Field type="password" id="senhaNova" name="senhaNova" />
              <ErrorMessage name="senhaNova" component="div" />
            </div>

            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Processando...' : 'Atualizar Senha'}
            </button>
          </Form>
        )}
      </Formik>

      {message && (
        <div style={{ color: isSuccess ? 'green' : 'red', marginTop: '10px' }}>
          {message}
        </div>
      )}
    </div>
  );
};

--------

-Arquivo server.js:

const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

const app = express();
const PORT = 3000;
const JWT_SECRET = '4864d6f2e6dcd8c6b322de6cc2158acd69c1b2984d1a30116afb2da294299c86';

// Middleware
app.use(cors());
app.use(express.json());

// Configuração do banco de dados MySQL
const db = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'loja'
});

// Conectar ao banco de dados
db.connect((err) => {
  if (err) {
    console.error('Erro ao conectar ao banco de dados:', err);
    return;
  }
  console.log('Conectado ao banco de dados MySQL');
});

// Rota para login e alteração de senha
app.post('/login', (req, res) => {
  const { email, senhaAntiga, senhaNova } = req.body;

  if (!email || !senhaAntiga || !senhaNova) {
    return res.status(400).json({
      success: false,
      message: 'Email, senha antiga e nova senha são obrigatórios'
    });
  }

  // Verificar se o usuário existe no banco de dados
  const query = 'SELECT * FROM usuarios WHERE email = ?';
  
  db.query(query, [email], (err, results) => {
    if (err) {
      console.error('Erro na consulta:', err);
      return res.status(500).json({
        success: false,
        message: 'Erro interno do servidor'
      });
    }

    if (results.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Usuário não encontrado'
      });
    }

    const usuario = results[0];

    // Verificar se a senha antiga está correta
    bcrypt.compare(senhaAntiga, usuario.senha, (err, isMatch) => {
      if (err) {
        console.error('Erro ao verificar senha:', err);
        return res.status(500).json({
          success: false,
          message: 'Erro ao verificar senha'
        });
      }

      if (!isMatch) {
        return res.status(401).json({
          success: false,
          message: 'Senha atual incorreta'
        });
      }

      // Criptografar a nova senha
      bcrypt.hash(senhaNova, 10, (err, hashedPassword) => {
        if (err) {
          console.error('Erro ao criptografar senha:', err);
          return res.status(500).json({
            success: false,
            message: 'Erro ao processar nova senha'
          });
        }

        // Atualizar a senha no banco de dados
        const updateQuery = 'UPDATE usuarios SET senha = ? WHERE email = ?';
        
        db.query(updateQuery, [hashedPassword, email], (err, updateResults) => {
          if (err) {
            console.error('Erro ao atualizar senha:', err);
            return res.status(500).json({
              success: false,
              message: 'Erro ao atualizar senha'
            });
          }

          if (updateResults.affectedRows === 0) {
            return res.status(400).json({
              success: false,
              message: 'Não foi possível atualizar a senha'
            });
          }

          // Gerar token JWT
          const token = jwt.sign(
            { 
              id: usuario.id, 
              email: usuario.email 
            },
            JWT_SECRET,
            { expiresIn: '1h' }
          );

          res.json({
            success: true,
            message: 'Senha atualizada com sucesso',
            token: token,
            user: {
              id: usuario.id,
              email: usuario.email
            }
          });
        });
      });
    });
  });
});

// Middleware para verificar token JWT
const verifyToken = (req, res, next) => {
  const token = req.headers['authorization'];

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Token não fornecido'
    });
  }

  jwt.verify(token.replace('Bearer ', ''), JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({
        success: false,
        message: 'Token inválido'
      });
    }

    req.user = decoded;
    next();
  });
};

// Rota protegida de exemplo
app.get('/api/protected', verifyToken, (req, res) => {
  res.json({
    success: true,
    message: 'Acesso autorizado',
    user: req.user
  });
});

// Iniciar o servidor
app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

// Tratamento de erros não capturados
process.on('uncaughtException', (err) => {
  console.error('Erro não capturado:', err);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Rejeição não tratada:', reason);
  process.exit(1);
});


////////////////////////////////////////////////////////////////&&& ###
YUP PARA VALIDAÇÃO DE FORMULARIOS

Instalação:
npm install yup

importação:
import * as yup from 'yup';               //OU import * as Yup from 'yup';
ou
import * as yup from 'Yup';               //OU import * as Yup from 'Yup';


CUIDADO!!!
Se colocar: import * as Yup from 'yup';
Então terá que usar no codigo sempre yup com Y maiusculo

Se colocar: import * as yup from 'yup';
Então terá que usar no codigo sempre yup com Y minusculo


---------------- ###


-Estrutura HTML do Formulario:
(OBS: className para estilizar no CSS)

import * as Yup from 'yup';
import { Formik, Form, Field, ErrorMessage } from 'formik';
...
<Formik 
  initialValues={{email: ''}} 
  onSubmit={handleClickCadastro}
  validationSchema={validationCadastro}
>
  <Form className="cadastro-form">
    <div className="cadastro-form-group">
      <Field 
        name="email" 
        className="form-field"
        placeholder="Digite seu email"
      />
      <ErrorMessage
        component="div"                      //Ou component="span"
        name="email"
        className="form-error"
      />
    </div>

    <div className="cadastro-form-group">
      <Field 
        name="senha" 
        className="form-field"
        placeholder="Digite sua senha"
        type= "password"
      />
      <ErrorMessage
        component="div"                       //Ou component="span"
        name="senha"
        className="form-error"
      />
    </div>
    <button className="button" type="submit">Cadastro</button>
  </Form>
</Formik>


-Função de validação:

const validationCadastro = yup.object().shape({
  email: yup
    .string()
    .email("Não é um email")
    .required("Este campo é obrigatório"),
  senha: yup
    .string()
    .min(8, "A senha deve ter 8 caracteres")
    .required("Este campo é obrigatório"),
});


----------- ###

Common Yup validation templates:

Yup.string().required("Name is required")
Yup.string().email("Invalid email format")
Yup.string().min(5, "Name must be at least 5 characters").max(20, "Name cannot exceed 20 characters")
Yup.string().oneOf(['red', 'green', 'blue'], 'Invalid color')
Yup.number().min(18, "Must be 18 or older").max(100, "Must be 100 or younger")
Yup.number().integer("Must be an integer").positive("Must be positive")
Yup.date().min('2023-01-01', "Date must be after January 1, 2023")
Yup.date().required("Date is required")
Yup.boolean().required("Checkbox is required")

length()            afirma o comprimento da string / número
url()               afirma que é uma URL válida
min() / max()       afirma que o número é pelo menos 'x' e menor que 'y'
ensure()            transforma undefined e nullvalores em uma string vazia, além de definir o defaultcomo uma string vazia.

confirmPassword: 
yup.string().oneOf([yup.ref('password'), null], 'Passwords must match')

.test(): Allows you to create custom validation logic using a test function. This is useful for complex scenarios that can't be covered by built-in methods. 
    Yup.string().test(
        "is-strong-password",
        "Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, and one number",
        (value) => {
          // Add your password validation logic here
          return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]{8,}$/.test(value);
        }
      )

Nested Schemas: Enables validation of complex objects and arrays of data. 
     Yup.object().shape({
        name: Yup.string().required(),
        address: Yup.object().shape({
            street: Yup.string().required(),
            city: Yup.string().required(),
        })
    })

Async Validation: Supports asynchronous validation, useful for server-side checks or other operations that require waiting for a response.
      Yup.string().test('unique-email', 'Email already exists', async (value) => {
        // Simulate an API call to check for email uniqueness
        const isUnique = await checkEmailUniqueness(value);
        return isUnique;
      })

---------

REGEX:

  const validationSchema = yup.object().shape({
    username: yup
      .string()
      .required('É obrigatório preencher')
      .matches(/^\S*$/, 'Não pode conter espaços')
      .matches(/^[0-9A-Za-z]$/, "Deve conter apenas letras e números")
      .matches(/^{6,16}$/, "Deve conter entre 6 e 16 caracteres")            //ou usar .min() e .max()
  });

/.../ wrap/denote a regex statement
^ indicates the start of a string, while $ indicates the end.
[...] indicates a particular set of valid characters, otherwise called a character class; 0-9 allows numbers, A-Z allows uppercase letters, a-z allows lowercase. 
{6,16} indicates the allowed number of characters. If you just used {6}, you're testing for a length of exactly 6, while {6,} tests for minimum length.
. signifies any character is possible, while * means 'zero or more' of them.

---

Valid Password: between 8 and 32 characters, at least one letter and one number
Strong Password: valid, plus a combination of uppercase and lowercase letters and special characters

/^(?=.*?[0-9])(?=.*?[A-Za-z]).{8,32}$/

(...) is a capture group. You can use them for capturing particular characters in specific orders.
?= is a positive lookahead. The search moves rightward through the string from the location in your regex you make this assertion in.
. signifies any character is possible, while * means 'zero or more' of them.
The extra question mark in ?=.*? makes the search lazy, which essentially means 'stop looking after the first time this requirement is met'.

the first part of our statement ^(?=.*?[0-9]) means 'from the start of the string, find a number that is preceded by zero or more of any character'.

Adding (?=.*?[A-Za-z]) means do the same for any letter, or 'from the start of the string, find a letter that is preceded by zero or more of any character'. This allows us to confirm the presence of a specified kind of character within the total set of what is allowed without regard to where it occurs in the string.

The last part of our statement .{8,32}$ builds on our understanding of . usage. We don't want to limit what kinds of characters the actual password is allowed to be. In contrast, if limiting to letters and numbers only, you'd use [0-9A-Za-z]{8,32}$.

In addition to the valid password requirements, a strong password requires at least one uppercase letter, at least one lowercase letter, and at least one special character. We can just build on the same regex statement:

// valid, but not strong
/^(?=.*?[0-9])(?=.*?[A-Za-z]).{8,32}$/
// strong
/^(?=.*?[0-9])(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[^0-9A-Za-z]).{8,32}$/

find one number, (?=.*?[0-9])
one uppercase letter, (?=.*?[A-Z])
one lowercase letter, (?=.*?[a-z])
and one character that is NOT alphanumeric (?=.*?[^0-9A-Za-z])
in a string with any characters between 8 and 32 characters long .{8,32}
When used at the start of a character class ^ means 'NOT', or everything excluding. A basic understanding of sets helps here. A simple example is [^B], which means 'any character except B'.

The JavaScript RegExp class has a very handy method called test() that can be used to test strings against a specified regex statement. For instance,

const validUsername = /^[0-9A-Za-z]{6,16}$/;

console.log(validUsername.test('username')) // valid
// prints true
console.log(validUsername.test('test1')) // too short
// prints false
console.log(validUsername.test('@testing1')) // invalid character
// prints false
You can do the same thing with password, as demonstrated in a replit I created embedded below. Select 'show code' to see the functions you have to work with, then hit run when you want to open the environment and play around with running your own tests.

// anything NOT alphanumeric, correct length
const isValidUsername = /^[0-9A-Za-z]{6,16}$/;

// at least one number, at least one letter, correct length
const isValidPassword = /^(?=.*?[0-9])(?=.*?[A-Za-z]).{8,32}$/;

// at least one each of a number, uppercase letter, lowercase letter, and non-alphanumeric, correct length
const isStrongPassword = /^(?=.*?[0-9])(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[^0-9A-Za-z]).{8,32}$/;

function testUsername(testcase) {
  console.log(`${testcase} ${isValidUsername.test(testcase) ? 'is' : 'is not'} a valid username.`);
}

function testPassword(testcase) {
  const validPassword = (testcase) => isValidPassword.test(testcase);
  const passwordStrength = (testcase) => isStrongPassword.test(testcase);
  
    if (passwordStrength(testcase)) {
      console.log(`${testcase} is a strong and valid password.`);
    } else if (validPassword(testcase)) {
      console.log(`${testcase} is a valid password, but not strong.`);
    } else {
      console.log(`${testcase} is not a valid password.`);
    }
}

// some test cases for you to work with
const usernameTests = ['test', 'isvalid', 'Trythis1', 'notvalidbctoolong'];
const passwordTests = ['notvalid', 'validnotstrong1', 'Strong!2023', 'this is Strong 2'];

// ** create your own tests using the below examples
testUsername('notvalid!');
testPassword(passwordTests[1]);

--------- ###

CPF apenas:

// Função de validação personalizada para CPF
const validarCPF = (cpf) => {
  cpf = cpf.replace(/[^\d]+/g, '');
  if (cpf.length !== 11 || /^(\d)\1{10}$/.test(cpf)) return false;
  
  let soma = 0;
  for (let i = 0; i < 9; i++) {
    soma += parseInt(cpf.charAt(i)) * (10 - i);
  }
  let resto = (soma * 10) % 11;
  if (resto === 10 || resto === 11) resto = 0;
  if (resto !== parseInt(cpf.charAt(9))) return false;
  
  soma = 0;
  for (let i = 0; i < 10; i++) {
    soma += parseInt(cpf.charAt(i)) * (11 - i);
  }
  resto = (soma * 10) % 11;
  if (resto === 10 || resto === 11) resto = 0;
  if (resto !== parseInt(cpf.charAt(10))) return false;
  
  return true;
};

// Schema de validação principal
export const validationCadastro = Yup.object({
  cpf: Yup.string()
    .required('CPF é obrigatório')
    .matches(/^\d{3}\.\d{3}\.\d{3}-\d{2}$/, 'CPF deve estar no formato 999.999.999-99')
    .test('cpf-valido', 'CPF inválido', function(value) {
      return validarCPF(value);
    }),
});

---

Alternativo:

// Função para permitir apenas números nos campos
const handleNumericInput = (e) => {
  const value = e.target.value.replace(/\D/g, '');
  return value;
};

...
  cpf: Yup.string()
    .matches(/^\d{11}$/, 'CPF deve conter exatamente 11 dígitos')
    .required('CPF é obrigatório'),
...

...
                onChange={(e) => {
                  const value = handleNumericInput(e);
                  setFieldValue('cpf', value);
                }}
...

------------ ###

CNPJ:
type="text"


// Função para validar CNPJ
const validarCNPJ = (cnpj) => {
  cnpj = cnpj.replace(/[^\d]/g, '');
  if (cnpj.length !== 14) return false;
  
  if (/^(\d)\1{13}$/.test(cnpj)) return false;
  
  let tamanho = cnpj.length - 2;
  let numeros = cnpj.substring(0, tamanho);
  let digitos = cnpj.substring(tamanho);
  let soma = 0;
  let pos = tamanho - 7;
  
  for (let i = tamanho; i >= 1; i--) {
    soma += numeros.charAt(tamanho - i) * pos--;
    if (pos < 2) pos = 9;
  }
  
  let resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
  if (resultado != digitos.charAt(0)) return false;
  
  tamanho = tamanho + 1;
  numeros = cnpj.substring(0, tamanho);
  soma = 0;
  pos = tamanho - 7;
  
  for (let i = tamanho; i >= 1; i--) {
    soma += numeros.charAt(tamanho - i) * pos--;
    if (pos < 2) pos = 9;
  }
  
  resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
  return resultado == digitos.charAt(1);
};


// Schema de validação principal
export const validationCadastro = Yup.object({
  cnpj: Yup.string()
    .test('cnpj-valido', 'CNPJ inválido', function(value) {
      if (!value) return true; // Campo opcional
      return validarCNPJ(value);
    })
    .transform((value) => value?.replace(/[^\d]/g, '') || ''),
});

------------- ###

CPF ou CNPJ:
type="text"

// Função para validar CPF
const validarCPF = (cpf) => {
  cpf = cpf.replace(/[^\d]/g, '');
  if (cpf.length !== 11 || /^(\d)\1{10}$/.test(cpf)) return false;
  
  let soma = 0;
  for (let i = 0; i < 9; i++) {
    soma += parseInt(cpf.charAt(i)) * (10 - i);
  }
  let resto = 11 - (soma % 11);
  if (resto === 10 || resto === 11) resto = 0;
  if (resto !== parseInt(cpf.charAt(9))) return false;
  
  soma = 0;
  for (let i = 0; i < 10; i++) {
    soma += parseInt(cpf.charAt(i)) * (11 - i);
  }
  resto = 11 - (soma % 11);
  if (resto === 10 || resto === 11) resto = 0;
  return resto === parseInt(cpf.charAt(10));
};

// Função para validar CNPJ
const validarCNPJ = (cnpj) => {
  cnpj = cnpj.replace(/[^\d]/g, '');
  if (cnpj.length !== 14) return false;
  
  if (/^(\d)\1{13}$/.test(cnpj)) return false;
  
  let tamanho = cnpj.length - 2;
  let numeros = cnpj.substring(0, tamanho);
  let digitos = cnpj.substring(tamanho);
  let soma = 0;
  let pos = tamanho - 7;
  
  for (let i = tamanho; i >= 1; i--) {
    soma += numeros.charAt(tamanho - i) * pos--;
    if (pos < 2) pos = 9;
  }
  
  let resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
  if (resultado != digitos.charAt(0)) return false;
  
  tamanho = tamanho + 1;
  numeros = cnpj.substring(0, tamanho);
  soma = 0;
  pos = tamanho - 7;
  
  for (let i = tamanho; i >= 1; i--) {
    soma += numeros.charAt(tamanho - i) * pos--;
    if (pos < 2) pos = 9;
  }
  
  resultado = soma % 11 < 2 ? 0 : 11 - (soma % 11);
  return resultado == digitos.charAt(1);
};


// Schema de validação principal
export const validationCadastro = Yup.object({
  cpfOuCnpj: Yup.string()
    .required('CPF ou CNPJ é obrigatório')
    .test('cpf-ou-cnpj-valido', 'CPF ou CNPJ inválido', function(value) {
      if (!value) return false;
      const numeros = value.replace(/[^\d]/g, '');
      
      if (numeros.length === 11) {
        return validarCPF(value);
      } else if (numeros.length === 14) {
        return validarCNPJ(value);
      }
      
      return false;
    }),
});

-----

Alternativo:

// Função para permitir apenas números nos campos
const handleNumericInput = (e) => {
  const value = e.target.value.replace(/\D/g, '');
  return value;
};

  cpfCnpj: Yup.string()
    .matches(/^\d{11}$|^\d{14}$/, 'Deve conter 11 dígitos (CPF) ou 14 dígitos (CNPJ)')
    .required('CPF ou CNPJ é obrigatório'),

------------ ###

Alfanumérico com 1 ou mais caracteres (letras e numeros apenas):
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  alfanumerico: Yup.string()
    .required('Campo alfanumérico é obrigatório')
    .min(1, 'Deve ter pelo menos 1 caractere')
    .matches(/^[a-zA-Z0-9]+$/, 'Deve conter apenas letras e números'),
});

------------ ###

Alfanumérico com 1 ou mais caracteres (letras, numeros e caracteres especiais):
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  alfanumerico: Yup.string()
    .min(1, 'Campo deve ter pelo menos 1 caractere')
    .required('Campo obrigatório'),
});

------------ ###

Username com 1 a 20 caracteres e obrigatório

// Schema de validação principal
export const validationCadastro = Yup.object({
 username: Yup.string()
    .required('Username é obrigatório')
    .min(1, 'Username deve ter pelo menos 1 caractere')
    .max(20, 'Username deve ter no máximo 20 caracteres'),
});

------------ ###

Nome
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  nome: Yup.string()
    .min(2, 'Nome deve ter pelo menos 2 caracteres')
    .matches(/^[a-zA-ZÀ-ÿ\s]+$/, 'Nome deve conter apenas letras')
    .required('Nome é obrigatório'),
});

------------ ###

Sobrenome
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  sobrenome: Yup.string()
    .min(2, 'Sobrenome deve ter pelo menos 2 caracteres')
    .matches(/^[a-zA-ZÀ-ÿ\s]+$/, 'Sobrenome deve conter apenas letras')
    .required('Sobrenome é obrigatório'),
});

------------ ###

Nome completo
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  nomeCompleto: Yup.string()
    .min(5, 'Nome completo deve ter pelo menos 5 caracteres')
    .matches(/^[a-zA-ZÀ-ÿ\s]+$/, 'Nome completo deve conter apenas letras')
    .required('Nome completo é obrigatório'),
});

------------ ###

Senha obrigatória com no mínimo 8 caracteres (precisa ter maiúsculas, minúsculas e número/caractere especial)

// Schema de validação principal
export const validationCadastro = Yup.object({
  senha: Yup.string()
    .required('Senha é obrigatória')
    .min(8, 'Senha deve ter no mínimo 8 caracteres')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*[\d\W]).*$/, 
      'Senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número ou caractere especial'),
});

-----

Alternativo:

  senha: Yup.string()
    .min(8, 'Senha deve ter no mínimo 8 caracteres')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*[\d\W]).*$/, 'Senha deve conter pelo menos uma maiúscula, uma minúscula e um número/caractere especial')
    .required('Senha é obrigatória'),

------------ ###

Email obrigatório

// Schema de validação principal
export const validationCadastro = Yup.object({
  email: Yup.string()
    .required('Email é obrigatório')
    .email('Digite um email válido'),
});

------------- ###

CEP (99999-999)

// Schema de validação principal
export const validationCadastro = Yup.object({
  cep: Yup.string()
    .required('CEP é obrigatório')
    .matches(/^\d{5}-\d{3}$/, 'CEP deve estar no formato 99999-999'),
});

------ 

Alternativo:

// Função para formatar CEP
const formatCEP = (value) => {
  const numbers = value.replace(/\D/g, '');
  if (numbers.length <= 5) return numbers;
  return `${numbers.slice(0, 5)}-${numbers.slice(5, 8)}`;
};

  cep: Yup.string()
    .matches(/^\d{8}$/, 'CEP deve conter exatamente 8 dígitos')
    .required('CEP é obrigatório'),

------------- ###

Data (DD-MM-AAAA)

// Schema de validação principal
export const validationCadastro = Yup.object({
  data: Yup.string()
    .required('Data é obrigatória')
    .matches(/^\d{2}-\d{2}-\d{4}$/, 'Data deve estar no formato DD-MM-AAAA')
    .test('data-valida', 'Data inválida', function(value) {
      if (!value) return false;
      const [dia, mes, ano] = value.split('-').map(Number);
      const data = new Date(ano, mes - 1, dia);
      return data.getFullYear() === ano && 
             data.getMonth() === mes - 1 && 
             data.getDate() === dia;
    }),
});

------

Alternativo:

// Função para formatar data (DD/MM/AAAA)
const formatDateComplete = (value) => {
  const numbers = value.replace(/\D/g, '');
  if (numbers.length <= 2) return numbers;
  if (numbers.length <= 4) return `${numbers.slice(0, 2)}/${numbers.slice(2)}`;
  return `${numbers.slice(0, 2)}/${numbers.slice(2, 4)}/${numbers.slice(4, 8)}`;
};

  dataCompleta: Yup.string()
    .matches(/^\d{2}\/\d{2}\/\d{4}$/, 'Data deve estar no formato DD/MM/AAAA')
    .required('Data é obrigatória'),

------------- ###

Data (DD-MM-AA)

// Schema de validação principal
export const validationCadastro = Yup.object({
  data: Yup.string()
    .matches(/^\d{2}-\d{2}-\d{2}$/, 'Data deve estar no formato DD-MM-AA')
    .test('data-valida', 'Data inválida', function(value) {
      if (!value) return true;
      const [dia, mes, ano] = value.split('-').map(Number);
      const anoCompleto = ano < 50 ? 2000 + ano : 1900 + ano;
      const data = new Date(anoCompleto, mes - 1, dia);
      return data.getFullYear() === anoCompleto && 
             data.getMonth() === mes - 1 && 
             data.getDate() === dia;
    })
    .required('Data é obrigatória'),
});

------

Alternativo:

// Função para formatar data (DD/MM/AA)
const formatDateShort = (value) => {
  const numbers = value.replace(/\D/g, '');
  if (numbers.length <= 2) return numbers;
  if (numbers.length <= 4) return `${numbers.slice(0, 2)}/${numbers.slice(2)}`;
  return `${numbers.slice(0, 2)}/${numbers.slice(2, 4)}/${numbers.slice(4, 6)}`;
};

  dataReduzida: Yup.string()
    .matches(/^\d{2}\/\d{2}\/\d{2}$/, 'Data deve estar no formato DD/MM/AA')
    .required('Data é obrigatória'),


------------- ###

Hora (hh:mm:ss)

// Schema de validação principal
export const validationCadastro = Yup.object({
  hora: Yup.string()
    .required('Hora é obrigatória')
    .matches(/^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/, 'Hora deve estar no formato hh:mm:ss'),
});

------------- ###

Hora (hh:mm)

// Schema de validação principal
export const validationCadastro = Yup.object({
  hora: Yup.string()
    .matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Hora deve estar no formato HH:MM')
    .required('Hora é obrigatória'),
});

------------- ###

Telefone fixo com código de país e DDD  (+99(99)9999-9999)

// Schema de validação principal
export const validationCadastro = Yup.object({
  telefoneFixoCompleto: Yup.string()
    .required('Telefone fixo com código de país é obrigatório')
    .matches(/^\+\d{2}\(\d{2}\)\d{4}-\d{4}$/, 'Telefone deve estar no formato +99(99)9999-9999'),
});

------------- ###

Telefone fixo com apenas DDD  (99)9999-9999

// Schema de validação principal
export const validationCadastro = Yup.object({
  telefoneFixo: Yup.string()
    .required('Telefone fixo é obrigatório')
    .matches(/^\(\d{2}\)\d{4}-\d{4}$/, 'Telefone deve estar no formato (99)9999-9999'),
});

------

Alternativo:

  telefoneFixo: Yup.string()
    .matches(/^\d{10}$/, 'Telefone fixo deve conter exatamente 10 dígitos (DDD + número)')
    .required('Telefone fixo é obrigatório'),

-------------- ###

Celular com código de país e DDD  (+99(99)99999-9999)

// Schema de validação principal
export const validationCadastro = Yup.object({
  celularCompleto: Yup.string()
    .required('Celular com código de país é obrigatório')
    .matches(/^\+\d{2}\(\d{2}\)\d{5}-\d{4}$/, 'Celular deve estar no formato +99(99)99999-9999'),
});

-------------- ###

Celular com apenas DDD  ((99)99999-9999)

// Schema de validação principal
export const validationCadastro = Yup.object({
  celular: Yup.string()
    .required('Celular é obrigatório')
    .matches(/^\(\d{2}\)\d{5}-\d{4}$/, 'Celular deve estar no formato (99)99999-9999'),
});

------

Alternativo:

// Função para permitir apenas números nos campos
const handleNumericInput = (e) => {
  const value = e.target.value.replace(/\D/g, '');
  return value;
};

  celular: Yup.string()
    .matches(/^\d{11}$/, 'Celular deve conter exatamente 11 dígitos (DDD + número)')
    .required('Celular é obrigatório')

--------------- ###

Número com ou sem decimal (Ex: 9 ou 9.9 ou 9,9)

// Schema de validação principal
export const validationCadastro = Yup.object({
  numero: Yup.string()
    .required('Número é obrigatório')
    .matches(/^\d+([,.]\d+)?$/, 'Deve ser um número válido (ex: 9 ou 9.9 ou 9,9)')
    .test('numero-valido', 'Número inválido', function(value) {
      const numeroFormatado = value.replace(',', '.');
      return !isNaN(parseFloat(numeroFormatado));
    }),
});

---------------- ###

Preço (1.00)
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  precoComPonto: Yup.string()
    .required('Preço é obrigatório')
    .matches(/^\d+\.\d{2}$/, 'Preço deve estar no formato 1.00'),
});

---------------- ###

Preço (1,00)
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  precoComVirgula: Yup.string()
    .required('Preço é obrigatório')
    .matches(/^\d+,\d{2}$/, 'Preço deve estar no formato 1,00'),
});

----------------- ###

Preço (1,00) ou (1.00)
type="text"

// Schema de validação principal
export const validationCadastro = Yup.object({
  preco: Yup.string()
    .matches(/^\d+([.,]\d{2})?$/, 'Preço deve estar no formato 0,00 ou 0.00')
    .test('preco-valido', 'Preço deve ser maior que zero', function(value) {
      if (!value) return true;
      const numero = parseFloat(value.replace(',', '.'));
      return numero > 0;
    })
    .required('Preço é obrigatório'),
});

-------

Alternativo:

// Função para formatar preço
const formatPrice = (value) => {
  const numbers = value.replace(/[^\d.]/g, '');
  return numbers;
};

  preco: Yup.string()
    .matches(/^\d+(\.\d{1,2})?$/, 'Preço deve conter apenas números e até 2 casas decimais')
    .required('Preço é obrigatório'),


----------------- ###


CARTÃO DE CREDITO:

// Função de validação personalizada para cartão de crédito
const validarCartaoCredito = (numero) => {
  numero = numero.replace(/\D/g, '');
  if (numero.length < 13 || numero.length > 19) return false;
  
  // Algoritmo de Luhn
  let soma = 0;
  let alternar = false;
  
  for (let i = numero.length - 1; i >= 0; i--) {
    let digito = parseInt(numero.charAt(i));
    
    if (alternar) {
      digito *= 2;
      if (digito > 9) {
        digito -= 9;
      }
    }
    
    soma += digito;
    alternar = !alternar;
  }
  
  return soma % 10 === 0;
};


// Schema de validação principal
export const validationCadastro = Yup.object({
  cartaoCredito: Yup.string()
    .required('Número do cartão de crédito é obrigatório')
    .matches(/^[\d\s-]+$/, 'Número do cartão deve conter apenas números, espaços ou hífens')
    .test('cartao-valido', 'Número do cartão inválido', function(value) {
      return validarCartaoCredito(value);
    }),
});

------------ ###

Número de cartão de crédito AMEX

// Função de validação personalizada para cartão AMEX
const validarCartaoAmex = (numero) => {
  numero = numero.replace(/\D/g, '');
  // AMEX começa com 34 ou 37 e tem 15 dígitos
  if (numero.length !== 15 || (numero.substring(0, 2) !== '34' && numero.substring(0, 2) !== '37')) {
    return false;
  }
  return validarCartaoCredito(numero);
};


// Schema de validação principal
export const validationCadastro = Yup.object({
  cartaoAmex: Yup.string()
    .required('Número do cartão AMEX é obrigatório')
    .matches(/^[\d\s-]+$/, 'Número do cartão deve conter apenas números, espaços ou hífens')
    .test('amex-valido', 'Número do cartão AMEX inválido', function(value) {
      return validarCartaoAmex(value);
    }),
});

------------ ###

Número de cartão de crédito VISA

const validarVisa = (numero) => {
  numero = numero.replace(/\s/g, '');
  return /^4[0-9]{12}(?:[0-9]{3})?$/.test(numero) && validarLuhn(numero);
};

// Algoritmo de Luhn para validação de cartão de crédito
const validarLuhn = (numero) => {
  let soma = 0;
  let alternar = false;
  
  for (let i = numero.length - 1; i >= 0; i--) {
    let digito = parseInt(numero.charAt(i));
    
    if (alternar) {
      digito *= 2;
      if (digito > 9) digito -= 9;
    }
    
    soma += digito;
    alternar = !alternar;
  }
  
  return soma % 10 === 0;
};

// Schema de validação principal
export const validationCadastro = Yup.object({
  cartaoVisa: Yup.string()
    .test('visa-valido', 'Número do cartão VISA inválido', function(value) {
      if (!value) return true; // Campo opcional
      return validarVisa(value);
    }),
});


------------- ###

Número de cartão de crédito MASTER

const validarMaster = (numero) => {
  numero = numero.replace(/\s/g, '');
  return /^5[1-5][0-9]{14}$/.test(numero) && validarLuhn(numero);
};

// Algoritmo de Luhn para validação de cartão de crédito
const validarLuhn = (numero) => {
  let soma = 0;
  let alternar = false;
  
  for (let i = numero.length - 1; i >= 0; i--) {
    let digito = parseInt(numero.charAt(i));
    
    if (alternar) {
      digito *= 2;
      if (digito > 9) digito -= 9;
    }
    
    soma += digito;
    alternar = !alternar;
  }
  
  return soma % 10 === 0;
};

// Schema de validação principal
export const validationCadastro = Yup.object({
  cartaoMaster: Yup.string()
    .test('master-valido', 'Número do cartão MasterCard inválido', function(value) {
      if (!value) return true; // Campo opcional
      return validarMaster(value);
    }),
});

-------------------------- ###

Exemplo de codigo 1:


export default function FormularioCadastro() {

  const handleSubmit = async (values, { setSubmitting, setStatus, resetForm }) => {
    try {
      console.log('Dados do formulário:', values);                  //opcional

      const response = await axios.post('/cadastro', values);

      console.log('Resposta da API:', response.data);              //opcional
      alert('Cadastro realizado com sucesso!');                    //opcional
      setStatus({ type: 'success', message: 'Cadastro realizado com sucesso!' 
      
      resetForm();
});
    } catch (error) {
      console.error('Erro no envio:', error);                      //opcional
      alert('Erro ao realizar cadastro. Tente novamente.');        //opcional
      setStatus({ type: 'error', message: 'Erro ao realizar cadastro' });
    } finally {
      setSubmitting(false);
    }
  };

  const initialValues = {
    username: '',
    senha: '',
  };

  return (
    <Formik
      initialValues={initialValues}
      validationSchema={validationCadastro}
      onSubmit={handleSubmit}
    >
      {({ isSubmitting, status }) => (
        <Form>
          {status && (
            <div className={`alert ${status.type === 'success' ? 'alert-success' : 'alert-error'}`}>
              {status.message}
            </div>
          )}
          
          <div>
            <Field name="username" placeholder="Username" />
            <ErrorMessage name="username" component="div" className="error" />
          </div>
          
          <div>
            <Field name="senha" type="password" placeholder="Senha" />
            <ErrorMessage name="senha" component="div" className="error" />
          </div>
       
          
          <button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Enviando...' : 'Cadastrar'}
          </button>
        </Form>
      )}
    </Formik>
  );
};

-------------- &&& ###
FORMULARIO COM YUP COM VALIDAÇÕES MELHORES

Exemplo de codigo com CPF/CNPJ:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function CadastroComponent() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');
      
      const response = await axios.post('http://localhost:3000/cadastro', {
        campo: values.campo,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    campo: Yup.string()
      .required('CPF ou CNPJ é obrigatório')
      .test('cpf-cnpj-format', 'Deve conter 11 dígitos (CPF) ou 14 dígitos (CNPJ)', (value) => {
        if (!value) return false;
        const numbersOnly = value.replace(/\D/g, '');
        return numbersOnly.length === 11 || numbersOnly.length === 14;
      })
      .test('cpf-cnpj-valid', 'CPF ou CNPJ inválido', (value) => {
        if (!value) return false;
        const numbersOnly = value.replace(/\D/g, '');
        
        // Validação básica para evitar números repetidos
        if (numbersOnly.length === 11) {
          return !(/^(\d)\1{10}$/.test(numbersOnly)); // CPF não pode ter todos os dígitos iguais
        } else if (numbersOnly.length === 14) {
          return !(/^(\d)\1{13}$/.test(numbersOnly)); // CNPJ não pode ter todos os dígitos iguais
        }
        return false;
      }),
  });

  const formatCpfCnpj = (value) => {
    const numbersOnly = value.replace(/\D/g, '');
    
    if (numbersOnly.length <= 11) {
      // Formato CPF: 000.000.000-00
      return numbersOnly
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d{1,2})/, '$1-$2');
    } else {
      // Formato CNPJ: 00.000.000/0000-00
      return numbersOnly
        .replace(/(\d{2})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1.$2')
        .replace(/(\d{3})(\d)/, '$1/$2')
        .replace(/(\d{4})(\d{1,2})/, '$1-$2');
    }
  };

  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik 
          initialValues={{ campo: '' }} 
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values, setFieldValue }) => (
            <Form>
              <div>
                <Field 
                  name="campo" 
                  placeholder="Digite o CPF ou CNPJ"
                  value={values.campo}
                  onChange={(e) => {
                    const formatted = formatCpfCnpj(e.target.value);
                    setFieldValue('campo', formatted);
                  }}
                  maxLength={18} // Máximo para CNPJ formatado
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="campo"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}
      
      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
    </div>
  );
}

------------------------ ### @@@

Exemplo de codigo com celular:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Teste() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');

      const response = await axios.post('http://localhost:3000/cadastro', {
        campo: values.campo,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    campo: Yup.string()
      .required('Celular é obrigatório')
      .matches(/^\(\d{2}\)\d{5}-\d{4}$/, 'Celular deve estar no formato (99)99999-9999'),
  });

  const formatPhoneNumber = (value) => {
    const numbers = value.replace(/\D/g, '');

    if (numbers.length <= 2) {
      return numbers.length > 0 ? `(${numbers}` : '';
    } else if (numbers.length <= 7) {
      return `(${numbers.slice(0, 2)})${numbers.slice(2)}`;
    } else {
      return `(${numbers.slice(0, 2)})${numbers.slice(2, 7)}-${numbers.slice(7, 11)}`;
    }
  };

  const handleChange = (e, setFieldValue) => {
    const formattedValue = formatPhoneNumber(e.target.value);
    setFieldValue('campo', formattedValue);
  };

  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik
          initialValues={{ campo: '' }}
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values, setFieldValue }) => (
            <Form>
              <div>
                <Field
                  name="campo"
                  placeholder="Digite o Celular"
                  value={values.campo}
                  onChange={(e) => handleChange(e, setFieldValue)}
                  maxLength={14} // Máximo para celular formatado (99)99999-9999
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="campo"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}

      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
    </div>
  );
}

-------------------- ###

Exemplo de codigo com CEP:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Teste() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');

      const response = await axios.post('http://localhost:3000/cadastro', {
        cep: values.cep,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    cep: Yup.string()
      .required('CEP é obrigatório')
      .matches(/^\d{5}-\d{3}$/, 'CEP deve estar no formato 99999-999'),
  });

  const formatCEP = (value) => {
    const numbers = value.replace(/\D/g, '');

    if (numbers.length <= 5) {
      return numbers;
    } else {
      return `${numbers.slice(0, 5)}-${numbers.slice(5, 8)}`;
    }
  };

  const handleChange = (e, setFieldValue) => {
    const formattedValue = formatCEP(e.target.value);
    setFieldValue('cep', formattedValue);
  };

  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik
          initialValues={{ cep: '' }}
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values, setFieldValue }) => (
            <Form>
              <div>
                <Field
                  name="cep"
                  placeholder="Digite o CEP"
                  value={values.cep}
                  onChange={(e) => handleChange(e, setFieldValue)}
                  maxLength={9} // Máximo para CEP formatado 99999-999
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="cep"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}

      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
    </div>
  );
}

------------------ ###

Exemplo de codigo para Nome, Sobrenome ou Nome completo:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Teste() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');

      const response = await axios.post('http://localhost:3000/cadastro', {
        nomeCompleto: values.nomeCompleto,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    nomeCompleto: Yup.string()
      .required('O nome completo é obrigatório')
      .min(3, 'O nome completo deve ter pelo menos 3 caracteres')
      .max(100, 'O nome completo deve ter no máximo 100 caracteres')
      .matches(/^[A-Za-zÀ-ÖØ-öø-ÿ\s]+$/, 'O nome completo deve conter apenas letras e espaços')
  });


  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik
          initialValues={{ nomeCompleto: '' }}
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values }) => (
            <Form>
              <div>
                <Field
                  name="nomeCompleto"
                  placeholder="Digite o Nome Completo"
                  value={values.nomeCompleto}
                  type="text"
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="nomeCompleto"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}

      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
      
    </div>
  );
}

----------------------- ###

Username (letras, numeros e caracteres especiais e não aceita espaço)

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Teste() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');

      const response = await axios.post('http://localhost:3000/cadastro', {
        username: values.username,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    username: Yup.string()
      .required('Username é obrigatório')
      .min(3, 'Username deve ter pelo menos 3 caracteres')
      .max(20, 'Username deve ter no máximo 20 caracteres')
      .matches(/^[^ ]+$/, 'Username não pode conter espaços')
  });


  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik
          initialValues={{ username: '' }}
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values }) => (
            <Form>
              <div>
                <Field
                  name="username"
                  placeholder="Digite o Username"
                  value={values.username}
                  type="text"
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="username"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}

      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
      
    </div>
  );
}


----------------------- ###

Email:

import React, { useState } from 'react';
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';
import axios from 'axios';

export default function Teste() {

  const [cadastroError, setCadastroError] = useState('');
  const [successMessage, setSuccessMessage] = useState('');

  const handleSubmit = async (values, { resetForm }) => {
    try {
      setCadastroError('');
      setSuccessMessage('');

      const response = await axios.post('http://localhost:3000/cadastro', {
        email: values.email,
      });

      if (response.status === 201) {
        setSuccessMessage('Usuário cadastrado com sucesso!');
        resetForm();
        // Aqui você pode adicionar navegação se necessário
        // navigate('/login');
      }

    } catch (error) {
      if (error.response?.data?.error) {
        setCadastroError(error.response.data.error);
      } else if (error.response?.status === 400) {
        setCadastroError('Dados inválidos. Verifique as informações e tente novamente.');
      } else if (error.response?.status === 409) {
        setCadastroError('Já cadastrado no sistema.');
      } else if (error.code === 'ECONNREFUSED') {
        setCadastroError('Servidor indisponível. Tente novamente mais tarde.');
      } else {
        setCadastroError('Erro inesperado. Tente novamente.');
      }
      console.error('Erro no cadastro:', error);
    }
  };

  const validationSchema = Yup.object().shape({
    email: Yup.string()
      .email('Email inválido')
      .required('Email é obrigatório')
      .matches(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/, 'Email inválido')
  });

  return (
    <div>
      <div>
        <h1>Cadastro</h1>

        <Formik
          initialValues={{ email: '' }}
          onSubmit={handleSubmit}
          validationSchema={validationSchema}
        >
          {({ values }) => (
            <Form>
              <div>
                <Field
                  name="email"
                  placeholder="Digite o Email"
                  value={values.email}
                  type="email"
                  disabled={false}
                />
                <ErrorMessage
                  component="span"
                  name="email"
                />
              </div>

              <button type="submit">Cadastrar</button>
            </Form>
          )}
        </Formik>
      </div>

      {/* Mensagens de feedback */}
      {successMessage && (
        <div>
          {successMessage}
        </div>
      )}

      {cadastroError && (
        <div>
          {cadastroError}
        </div>
      )}
      
    </div>
  );
}













////////////////////////////////////////////////////////////////&&&
CRUD COM REACT, NODE, NEXT E MYSQL
VIDEO: https://www.youtube.com/embed/7LTIfvCERWE?autoplay=1

-Instale o Node JS

-Crie uma pasta para o arquivo do projeto (Ex: Projeto01)

-No terminal, dentro da pasta do projeto digite:  npx create-next-app
-Digite o nome da pasta que ficará dentro do projeto (Ex: App01)
-Escolha que não quer usar o typescript
-Escolha que quer usar ESLint
-Escolha que não quer usar o Tailwind CSS
-Escolha que quer usar o diretorio src/
-Escolha que não quer usar o App Router
-Escolha que não quer customizar o alias

-No terminal, vá para a pasta App01 e digite:
npm run dev
A url usada será a http://localhost:3000

-No arquivo index.js, pode deletar o conteudo dentro da tag <main> e os imports desnecessarios, além dos arquivos css 

-Instale o axios no terminal:
npm install axios

-No arquivo index.js:

import React, {useState} from 'react'
import Axios from 'axios'

export default function App() {

  const [data, setData] = useState({
    name: '',
    email: '',
  })

  const [message, setMessage] = useState("")

  const valueInput = (e) => {                     //handleChange
    setData({...data, [e.target.name]: e.target.value})
  }

  const addUser = async (e) => {                  //handleSubmit
    e.preventDefault();        //para não recarregar a pagina ao clicar

    console.log("Nome: " + data.name)        //opcional
    console.log("E-mail: " + data.email)     //opcional

    const headers = {
      'headers': {
        'Content-Type': 'application/json'
      }
    }

    await axios.post('http://localhost:8080/users', data, headers)
      .then((response) => {

        setMessage(response.data.mensagem)       

        setData({
          name: '',
          email: ''
        })
      }) .catch ((err) => {
        if (err.response){
          setMessage(err.response.data.mensagem)   
        } 
        else{
          setMessage("Erro: Tente novamente mais tarde")
        }
      })
  }

  return (
    <>
      <h2>Cadastrar usuário</h2>

      {message ? <p>{message}</p> : ""}

      <form onSubmit={addUser}>

        <label>Nome: </label>
        <input 
          type="text" 
          name="name" 
          placeholder="Seu nome" 
          onChange={valueInput}
          value={data.name}
        />

        </br>

        <label>E-mail: </label>
        <input 
          type="email" 
          name="email" 
          placeholder="Seu email" 
          onChange={valueInput}
          value={data.email}
        />

        </br>

        <button type="submit">ENVIAR</button>

      </form>
    </>
  )
}

-Execute o projeto com:
npm run dev

-Em uma pasta chamada onde estarão os arquivos de banco de dados: (Ex: servidor)

-No arquivo app.js dentro da pasta servidor:
(CÓDIGO INCOMPLETO)

const express = require("express")
const cors = require("cors")

const app = express()

app.use(express.json())

const users = require("./controllers/users")  // ?????

app.use("/", users)

app.listen(8080, () => {
  console.log("Servidor iniciado na porta 8080: http://localhost:8080")
})


-No arquivo users.js dentro da pasta servidor e dentro da pasta controllers:

...
await db.Users.create(dados).then((dadosUsuario) => {
  return res.json({
    mensagem: "Usuário cadastrado com sucesso!", dadosUsuario
  })
}) .catch(() => {
  return res.status(400).json({
    mensagem: "Erro: Usuario não cadastrado com sucesso!"
  })
})
...


////////////////////////////////////////////////////////////////&&&
CRUD COM REACT, NODE E MYSQL
VIDEO: https://www.youtube.com/embed/e0He6sCiQT8?autoplay=1
VIDEO: https://www.youtube.com/embed/5_9rvyT9cg4?autoplay=1
VIDEO: https://www.youtube.com/embed/vzPsUWLprAw?autoplay=1

-Instale o Node JS.

-Crie uma pasta no computador chamada, por exemplo, projeto1
-Dentro dela, crie uma pasta chamada client e outra chamada server
-No terminal, dentro da pasta client, digite:
npx create-react-app pastatemp

-Recorte os arquivos criados dentro de pastatemp e cole dentro da pasta client. Depois exclua pastatemp.

---

-Dentro da pasta client, no terminal digite:
yarn add axios

---

-No arquivo App.js:

import React,{useState, useEffect} from 'react'
import Axios from 'axios'
import "./App.css"
import Pagina1 from "./components/Pagina1"      //opcional**

export default function App() {

  const [values, setValues] = useState()
  const [listProdutos, setListProdutos] = useState()

  const handleChangeValue = (valor) => {
    setValues((prevValue) => ({
      ...prevValue,
      [valor.target.name]: valor.target.value
    }))
  }

  const handleEnviar = () => {
    Axios.post("http://localhost:3001/register", {
      name: values.name,
      cost: values.cost,
      category: values.category,
    })
    .then((response)=> {
      console.log(response)
    })
  }

  useEffect(() => {                   //opcional**
    Axios.get("http://localhost:3001/getPagina1")
    .then ((response) => {
      setListProdutos(response.data)
    })
  }, [])

  return (
    <div className = "app--container">
      <div className="register--container">
        <input 
          type="text" 
          name="name" 
          placeholder="Nome" 
          className="register--input" 
          onChange={handleChangeValue} 
        />
        <input 
          type="text" 
          name="cost" 
          placeholder="Preço" className="register--input"  
          onChange={handleChangeValue} 
        />
        <input 
          type="text" 
          name="category" 
          placeholder="Categoria" className="register--input" 
          onChange={handleChangeValue} 
        />
        <button className="register--button" onClick={() => handleEnviar}>Cadastrar</button>
      </div>

      {typeof listProdutos !== "undefined" && listProdutos.map((valor) => {       //opcional**
        return (
          <Pagina1 
            key={value.id} 
            listPagina1={listProdutos} 
            setListPagina1={setListProdutos} 
            id={value.id}
            name={value.name}
            cost={value.cost}
            category={value.category}
          /> 
        )     
      })}

    </div>
  )
}

---

-No arquivo Pagina1.js dentro da pasta components:  
//opcional caso queira que seja mostrado no App.js algum valor do banco de dados

import React from 'react'

export default function Pagina1(props) {
  return (
    <div className="card--container">
      <p>{props.name}</p>
      <p>{props.cost}</p>
      <p>{props.category}</p>
    </div>
  )
}

---

-No terminal, vá para a pasta server e digite:
npm init -y

-Será criado um arquivo package.json 

---

-No terminal, dentro da pasta server digite:
yarn add mysql express cors nodemon
(Serão instalados o mysql, express, cors e nodemon)

---

-No arquivo package.json altere a seguinte parte do codigo:

...
"scripts": {
  "start": "node index.js",
  "dev": "nodemon index.js",
  "test": "echo \"Error: no test specified\" && exit 1"
}
...

-Com isso, para iniciar o servidor e ele ser atualizado automaticamente por causa do nodemon, pode-se usar no terminal os comandos:
yarn dev           (caso esteja usando o yarn)
OU
npm run dev        (caso esteja usando o npm)

---

-Crie um arquivo chamado index.js e dentro dele escreva o codigo: (opcional: TESTE PARA VER SE ESTÀ FUNCIONANDO)

const express = require("express");
const app = express();

app.get("/", (req, res) => {
  res.send("hello world");
});

app.listen(3001, () => {
  console.log("rodando servidor");
});


-Na url localhost/3001 estará aparecendo a mensagem hello world

---

-No MySQL Workbench, crie um schema chamado produtos01. Dentro dele crie uma tabela chamada tabela01
-Esta tabela terá as colunas:
  id = INT = PK, NN, AI
  name = VARCHAR(45) = NN
  cost = VARCHAR(45) = NN
  category = VARCHAR(45) = NN
-Clique em Apply e depois finish

-Se quiser ver os valores das colunas, clique com o botão direito em tabela01 e clique em Select Rows - Limit 1000

Caso queira criar um projeto no MySQL pelo console do MySQL, digite:
CREATE DATABASE produtos01 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci

O arquivo .env possui os dados para acessar o banco de dados.
Ele aparecerá após instalar as dependencias na pasta server:  npm install

---

-Agora vamos incrementar o codigo de index.js adicionando o metodo POST:

const express = require("express");
const app = express();
const mysql = require("mysql");
const cors = require("cors");

const db = mysql.createPool({
  host: "localhost",
  user: "root",
  password: "password",
  database: "produtos01",
})

app.use(cors);
app.use(express.json());

app.post("/register"), (req, res) => {
  const {name} = req.body;
  const {cost} = req.body;
  const {category} = req.body;

  let tabelaSQL = "INSERT INTO tabela01 (name, cost, category) VALUES (?, ?, ?)":

  db.query(tabelaSQL, [name, cost, category], (err, result) => {
    if (err) console.log(err);
    else res.send(result);
  })
};

app.get("/getPagina1", (req, res) => {    //opcional**
  let tabelaSQL = 
    "SELECT * from tabela01";

  db.query(tabelaSQL, (err, result) => {
    if (err) console.log(err);
    else res.send(result);
  })
});

app.listen(3001, () => {
  console.log("O servidor está rodando");
});

---

O código para editar e deletar elementos da tabela no MySQL é:
VIDEO: https://www.youtube.com/embed/vzPsUWLprAw?autoplay=1
(ESTÁ INCOMPLETO POIS ELE USA MATERIAL UI)

import React from 'react'
import Axios from 'axios'

export default function EditPage(props) {
  const [editValues, setEditValues] = useState({
    id: props.id,
    name: props.name,
    cost: props.cost,
    category: props.category,
  })

  const handleEditar = () => {
    Axios.put("http://localhost:3001/edit", {
      id: editValues.id,
      name: editValues.name,
      cost: editValues.cost,
      category: editValues.category,
    })
    .then((response)=> {
      console.log(response)
    })
  }

  const handleDeletar = () => {
    Axios.delete('http://localhost:3001/delete/${editValues.id}');
    handleClose(); 
  }
  ...
}

-No arquivo index.js na pasta server:

app.put("/edit", (req,red) => {
})

app.delete("/delete/:id", (req,res) => {
  const {id} = req.params;
  let SQL = "DELETE FROM Tabela01 WHERE id = ?";
  db.query(SQL, [id], (err, result) => {
    if (err) console.log(err);
    else res.send(result);
  })
})



////////////////////////////////////////////////////////////////&&&
FORMULARIO COM REACT, PHP E MYSQL
VIDEO: https://www.youtube.com/embed/i2TfLyDhiyE?autoplay=1

-No arquivo index.php:

<?php

function resposta($codigo, %ok, %msg) {
	header("Access-Control-Allow-Origin: *");
	header("Access-Control-Allow-Headers: *");
	header("Content-Type: application/json");

	http_response_code($codigo);
	echo (json_encode([
		'ok' => $ok,
		'msg' => $msg
	]));

	die;
}

if ($_SERVER['REQUEST_METHOD'] == "OPTIONS")
	resposta(200, true, '');

if ($_SERVER['REQUEST_METHOD'] != "POST")
	resposta(400, false, 'Método Inválido');

$conexao = new PDO('mysql:host=localhost;dbname=bancodedados','root', '1234');

$body = file_get_contents('php://input');

if (!$body){
    resposta(400, false, "Corpo da requisição não encontrado");
}

$body = json_decode($body);

$body->nome = filter_var($body->nome, FILTER_SANITIZE_STRING);
$body->email = filter_var($body->email, FILTER_VALIDATE_EMAIL);
$body->msg = filter_var($body->msg, FILTER_SANITIZE_STRING);

if (!$body->nome || !$body->email || !$body->msg)
	resposta(400, false, "Dados inválidos");

$stm = $conexao->prepare('INSERT INTO contato (nome,email,msg) VALUES (:nome, :email, : msg)');
$stm->bindParam('nome', $body->nome);
$stm->bindParam('email', $body->email);
$stm->bindParam('msg', $body->msg);
$stm->execute();

resposta(200, true, "Mensagem Salva com Sucesso");


-No arquivo App.js: (REACT)

import React,{useState} from 'react'
import './App.css'
import Api from './Api'

function App() {

  const [msg, setMsg] = useState('');

  const handleEnviar = async (e) => {
    e.preventDefault();
    setMsg(await (Api.enviar(e.target.nome.value, e.target.email.value, e.target.msg.value)));
    setTimout(()=>setMsg(''), 3000);
  }
}

export default function App(){
	return (
    <>
      <div className="form-login">
        <form className="form-login" onSubmit={handleEnviar}>
          <input type="text" name="nome" placeholder="Seu Nome" />
          <input type="email" name="email" placeholder="Seu E-mail" />
          <textarea placeholder="Sua Mensagem" name="msg"></textarea>
          <button type="submit">Enviar</button>
        </form>
      <div>
      {
        msg != '' && 
      <div className="msg">
        {msg}
      </div>
      }
    </>
	)
}

-No arquivo Api.js (dentro da pasta src):

export default {
  enviar: async (nome, email, msg) => {

    let contato = {
      nome, 
      email, 
      msg
    }

    let requisicao = {
      method: 'POST',
      headers: {'Content-Type' : 'application/json'},
      body: JSON.stringify(contato)
    }

    const response = await fetch ('http://localhost/dados/contato')
    const data = await response.json();
    return data.msg;

  }
}


-No arquivo App.css:

* {
  padding: 0;
  margin: 0;
  box-sizing: border-box;
  font-family: Arial;
}

.App {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  height: 100vh;
  background-color: #111;
}

form {
  display: flex;
  flex-direction: column;
  width: 300px;
  background-color: rgba(255,255,255,0.2);
  padding: 20px;
  border-radius: 10px;
}

form button {
  margin-top: 10px;
  padding: 10px 15px;
  background-color: #5cc;
  border: none;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
}

input, label, textarea {
  margin-top: 10px;

}

input, textarea {
  outline: none;
  border: none;
  border-radius: 20px;
  padding: 10px;
  font-size: 15px;
}

input:focus, textarea:focus {
  background-color: #EEE;
}

.msg {
  background-color: #FFF;
  text-align: center;
  padding: 10px 0px;
  font-weight: bold;
}

