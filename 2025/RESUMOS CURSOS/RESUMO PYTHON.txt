
////////////////////////////////////////////////////////// &&&
SOBRE O PYTHON

Não é necessário terminar com ;

Uma característica marcante da comunidade de desenvolvedores Python é manter uma lista de propostas de melhorias, chamadas PEP.

Python suporta a maioria das técnicas da programação orientada a objetos

A linguagem Python é desenvolvida sob uma licença de código aberto aprovada pela OSI, tornando-a livremente utilizável e distribuível, mesmo para uso comercial.

Python permite que você utilize o underline (_) como separador de milhar
Exemplo:
1_000      =>    1.000 ou 1000
1_000_000     =>  1.000.000 ou 1000000

Diferentemente da linguagem C, não existe o tipo char. Cada caractere em Python é uma string.

Python não implementa interfaces.
Interfaces são conjuntos abstratos de métodos.
São um conjunto de assinaturas de métodos. Ex: A minha interface para falar com o sistema X envolve as funções somar() recebendo dois números inteiros A e B e retornando um valor inteiro. 
Na interface não é implementado nada. Só é dito como se fala com esses sistema, mas não como ele faz.

Python não implementa sobrecarga.

/////////////////////////////////////////////////////////// &&&
INSTALANDO E RODANDO
VIDEO: https://www.youtube.com/embed/Zy3iaMZbPO8?autoplay=1

Instale o python no computador
https://www.python.org/

Ao iniciar a instalação, marque a opção Add python.exe to PATH

Instale a extensão Python no VSCode

Para rodar o arquivo no VSCode, no terminal digite dentro da pasta do arquivo:
python nome_do_arquivo.py

////////////////////////////////////////////////////////// &&&
VARIÁVEIS

Em python não é necessário declarar o tipo de variável

nome = "Carlos"       //OU nome = 'Carlos'
idade = 33
status = true

Os identificadores das variáveis podem ser compostos por Letras, o underline (_) e, com exceção do primeiro caractere, números de 0 a 9.

MinhaVariavel, _variavel, salario1 e salario1_2
São válidos.

1variavel e salario-1
Não são válidos.

MinhaVariavel e minhavariavel
São identificadores de duas variáveis distintas.

-------------

Diferentemente da linguagem C, não existe o tipo char.

-Aspas simples = Ex: 'uma string'
-Aspas duplas = Ex: "uma string"
-Aspas simples triplas = Ex: '''uma string'''
-Aspas duplas triplas = Ex: """uma string"""

Para todos esses exemplos será apresentado: 'uma string'

-------------
Atribuição múltipla:

1a forma:
a = 1
b = 2

2a forma (atribuição múltipla):
a, b = 1, 2

--------------
Inversão ou troca de valores:

a = 1
b = 2

# troca de variáveis usando variável auxiliar ‘temp’:
temp = a
a = b
b = temp

print(f"O valor da variável a é: {a}")
print(f"O valor da variável b é: {b}")

>>>  O valor da variável a é: 2
>>>  O valor da variável b é: 1

¨¨¨¨
Pode ser usada qualquer letra ou palavra no lugar de temp. Exemplo:

a = 1
b = 2

x = a
a = b
b = x

print(a)
print(b)

>>>   2
>>>   1

¨¨¨¨
# troca de variáveis através de atribuição múltipla:

a = 1
b = 2

a, b = b, a

print(f"O valor da variável a é: {a}")
print(f"O valor da variável b é: {b}")

>>>    O valor da variável a é: 2
>>>    O valor da variável b é: 1


////////////////////////////////////////////////////////// &&&
PALAVRAS RESERVADAS

Algumas palavras são consideradas reservadas e não podem ser usadas como identificadores de variáveis em Python. São elas:

and, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with e yield.

////////////////////////////////////////////////////////// &&&
PRINT

Para imprimir valores ou resultados.

print("Texto")   
>>> Texto

print(30)
>>> 30

-------

x = 10
print(x)
>>> 10

-------

nome = "Carlos"
print(nome)
>>> Carlos

----------------------------- ###

A função print() em Python atua de forma semelhante à função printf() em C.

Para um programador iniciante, as maiores diferenças entre elas são:

Duas chamadas da print() em Python:
São impressas na tela em linhas diferentes, sem a necessidade do uso do caractere ‘\n’ para pular a linha, como ocorre na printf() em C.


Uma chamada da print() em Python:
Permite a impressão de valores de variáveis sem a indicação do formato, como ocorre na printf() em C, quando precisamos escrever %c, %d ou %f, por exemplo.


////////////////////////////////////////////////////////////// &&&
TIPOS DE VARIÁVEIS

variavel = "Palavra"      => str
variavel = 'Palavra'      => str

variavel = 33             => int
variavel = 2.5            => float

variavel = true           => bool
variavel = false          => bool

////////////////////////////////////////////////////////////// &&&
CONVERTENDO TIPOS DE VARIÁVEIS

variavel = 33
str(variavel)

variavel = "2"
int(variavel)

variavel = 10
float(variavel)

-------

hora = 10
minutos = 26
segundos = 18

print(str(hora) + ' : ' + str(minutos) + ' : ' + str(segundos))

>>>   10 : 26 : 18

Atenção:
Se não separar pelo conjunto str (string), os valores serão somados. Exemplo:

hora = 10
minutos = 26
segundos = 18
print(hora + minutos + segundos)
>>>   54

Quando desejamos que a saída siga determinado padrão – por exemplo, de hora ou de data – existem algumas possibilidades para usar a função print(). É sempre possível utilizar a concatenação de strings, com o operador +, para montar a frase como quisermos.

Pode-se usar a função f também:
hora = 10
minutos = 26
segundos = 18
print(f'{hora} : {minutos} : {segundos}')
>>>   10 : 26 : 18

///////////////////////////////////////////////////////////// &&&
PARA SABER O TIPO DE VARIAVEL  type()

numero = 5
print(type(numero))
>>> <class 'int'>

------

valor='teste'
type(valor)
>>> str

valor='teste'
print(type(valor))
>>> <class 'str'>


/////////////////////////////////////////////////////////// &&&
.FORMAT
misturando strings com numeros ou variaveis

print('valor = {}'.format(12345))
ou 
print(f'valor = {12345}')

>>> valor = 12345

{ } = chaves
Obs: A informação dentro dos parênteses após .format SÓ PODEM SER NÚMEROS.

x = 10
print(f'valor = {x}')

>>> valor = 10

---------

lista = [4,8,15,16,23,42]
print(f'Os numeros de Lost são: {lista}')

>>> Os números de Lost são: [4, 8, 15, 16, 23, 42]

---------

a, b = 1, 2

print(f"O valor das variáveis: a={a}, b={b}")

>>> O valor das variáveis: a=1, b=2

Se não colocar o f na frente, vai aparecer na tela:
O valor das variáveis: a={a}, b={b}

--------------------------- ###

Considerando:
A = 10
B = 20

Para que seja impresso:
inicio 10 meio 20 final


Forma 1:  (função f)
print(f'inicio {A} meio {B} final')

Forma 2:  (.format)
print('inicio {} meio {} final'.format(A,B))

Forma 3:  (strings)
print('inicio ' + str(A) + ' meio ' + str(B) + ' final')

/////////////////////////////////////////////////////////////// &&&
QUEBRA DE TEXTO    \n
(parecido com a tag <br> no HTML)

Exemplo:

print("Primeira linha\nSegunda linha")
>>> Primeira linha
>>> Segunda linha

Python utiliza o caractere \n para quebra de linhas.

---------------------------------

Perceba que mesmo sendo composto por dois caracteres, ele representa apenas um na tabela ASCII: o caractere 10. Ele também é conhecido por ASCII LF, onde LF vem de line feed. A presença da barra invertida antecedendo o caractere n significa sequência de escape. Em outras palavras, estamos informando que este n não é a letra "êne", mas sim o comando de quebra de linha.

No Python, todas as sequências escapadas serão interpretadas quando presentes dentro de um texto (string). Isto é, se você pedir para o Python exibir a mensagem:
print("Ola\nMundo")

A sequência escapada estará em uma string e, portanto, será analisada, gerando a saída:
Ola 
Mundo

Mas nem sempre é esta saída que desejamos obter, pois pode acontecer de sua string utilizar naturalmente a barra invertida. Por exemplo, o caminho de um diretório no Windows poderia ser:
C:\temp\novos\foto.png

Se você fizer no Python:
print("C:\temp\novos\foto.png")
 
A saída gerada seria:
C: emp 
ovosoto.png

Isso porquê a sequência escapada \t representa uma tabulação e, portanto, é inserido um espaçamento dentro da string; a sequência \n é uma quebra de linha e a sequência \f não é reconhecida, então é ignorada. Neste caso, você pode adicionar um prefixo r à sua string para indicar ao Python que você deseja o seu texto da maneira que está, sem analisá-lo:
print(r"C:\temp\novos\foto.png")

Desta forma, a saída será exatamente o texto esperado:
C:\temp\novos\foto.png

Outra forma é escapar a sequência escapada (sim, você leu certo). Na verdade, o que é feito é escapar o caractere da barra invertida, indicando que aquela barra invertida não deve ser analisada como caractere de escape. Isto é:
print("C:\\temp\\novos\\foto.png")

Desta forma, o resultado produzido é idêntico ao utilizar o prefixo r no texto.

No Python ainda existe a sequência escapada \N que não deve ser confundida com \n. No primeiro o N é maiúsculo e no segundo é minúsculo. Pode parecer que não faz diferença, mas faz. Quando utilizado o prefixo u no texto desejado, indicando ao Python para interpretar o texto como Unicode, a sequência \N é utilizada para inserir caracteres através do seu nome - no Python 3, o prefixo u é desnecessário. Por exemplo, ao fazer:
print(u"\N{BLACK SPADE SUIT}")
 
A saída gerada é:
♠


////////////////////////////////////////////////////////////// &&&
VALOR COM 2 OU MAIS CASAS DECIMAIS

"{: .2f}".format(  )
ou
"..... R${: .2f}".format(  )

Exemplo:

preco = float(10)
desconto = float(2)
total = preco - desconto
print("O total é R${: .2f}".format(total))

>>> O total é R$ 8.00

¨¨¨¨
Caso não especifique o número de casas decimais:

preco = 10
desconto = 2
total = preco - desconto
print(f"{total}")

>>> 8

¨¨¨¨
preco = float(10)
desconto = float(2)
total = preco - desconto
print(f"{total}")

>>> 8.0

---------------

"{: .2f}".format(  )       =>  2 casas decimais
"{: .3f}".format(  )       =>  3 casas decimais
"{: .4f}".format(  )       =>  4 casas decimais
"{: .5f}".format(  )       =>  5 casas decimais
etc...

Exemplos:
x = float(7)
print("{: .2f}".format(x))
>>> 7.00

x = float(7)
print("{: .3f}".format(x))
>>> 7.000

x = float(7)
print("{: .5f}".format(x))
>>> 7.00000

x = float(7)
print("{: .8f}".format(x))
>>> 7.00000000

/////////////////////////////////////////////////////////////// &&&
Para especificar a largura de campo para exibir um numero inteiro:
(quantidade de espaço antes de um item mostrado)

Utilizando:
'{:  }'.format(  )

Ou para mais de um item:
'{: } , {: }'.format(x , y)
'{: } , {: } , {: }'.format(x , y , z)
etc...

Exemplo:
'{:4},{:5}'.format(10,100)
>>>    '  10,   100'

Observe que os valores 10 e 100 foram impressos com espaços em branco à esquerda. Isso ocorreu porque definimos que a primeira variável deveria ser impressa com 4 espaços com {:4} (2 foram ocupados e 2 ficaram em branco), e que a segunda variável deveria ser impressa com 5 espaços com {:5} (3 foram ocupados e 2 ficaram em branco).

Exemplos:
a-   '{:1},{:1}'.format(10,100)       =>   '10,100'
b-   '{:1},{:2}'.format(10,100)       =>   '10,100'
c-   '{:1},{:3}'.format(10,100)       =>   '10,100'
d-   '{:1},{:4}'.format(10,100)       =>   '10, 100'
e-   '{:1},{:5}'.format(10,100)       =>   '10,  100'
f-   '{:1},{:6}'.format(10,100)       =>   '10,   100'

Se a largura não for especificada, ela será determinada pela quantidade de dígitos do valor a ser impresso.

Também é válido perceber que o padrão é alinhar os valores à direita do espaço reservado para a impressão da variável.

Outro exemplo:

'{:3}'.format(20)
>>>   ' 20'

O número 20 ocupa 2 casas e foi especificado que tivessem 3 espaços antes do número. Então sobrou apenas 1 espaço antes do número.
(2 espaços são ocupados pelo número 20 e 1 espaço fica em branco)

///////////////////////////////////////////////////////////// &&&
ESCOPO

def multiplicador(numero):
  x = 2                        # esta variável tem escopo local
  print(f"Dentro da função, a variável x vale: {x}")
  return x * numero

x = 3                          # esta variável tem escopo global
y = multiplicador(5)
print(f"Fora da função, a variável x vale: {x}")

>>> Dentro da função, a variável x vale: 2
>>> Fora da função, a variável x vale: 3

-----------

def multiplicador(numero):
  global x                    # todas as referências à variável x são para a global
  x = 2                       # x global será alterado
  print(f"Dentro da função, a variável x vale: {a}")
  return x * numero

x = 3                               # esta variável tem escopo global
y = multiplicador(5)

print(f"A variável y vale: {y}")
print(f"Fora da função, a variável x vale: {x}")

////////////////////////////////////////////////////////////// &&&
Para especificar a largura de campo para exibir um inteiro, para imprimir valores de ponto flutuante com a precisão definida:
(quantidade definida de espaço antes de um item mostrado)

Utilizando:
'{:  .   }'.format(   )

Só funciona com número decimal (float) dentro de .format( )

Exemplo:

'{:8.5}'.format(10/3)
>>>    '     3.3333'

Ao usar {:8.5}, estamos determinando que a impressão será com 8 espaços, mas apenas 5 serão utilizados e + 1 espaço do ponto decimal (restando 3 espaços em branco antes)
O número 3.3333 ocupa 6 espaços. O caractere ponto (.) também conta!

Exemplos:

'{:1.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:2.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:3.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:4.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:5.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:6.5}'.format(10/3)   >>>   '3.3333'     (0 espaço vazio)
'{:7.5}'.format(10/3)   >>>   ' 3.3333'     (1 espaço vazio)
'{:8.5}'.format(10/3)   >>>   '  3.3333'     (2 espaços vazios)
'{:9.5}'.format(10/3)   >>>   '   3.3333'     (3 espaços vazios)

Outros exemplos:

'{:4.5}'.format(10/2.0)     >>>     ' 5.0'   (1 espaço vazio)
'{:6.5}'.format(10/2.0)     >>>     '   5.0'   (3 espaços vazios)

'{:5.5}'.format(3.5)     >>>     '  3.5'   (2 espaços vazios)
'{:9.5}'.format(17.25)     >>>     '    17.25'   (4 espaços vazios)

ATENÇÃO!
'{:7.5}'.format(17.25)     >>>     '  17.25'   (2 espaços vazios e aceita 7 caracteres  / aceita até 5 números)
'{:6.5}'.format(17.25)     >>>     ' 17.25'   (1 espaço vazio e aceita 6 caracteres  / aceita até 5 números)
'{:5.5}'.format(17.25)     >>>     '17.25'   (0 espaços vazios e aceita 5 caracteres  / aceita até 5 números)
'{:5.4}'.format(17.25)     >>>     '17.25'   (0 espaços vazios e aceita 5 caracteres  / aceita até 4 números)
'{:5.3}'.format(17.25)     >>>     ' 17.2'   (1 espaço vazio e aceita 5 caracteres  / aceita até 3 números)

'{:5.2}'.format(17.25)     >>>     '1.7e+01'   (0 espaços vazios e aceita 5 caracteres  / aceita até 2 números)
'{:8.2}'.format(17.25)     >>>     ' 1.7e+01'   (1 espaço vazio e aceita 8 caracteres  / aceita até 2 números)
'{:5.1}'.format(17.25)     >>>     '2e+01'   (0 espaços vazios e aceita 5 caracteres  / aceita até 1 números)

'{:9.5}'.format(1756.2523)   >>>   '   1756.3'  ARREDONDOU (3 espaços vazios e aceita 9 caracteres  / aceita até 5 números)
'{:6.5}'.format(1756.7523)   >>>   '1756.8'  ARREDONDOU (0 espaços vazios e aceita 6 caracteres  / aceita até 5 números) 

////////////////////////////////////////////////////////////// &&&
Utilitário dir e Utilitário help

Apresenta todos os atributos e métodos disponíveis para determinado tipo de dado.

print(dir(int))
ou
print(help(int))

No prompt interativo do Python, seja no Python Console do PyCharm ou em outro ambiente Python, basta digitar dir(int) e help(int) e pressionar a tecla [ENTER] ou [RETURN], sem a necessidade de usar a função print.

-----------------------

Em Python, é possível definir uma string que serve como documentação de funções definidas pelo desenvolvedor.

help()
passando como parâmetro a função desejada, essa string é exibida.
(Ele imprime o comentario acima da função )

Exemplo:

#Comentário
def teste(palavra):
  print(x)
print(help(teste))
>>> Help on function teste in module __main__:
>>> teste(palavra)
>>>        #Comentário
>>> None

ou

#Comentário
def teste(palavra):
  print(x)
help(teste)
>>> Help on function teste in module __main__:
>>> teste(palavra)
>>>        #Comentário

Adicionando mais comentários:

#Comentário 1
#Comentário 2
def teste(palavra):
  print(x)
help(teste)
>>> Help on function teste in module __main__:
>>> teste(palavra)
>>>        #Comentário 1
>>>        #Comentário 2


Exemplo para determinar o n-ésimo termo da sequência de Fibonacci:

Docstring da função fibo():
#Determina o n-ésimo termo da sequência de Fibonacci

def fibo(n):
     if n == 1 or n == 2:
         return 1
     else:
         return fibo(n - 1) + fibo(n - 2)
print(help(fibo))


Exibição da docstring da função fibo():
>>> fibo(n)
>>>       #Determina o n-ésimo termo da sequência de Fibonacci
>>> None

No codigo “Docstring da função fibo()”, a linha 2 mostra a declaração da docstring.
A linha 8 exibe a impressão na tela da chamada help(fibo). No codigo “Exibição da docstring da função fibo()”, está o resultado da execução desse programa.

//////////////////////////////////////////////////////////// &&&
INDENTAÇÃO

Diferente de C e Java, que usam as chaves { e } para delimitar os blocos, em Python todos os blocos são iniciados com o símbolo : (dois pontos) na linha superior e representados pelo acréscimo de 4 (quatro) espaços à esquerda.

Em Javascript:

if (condição) {
  instrução 1;
} else {
  instrução 2;
}

¨¨¨¨

Em Python:

if (condição) :
  instrução 1
else:
  instrução 2

//////////////////////////////////////////////////////////////////// &&&
COMENTÁRIOS

Comentários com uma linha:
Iniciados com #

# Comentário 

-------

Comentários com várias linhas:
Limitados por """ (três aspas duplas) no início e no fim

"""
comentário 1
comentário 2
"""
//////////////////////////////////////////////////////////////////// &&&
SINAIS DE MATEMÁTICA

+  (mais)
-  (menos)
*  (vezes)
/  (dividido)

%  (módulo = resto da divisão)
print(5%2)  => 1
(O resto da divisão é 1)

// (quociente inteiro)
print(5%2)  => 2
(O quociente da divisão é 2)

** exponenciação:
print (2**3)    =>   8   
(2 elevado a 3 é igual a 8)

---------

•Soma [ + ]                          =>    2.5 + 1.3 = 3.8
•Subtração [ - ]                     =>   2.5 - 1.3 = 1.2
•Multiplicação [ * ]                 =>   2.5 * 1.3 = 3.25
•Divisão [ / ]                       =>   2.5/1.3 = 1.923076923076923
•Divisão inteira [ // ]              =>   9/2 = 4
•Resto na divisão inteira [ % ]      =>   9%2 = 1
•Valor absoluto [ abs(parâmetro) ]   =>   abs(-2.5) = 2.5
•Exponenciação [ ** ]                =>   2**4 = 16

//////////////////////////////////////////////////////////////////// &&&
OPERADORES COMPOSTOS 

+=  (mais igual)        // x = x + 2   é igual a  x += 2
-=  (menos igual)
*=  (vezes igual)
/=  (dividido igual)
%=  (módulo igual)

(Provavelmente o operador //= também)

--------------------- ###

Diferente de C, em Python NÃO É POSSÍVEL incrementar ou decrementar uma variável com um operador unário, como o ++ ou --.
Ex: x++  ou x--

--------------------- ###

Quando temos tipos diferentes envolvidos na mesma expressão, o Python converte implicitamente cada operando para o tipo mais abrangente envolvido na expressão.
Estamos usando a palavra abrangente, mas poderíamos falar que existem tipos que englobam (ou contêm) outros.

Int + Int = Int
Int + Float = Float
Float + Float = Float

Int (Z - números inteiros) faz parte do conjunto float (R - Números Reais)

Exemplo:
Um número do tipo int pode ser visto como um float com a parte decimal nula. Porém, o inverso não é verdade. Ou seja, o conjunto dos inteiros (int) é um subconjunto do conjunto dos reais (float). Assim, a expressão 5 + 0.68 – que envolve um int e um float – tem como resultado 5.68. O inteiro 5 é convertido pelo Python para o número de ponto flutuante 5.0 antes que a soma (de dois valores float) seja realmente efetuada.

----------
Há 2 formas de operações algébricas:
(Implícita ou explícita)
Uso ou não de parenteses para dizer a ordem de uma operação matemática.

A precedência de operadores existente em Python (implícita) ou explicitar a ordem em que ele deseja que a expressão seja avaliada.

Sempre que o programador quiser forçar a ocorrência de uma operação antes de outras, ele pode utilizar os parênteses para aumentar a prioridade sobre ela. 

Exemplo:
A expressão 3 + 2 * 5 tem como resultado 25 ou 13? Aprendemos no ensino fundamental que as operações de produto e divisão têm precedência sobre as operações de soma e subtração. Ou seja, um produto será realizado antes de uma soma, na mesma expressão. Assim, a expressão acima tem como resultado 13. Isso ocorre sempre que não forem explicitadas outras relações de precedência com o uso de parênteses. Caso o programador quisesse forçar que a soma ocorresse primeiro, ele deveria escrever assim: (3 + 2) * 5.

Conversões explícitas:

Transforma um número de tipo decimal (float) em inteiro (int).
float(2)     =>    2.0

Transforma um número de tipo inteiro (int) em decimal (float).
int(5.1)     =>     5
("arredonda para baixo")

Atenção!
Fique atento, porque não é uma aproximação para o inteiro mais próximo, e sim o truncamento.

----------------

A tabela a seguir traz as relações de precedência entre os operadores, com as linhas mais altas tendo prioridade sobre as linhas mais baixas. Ou seja, elas ocorrem primeiro. Dentro da mesma linha, a precedência é da esquerda para a direita. Observe:

Operador	                                    Descrição
[expressões ...]	                            Definição de lista
x[ ], x[índice : índice]	                    Operador de indexação
**	                                          Exponenciação
+x, -x	                                      Sinal de positivo e negativo
*, /, //, %	                                  Produto, divisão, divisão inteira, resto
+, -	                                        Soma, subtração
in, not in, <, <=,>, >=, <>, !=, ==	          Comparações, inclusive a ocorrência em listas
not x	                                        Booleano NOT (não)
and	                                          Booleano AND (e)
or	                                          Booleano OR (ou)


///////////////////////////////////////////////////////////////////// &&&
TYPE COMPLEX

É o tipo utilizado para manipular números complexos, na forma: 

x + yj
sendo x a parte real e y a parte imaginária do complexo.

Veja dois exemplos de variáveis do tipo complex, em que a parte real é 2 e a parte imaginária é 5:

Exemplo 1:
r = complex(2,5)
r
>>>  (2+5j)

---

Exemplo 2:
w=2+5j
type (w)
>>>   <class 'complex'>

A chamada r.conjugate() retorna o conjugado do número complexo r, em que a parte real é mantida e a parte imaginária tem o seu sinal trocado.

The complex data type in python consists of two values, the first one is the real part of the complex number, and the second one is the imaginary part of the complex number. We usually denote the real part using i and the imaginary part with j. For example, (3 + 7j) or (3i + 7j).

z = 1 + 2j
print(type(z))
>>>   <class 'complex'>

a = complex(1.2 , 2.5)
print(a)
(1.2 + 2.5j)

///////////////////////////////////////////////////////////// &&&
TYPE BOOL

Trata-se de expressões que podem ser avaliadas com um dos dois valores booleanos: True ou False.

Ex: 
2<5    =>   True
2>5    =>   False

---------------

Em Python, uma conversão implícita em uma expressão algébrica não intuitiva é a dos valores booleanos True e False em 0 e 1.

True é convertido para o número 1
False é convertido para o número 0

Exemplos:
True + 3     =>    4
False + 1     =>    1

Os valores binários seguem a lógica booleana. Nela, dois valores são referidos como verdadeiro e falso, sim e não ou 0 e 1. Não importa a escolha feita para essa referência: seu conceito é o mesmo.

----------------

A relação entre os tipos bool, int e float é:
(Em termos de conjunto, assim como os conjuntos do números Inteiros, Racionais, Naturais, Irracionais, etc.)

( Float [ Int  { bool } ] )

int está dentro do conjunto float
bool está dentro dos conjuntos int e float

////////////////////////////////////////////////////////////// &&&
TYPE NOT

Exemplo:

2<5   =>   True     (tipo bool)
not(2<5)     =>    False    (operador not)

Posso escrever também:
print(not(2 < 3))

///////////////////////////////////////////////////////////// &&&
OPERADORES DE COMPARAÇÃO

<         Menor que
<=       Menor ou igual a
>         Maior que
>=       Maior ou igual a
==       Igual
!=        Não igual

O operador utilizado para comparar se dois valores são iguais é o ==, ou seja, duplo sinal de igual.
Tome cuidado para não confundir com o operador de atribuição, que é representado pelo sinal de igual apenas uma vez (=).

///////////////////////////////////////////////////////////// &&&
OPERADORES BOOLEANOS

Operador not:   (inverte o tipo bool)
Se "p = True"
Então "not(p) = False"
Se "p = False"
Então "not(p) = True"

Operador and:  (igual a multiplicação entre números positivos e negativos)
Se "p = True"  e  "q = True"
Então "p and q = True"  
Se "p = True"  e  "q = False"
Então "p and q = False"  
Se "p = False"  e  "q = True"
Então "p and q = False"  
Se "p = False"  e  "q = False"
Então "p and q = True"  

Operador or:  (false + false = false)
Se "p = True"  e  "q = True"
Então "p and q = True"  
Se "p = True"  e  "q = False"
Então "p and q = True"  
Se "p = False"  e  "q = True"
Então "p and q = True"  
Se "p = False"  e  "q = False"
Então "p and q = False"  

///////////////////////////////////////////////////////////// &&&
TRANSFORMAÇÃO DE STRINGS     upper() / lower() / split()

Upper (Coloca em letra maiúscula):

x = 'teste de strings'
x.upper()

>>>   'TESTE DE STRINGS'

---------- %%%

Em Python, considere a lista abaixo:

veiculos = ["avião", "carro", "navio", "ônibus"]

Implementar uma solução através de programação funcional para transformar todos os nome em maiusculos.

Usando programação funcional (versão resumida):

veiculos = ["avião", "carro", "navio", "ônibus"]
m = map((lambda x: x.upper()), veiculos)
print(list(m))
>>> ['AVIÃO', 'CARRO', 'NAVIO', 'ÔNIBUS']

----------------

Usando programação funcional (versão SUPER resumida):

veiculos = ["avião", "carro", "navio", "ônibus"]
print(list(map((lambda x: x.upper()), veiculos)))

-----------------

Usando programação funcional (versão do professor):

veiculos = ["avião", "carro", "navio", "ônibus"]

f_maiuscula = lambda x : str.upper(x)

nomes_maiusculos = list(map(f_maiuscula, veiculos))

print(nomes_maiusculos)

>>> ['AVIÃO', 'CARRO', 'NAVIO', 'ÔNIBUS']

------------------------------------------------------

Sem usar programação funcional:

veiculos = ["avião", "carro", "navio", "ônibus"]
veiculos2 = [ ]

for x in veiculos:
  veiculos2.append(x.upper())

print(veiculos2)
>>> ['AVIÃO', 'CARRO', 'NAVIO', 'ÔNIBUS']

Ou para imprimir cada um dos itens sem colocar em uma lista:

veiculos = ["avião", "carro", "navio", "ônibus"]

for x in veiculos:
  print(x.upper())
>>> AVIÃO 
>>> CARRO 
>>> NAVIO 
>>> ÔNIBUS

------------------------------------------------ ###
Lower (Coloca em letra minúscula):

x = 'TESTE DE STRINGS'
x.lower()

>>>   'teste de strings'

----------------------------------------------- ###
Split (separa as palavras por virgulas):

x='teste de strings'
x.split()

>>>  ['teste', 'de', 'strings']

A lista gerada com o método split() tem três elementos, porque a string original tinha três palavras.

------------------ %%%

o split() que quebra a string em substrings.

Exemplo de Split (separa os elementos por virgulas):

x = "teste de strings"
x.split()
>>>  ['teste', 'de', 'strings']

A lista gerada com o método split() tem três elementos, porque a string original tinha três elementos separados por espaço.

Utilizando com o comando print:

x = "teste de strings"
print(x.split())
>>> ['teste', 'de', 'strings']

-------------- %%%

Caso queira imprimir apenas um dos elementos que foram gerados, é preciso usar a sua posição na lista:

nome = "João da Silva"
nome = nome.split()    #comando split foi colocado com uma variavel
nome[0]
>>> 'João'

Utilizando com o comando print, é possível remover as aspas:

nome = "João da Silva"
nome = nome.split()
print(nome[0])
>>> João

Cuidado!
lista = "João da Silva"
lista.split()    #comando split sem nenhuma variável
print(lista[0])
>>> J

------------------- %%%

É possível usar o comando split juntamente com o comando input para separar números digitados separados por espaços:

lista = input("Digite os numeros: ")
lista = [ int(i) for i in lista.split() ]
print( lista )
>>> Digite os números: [2 4 6]
>>> [2, 4, 6]

Os números 2, 4 e 6 eram strings e estavam separados por um espaço. O comando "int(i) for i in lista.split()" separou esses 3 elementos e os transformou em numeros inteiros (int).

Caso queira imprimir especificamente um desses elementos, é preciso usar a sua posição na lista:

lista = input("Digite os números: ")
lista = [ int(i) for i in lista.split() ]
print( lista[1] )
>>> Digite os números: [2 4 6]
>>> 4

///////////////////////////////////////////////////////////// &&&
LISTAS

Listas são sequências mutáveis, normalmente usadas para armazenar coleções de itens homogêneos. 

Em Python, uma lista pode ser criada de algumas maneiras, tais como:

[ ]
Usando um par de colchetes para denotar uma lista vazia.

[a], [a, b, c]
Usando colchetes, separando os itens por vírgulas.

[x for x in iterable]
Usando a compreensão de lista.

list() ou list(iterable)
Usando o construtor do tipo list.

Iterable pode ser uma sequência, um container que suporte iteração ou um objeto iterador. 
Por exemplo, list('abc') retorna ['a', 'b', 'c'] e list( (1, 2, 3) ) retorna [1, 2, 3]. 
Se nenhum argumento for passado, o construtor cria uma lista vazia: [ ].

[ ]
>>> [ ]

[1,2,3]
>>>  [1,2,3]

['a','b','c']
>>>   ['a','b','c']

[123]
>>>  [123]

list[123]
>>> list[123]

list('123')
>>> ['1', '2', '3']

list((1, 2, 3))
>>>  [1, 2, 3]

list(('123'))
>>>  ['1', '2', '3']

list('abc')
>>>  ['a', 'b', 'c']

list(('abc'))
>>>  ['a', 'b', 'c']

list(('a,b,c'))
>>>  ['a', ',', 'b', ',', 'c']

------------------------------------- ###

a = ['10']
b = ['20']
c = ['30']

r = a + b + c

print(f' resultado = {r}')

>>>   resultado = ['10', '20', '30']

ou

a = ['10']
b = ['20']
c = ['30']

a + b + c

>>>   ['10', '20', '30']

---------------

a = ['10']
b = ['20']
c = ['30']

r = a*2 + b*3 + c*4

print(f' resultado = {r}')

>>>   resultado = ['10', '10', '20', '20', '20', '30', '30', '30', '30']

ou

a = ['10']
b = ['20']
c = ['30']

a*2 + b*3 + c*4

>>>   ['10', '10', '20', '20', '20', '30', '30', '30', '30']

A soma quando estamos trabalhando com listas funciona como uma contatenação, repetindo os números.

-----------------

a = ['10']
b = ['20']
c = ['30']

r = b*5

print(f' resultado = {r}')

>>>   resultado = ['20', '20', '20', '20', '20']

ou

a = ['10']
b = ['20']
c = ['30']

b*5

>>>   ['20', '20', '20', '20', '20']

------------------------------------- ###
Para imprimir os primeiros itens de uma lista:

lista = ["item 1" , "item 2" , "item 3" , "item 4" , "item 5" , "item 6" ]

print(lista[0:3])

>>> ["item 1", "item 2" , "item 3"]

-------------------- 
Para imprimir os últimos itens de uma lista:

lista = ["item 1" , "item 2" , "item 3" , "item 4" , "item 5" , "item 6" ]

print(lista[3:6])

>>> ["item 4", "item 5" , "item 6"]

-------------------
Para imprimir os itens de uma lista pulando de 2 em 2:

lista = ["item 1" , "item 2" , "item 3" , "item 4" , "item 5" , "item 6" ]

print(lista[0:6:2])

¨¨¨¨
De 3 em 3:

lista = ["item 1" , "item 2" , "item 3" , "item 4" , "item 5" , "item 6" , "item 7"]

print(lista[0:7:3])

>>> ["item 1", "item 4" , "item 7"]

---------------------------------------------------------- ###
Em Python, considere a lista abaixo:

lista = [0,1,1,2,3,5,8,13,21,34]

Implementar uma solução através de programação funcional para imprimir apenas os números pares.

Método usando programação funcional (com filter e lambda):

lista = [0,1,1,2,3,5,8,13,21,34]

par = filter((lambda x : x % 2 == 0) , lista)

print(list(par))
>>> [0, 2, 8, 34]

------------------------------------------------

Método usando programação funcional (com filter apenas):

lista = [0,1,1,2,3,5,8,13,21,34]

def Função(x):
    return x % 2 == 0

par = filter(Função , lista)

print(list(par))
>>> [0, 2, 8, 34]

-----------------------------------

Método sem usar programação funcional:

lista = [0,1,1,2,3,5,8,13,21,34]
lista2 = [ ]

for x in lista:
    if x % 2 == 0:
        lista2.append(x)

print(lista2)
>>> [0, 2, 8, 34]

---------------------------------------

Método do professor:

lista = [0,1,1,2,3,5,8,13,21,34]

TesteParidade = lambda x : x % 2 == 0

pares = list(filter(TesteParidade, lista))

print(TesteParidade(5)) #para saber se o número 5 é par
print(pares)
>>> False
>>> [0, 2, 8, 34]

//////////////////////////////////////////////////////////////////// &&&
FUNÇÕES LAMBDA
Paradigma funcional

Assim como em outras linguagens, o Python permite a criação de funções anônimas. Estas são definidas sem identificador (ou nome) e, normalmente, são utilizadas como argumentos para outras funções (de ordem superior).

Ela serve para preservar a utilização de funções puras.

Em Python, as funções anônimas são chamadas de funções lambda. Para criá-las, utilizamos a seguinte sintaxe:
lambda argumentos: expressão

Iniciamos com a palavra reservada lambda, seguida de uma sequência de argumentos separados por vírgula, dois pontos e uma expressão de apenas uma linha. 

As funções lambda sempre retornam o valor da expressão automaticamente. Não é necessário utilizar a palavra return.

Considere a função para multiplicar dois números a seguir:
def multiplicar(a, b):
    return a*b

A função lambda equivalente é:
lambda a, b: a*b

Temos os parâmetros a e b e a expressão a*b, que é retornado automaticamente. As funções lambda podem ser armazenadas em variáveis para depois serem chamadas como uma função qualquer.
Retornando ao exemplo da função multiplicar_por (script funcao5.py), podemos trocar a função multi por uma função lambda:

# script funcao5.py  (alterada com lambda)
def multiplicar_por(multiplicador):
    return lambda multiplicando: multiplicador * multiplicando

def main():
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2))
 
    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

if __name__ == "__main__":
    main()

------------------------------------------------------------ ###

Versão simplificada de função de ordem superior:
(sem usar função lambda)

def Função1(x):
    def Função2(y):
        return x + y
    return Função2

variavel = Função1(10)
print(variavel(5))
>>> 15

------------

Versão simplificada de função de ordem superior com 1 variável anônima (y):
(usando função lambda)

def Função1(x):
    return lambda y : x + y

variavel = Função1(10)
print(variavel(5))
>>> 15

--------------

Versão simplificada de função de ordem superior com 2 variáveis anônimas (y e z):
(usando função lambda)

def Função1(x):
    return lambda y , z : x + y + z

variavel = Função1(10)
print(variavel(5, 3))
>>> 18

------------------------------------------------- ###

Outro exemplo de função lambda com 1 variável anônima (x):
(sem usar outra função)

soma = lambda x : x + 2
resultado = soma(4)
print(resultado)
>>> 6

------------

Outro exemplo de função lambda com 2 variáveis anônimas (x e y):
(sem usar outra função)

soma = lambda x , y : x + y + 1
resultado = soma(4, 3)
print(resultado)
>>> 8

------------

minha_funcao = lambda x : x ** 2
resultado = minha_funcao(4)
print(resultado)
>>> 16

---------------------------------------------------------- ###
Utilizando a função lambda para testar condições:

Exemplo 1 com filter:
(para filtrar apenas os números pares)

lista = [0,1,2,3,5,8,13,21,34]

par = filter((lambda x : x % 2 == 0) , lista)

print(list(par))
>>> [0, 2, 8, 34]

--------------------

Exemplo 2 para testar uma condição:
(para saber se um número é par ou não)

p = lambda x : x % 2 == 0

print( p(5) )
>>> False
(O número 5 não é par, portanto deu False)

------------------

Exemplo 3 para testar uma condição de um item em uma lista:
(para saber se um número é ímpar ou não)

lista = [0,1,2,3,5,8,13,21,34]

p = lambda x : x % 2 != 0

print( p(lista[3]) )
>>> True
(O número 3 é ímpar, portanto deu True)

/////////////////////////////////////////////////////////////// &&&
ROUND()

Serve para arredondar números.

Sintaxe:
round(numero)

Para arredondar para cima um número float para o próximo número inteiro:

x = round(5.76543)

print(x)
>>> 6

----------------------------------------------------
Sintaxe:
round(numero, casasdecimais)

Para arrendondar um número float para uma certa quantidade de casas decimais:

x = round(5.76543 , 2)

print(x)
>>> 5.77

-----------

Simplificando:

print( round(5.76543 , 2) )
>>> 5.77


////////////////////////////////////////////////////////////// &&&
MAP
Paradigma funcional

Forma 1:
variavel = map( (lambda x: operação com x) , lista )
ou
variavel = map( nomedafunção , lista )

Para imprimir:
print( list(variavel) )

Forma 2 (resumida):
variavel = list( map( (lambda x: operação com x) , lista) )
ou
variavel = list( map(nomedafunção , lista) )

Para imprimir:
print(variavel)

Forma 3 (super resumida):

print( list( map( (lambda x: operação com x) , lista) ) )
ou
print( list( map(nomedafunção , lista) )

---------------------------

A função map é utilizada para aplicar uma determinada função em cada elemento de um iterável (lista, tupla, dicionários etc.), retornando um novo iterável com os valores modificados.

A função map é pura e de ordem superior, pois depende apenas de seus parâmetros e recebe uma função como parâmetro. 

Então serve para preservar a utilização de funções puras e de alta ordem, garantindo a imutabilidade dos dados (iteráveis passados como argumento).

A sua sintaxe é a seguinte:
map(função, iterável1, iterável2...)

O primeiro parâmetro da map é o nome da função (sem parênteses) que será executada para cada item do iterável. 
Os demais parâmetros são os iteráveis separados por vírgula. 
A função map sempre retorna um novo iterável.

Nos exemplos a seguir, vamos criar três scripts funcao_iterable.py, funcao_map.py e funcao_map_lambda.py. Todos executam a mesma operação. Recebem uma lista e triplicam cada item, gerando uma nova lista com os valores triplicados:

Exemplo 1 (sem usar map):
# script funcao_iterable.py
lista = [1, 2, 3, 4, 5]

def triplica_itens(iterable):
    lista_aux = [ ]
    for item in iterable:
        lista_aux.append(item * 3)
    return lista_aux

def main():
    nova_lista = triplica_itens(lista)
    print(nova_lista)

if __name__ == "__main__":
    main()
>>> [3, 6, 9, 12, 15]

--------------

Exemplo 2 (usando map):
# script funcao_map.py
lista = [1, 2, 3, 4, 5]

def triplica(item):
    return item * 3

def main():
    nova_lista = map(triplica, lista)  # função map
    print(list(nova_lista))

if __name__ == "__main__":
    main()
>>> [3, 6, 9, 12, 15]

------------------

Exemplo 3 (usando map e lambda):
# script funcao_map_lambda.py
lista = [1, 2, 3, 4, 5]

nova_lista = map(lambda item: item * 3, lista)   # função lambda

def main():
    print(list(nova_lista))

if __name__ == "__main__":
    main()
>>> [3, 6, 9, 12, 15]

Veja a seguir o que ocorreu em cada um dos scripts:

- Exemplo 1 (sem map e lambda):
Definimos uma função chamada triplica_itens, que recebe um iterável como parâmetro (def triplica_itens(iterable):), cria uma lista auxiliar para garantir imutabilidade (lista_aux = [ ]), percorre os itens do iterável passado como parâmetro (for item in iterable:), adiciona os itens triplicados à lista auxiliar (lista_aux.append(item*3)) e retorna a lista auxiliar (return lista_aux).
Essa função é chamada com o argumento lista (nova_lista = triplica_itens(lista)) e o resultado é impresso (print(nova_lista)).

- Exemplo 2 (usando map):
Definimos a função triplica, que triplica e retorna o item passado como parâmetro (def triplica(item):  e  return item * 3). É utilizada, assim como a variável lista, como argumentos para a função map (nova_lista = map(triplica, lista)).
A map vai aplicar internamente a função passada como parâmetro em cada item da lista, retornando um novo iterável(que pode ser convertido em listas, tuplas etc.). O resultado da função map é armazenado na variável nova_lista, para então ser impresso (print(list(nova_lista))).
A função map garante a imutabilidade dos iteráveis passados como argumento. Como a função map retorna um iterável, utilizamos o construtor list (iterável) para imprimir o resultado (print(list(nova_lista))).

- Exemplo 3 (usando map e lambda):
Substituímos a função triplica pela função lambda (lambda item: item*3), que foi utilizada como argumento para a função map (nova_lista = map(lambda item: item * 3, lista)). Esta vai aplicar a função lambda em cada item da lista, retornando um novo iterável que foi impresso posteriormente (print(list(nova_lista))).
Observe como o código foi reduzido e mesmo assim preservamos a utilização de funções puras (lambda), alta ordem (map) e que preservaram a imutabilidade dos dados. Tudo isso para garantir que não haja efeitos colaterais e dependência de estados.

-----------------------------------------------

Exemplo 1 simplificado (sem map e lambda):

lista1 = [1, 2, 3, 4, 5]

def Função(lista2):
    lista3 = [ ]
    for x in lista2:
        lista3.append(x + 3)
    return lista3

variavel = Função(lista1)
print(variavel)
>>> [4, 5, 6, 7, 8]

-----------------

Exemplo 2 simplificado (com map):

lista = [1, 2, 3, 4, 5]

def Função(x):
    return x + 3

variavel = map(Função, lista)
print(list(variavel))
>>> [4, 5, 6, 7, 8]

-------------------

Exemplo 3 simplificado (com map e lambda):

lista = [1, 2, 3, 4, 5]

variavel = map(lambda x : x + 3, lista)

print(list(variavel))
>>> [4, 5, 6, 7, 8]

--------------------- 

Caso queira imprimir 1 item específico da nova lista:

lista = [1, 2, 3, 4, 5]

variavel = map(lambda x: x + 3, lista)

v = list(variavel)

print( v[0] )
>>> 4

--------------------------------------------------------------------

É possível utilizar map com mais de uma lista:

listaX = [2 , 3]
listaY = [1 , 3]

z = lambda x , y : x * y

variavel = map( z , listaX , listaY)

print(list(variavel))
>>> [2, 9]

Ou simplificando:

listaX = [2 , 3]
listaY = [1 , 3]

variavel = map( lambda x , y : x * y , listaX , listaY)

print(list(variavel))
>>> [2, 9]

---------------------------

Para arredondar números com 2 e 3 casas decimais:

numeros = [9.56783, 7.57568, 3.00914, 6.2321]
casasdecimais = [2, 2, 3, 3]

resultado = map(lambda x , y : round(x , y) , numeros , casasdecimais)

print( list(resultado) )
>>> [9.57, 7.58, 3.009, 6.232]

------------------------------------------------------ ###
Em Python, considere a lista abaixo:

lista_numeros = [9.56783, 7.57568, 3.00914, 6.2321]

lista_precisao = [2, 2, 3, 3]

Implementar uma solução através de programação funcional para arredondar os valores da lista de números na mesma ordem da lista de precisão.

Forma 1 (do professor):

lista_numeros = [9.56783, 7.57568, 3.00914, 6.2321]
lista_precisao = [2, 2, 3, 3]

arredondamento = lambda x , y : round(x , y)

resultado = list(map(arredondamento , lista_numeros , lista_precisao))

print(resultado)
>>> [9.57, 7.58, 3.009, 6.232]

-----------------------------------------

Forma 2 (do professor):
(simplificada)

lista_numeros = [9.56783, 7.57568, 3.00914, 6.2321]
lista_precisao = [2, 2, 3, 3]

resultado = map(lambda x , y : round(x , y) , lista_numeros , lista_precisao)

print( list(resultado) )
>>> [9.57, 7.58, 3.009, 6.232]

-----------------------------------------

Forma 3 (mais trabalhosa):

import operator

lista_numeros = [9.56783, 7.57568, 3.00914, 6.2321]
lista_numeros1 = [lista_numeros[0], lista_numeros[1]]
lista_numeros2 = [lista_numeros[2], lista_numeros[3]]

ordem1 = list(map(lambda x : f"{x:.2f}", lista_numeros1))
ordem2 = list(map(lambda x : f"{x:.3f}", lista_numeros2))

c = operator.concat(ordem1, ordem2)

print(c)
>>> ['9.57', '7.58', '3.009', '6.232']

/////////////////////////////////////////////////////////////// &&&
OPERATOR
Paradigma funcional

operator.funcao(x, y)

Exemplo usando add (para somar => a + b):

import operator
print (operator.add(10, 20))
>>> 30

Só é possível utilizar com 2 variáveis. 
Para utilizar com mais de 2 variáveis, pode-se usar o reduce do functools:

import operator
from functools import reduce
lista = [10, 20, 30]
print(reduce(operator.add, lista))
>>> 60

-----------------

Exemplo usando mul (para multiplicar => a * b):

import operator
print(operator.mul(10, 20))
>>> 200

-----------------

Exemplo usando sub (para subtrair => a - b):

import operator
print(operator.sub(10, 3))
>>> 7

------------------

Exemplo usando truediv (para divisão inteira => a / b )

import operator
print(operator.truediv(10, 2))
>>> 5.0

-------------------

Exemplo usando mod (para achar o resto da divisão => a % b)

import operator
print(operator.mod(10, 3))
>>> 1

--------------------

Exemplo usando floordiv (para achar o quociente da divisão => a // b)

import operator
print(operator.floordiv(10, 3))
>>> 3

--------------------

Exemplo usando pow (para exponenciação => a ** b)

import operator
print(operator.pow(4, 2))
>>> 16

---------------------

Exemplo usando concat (para juntar 2 itens de uma lista):

import operator
print(operator.concat("Teste", "Exemplo"))
>>> TesteExemplo

---------------------

Exemplo usando concat (para juntar 3 ou mais itens de uma lista):

import operator
from functools import reduce
lista = ["Teste", "De", "Exemplo"]
print(reduce(operator.concat, lista))
>>> TesteDeExemplo

----------------------

Operation
Syntax
Function

Addition
a + b
add(a, b)

Concatenation
seq1 + seq2
concat(seq1, seq2)

Containment Test
obj in seq
contains(seq, obj)

Division
a / b
truediv(a, b)

Division
a // b
floordiv(a, b)

Bitwise And
a & b
and_(a, b)

Bitwise Exclusive Or
a ^ b
xor(a, b)

Bitwise Inversion
~ a
invert(a)

Bitwise Or
a | b
or_(a, b)

Exponentiation
a ** b
pow(a, b)

Identity
a is b
is_(a, b)

Identity
a is not b
is_not(a, b)

Indexed Assignment
obj[k] = v
setitem(obj, k, v)

Indexed Deletion
del obj[k]
delitem(obj, k)

Indexing
obj[k]
getitem(obj, k)

Left Shift
a << b
lshift(a, b)

Modulo
a % b
mod(a, b)

Multiplication
a * b
mul(a, b)

Matrix Multiplication
a @ b
matmul(a, b)

Negation (Arithmetic)
- a
neg(a)

Negation (Logical)
not a
not_(a)

Positive
+ a
pos(a)

Right Shift
a >> b
rshift(a, b)

Slice Assignment
seq[i:j] = values
setitem(seq, slice(i, j), values)

Slice Deletion
del seq[i:j]
delitem(seq, slice(i, j))

Slicing
seq[i:j]
getitem(seq, slice(i, j))

String Formatting
s % obj
mod(s, obj)

Subtraction
a - b
sub(a, b)

Truth Test
obj
truth(obj)

Ordering
a < b
lt(a, b)

Ordering
a <= b
le(a, b)

Equality
a == b
eq(a, b)

Difference
a != b
ne(a, b)

Ordering
a >= b
ge(a, b)

Ordering
a > b
gt(a, b)

////////////////////////////////////////////////////////////// &&&
REDUCE
Paradigma funcional

from functools import reduce
lista = [?, ?, ?, ?]
reduce(operação, lista)


Exemplo 1 com lambda:
(para somar todos os números da lista)

from functools import reduce
lista = [1, 3, 5, 6, 2]
print(reduce(lambda x , y : x + y, lista)) 
>>> 17

---------------------

Exemplo 2 com lambda:
(para achar o maior número da lista)

from functools import reduce
lista = [1, 3, 5, 6, 2]
print(reduce(lambda x , y: x if x > y else y, lista)) 
>>> 6

---------------------

Exemplo 3 com lambda:
(para achar o menor número da lista)

from functools import reduce
lista = [1, 3, 5, 6, 2]
print(reduce(lambda x , y: x if x < y else y, lista)) 
>>> 1

------------------------

Exemplo 1 com operator:
(para somar todos os números da lista)

from functools import reduce
import operator
lista = [1, 3, 5, 6, 2]
print(reduce(operator.add, lista)) 
>>> 17

------------------------

Exemplo 2 com operator:
(para subtrair todos os números da lista)

from functools import reduce
import operator
lista = [30, 3, 5, 6, 2]
print(reduce(operator.sub, lista)) 
>>> 14

-------------------------

Exemplo 3 com operator:
(para multiplicar todos os números da lista)

from functools import reduce
import operator
lista = [2, 3, 5]
print(reduce(operator.mul, lista)) 
>>> 30

------------------

Exemplo 4 com operator:
(para juntar os itens da lista)

from functools import reduce
import operator
lista = ["Teste", "De", "Exemplo"]
print(reduce(operator.add, lista)) 
>>>TesteDeExemplo

----------------------------------------------

É possível incluir a lista diretamente dentro dos parênteses do reduce:
from functools import reduce
reduce(operação, [?, ?, ?, ?])

Exemplo com lambda:
(para somar todos os números da lista)

from functools import reduce
print(reduce(lambda x , y : x + y, [1, 3, 5, 6, 2])) 
>>> 17

Exemplo com operator:
(para somar todos os números da lista)

from functools import reduce
import operator
print(reduce(operator.add, [1, 3, 5, 6, 2])) 
>>> 17

-----------------------------------------------------------------------

É possível usar reduce com 3 parâmetros. O terceiro parâmetro passará a ser o primeiro da lista:

Exemplo 1 com operator add (para somar):

from functools import reduce
import operator
lista = [4, 2, 1]
print(reduce(operator.add, lista, 3)) 
>>> 10
(O número 3 foi somado com 4 + 2 + 1. Então ficou: 3 + 4 + 2 + 1)


Exemplo 2 com operator sub (para subtrair):

from functools import reduce
import operator
lista = [4, 2, 1]
print(reduce(operator.sub, lista, 3)) 
>>> - 4
(O número 3 foi subtraído com 4 - 2 - 1. Então ficou: 3 - 4 - 2 - 1)

---------------------------------------------

O comando reduce também pode ser importado da seguinte forma:

import functools
 
lista = [1, 3, 5, 6, 2]

print(functools.reduce(lambda x, y: x + y, lista)) 

---------------------------------------------------- ###
Em Python, considere a lista abaixo:

numero = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Implementar uma solução através de programação funcional para somar todos os elementos da lista.

Usando reduce:

from functools import reduce

numero = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

soma = reduce(lambda x , y : x + y , numero)

print(soma)
>>> 55

-----------------

Usando reduce com mais uma variável:

from functools import reduce

numero = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

z = lambda x , y : x + y

soma = reduce( z , numero)

print(soma)
>>> 55

-----------------------------------------

Usando operator e reduce:

import operator
from functools import reduce

numero = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

soma = reduce(operator.add, numero)

print(soma)
>>> 55

/////////////////////////////////////////////////////////////// &&&
PARTIAL
Paradigma funcional

from functools import partial
variavel = partial( operação , valor1 )
print( variavel(valor2) )


Exemplo com operator add:

from functools import partial
variavel = partial(operator.add, 2)
print(variavel(5))
>>> 7
(O número 5 foi somado com o número 2)

Partial só aceita 2 valores. 

-----------------------------------

Exemplo com collections, attrgetter e sorted:

from functools import partial
import collections
from operator import attrgetter

pessoa = collections.namedtuple("pessoa", "nome idade")
pessoas = [pessoa("João", 40), pessoa("Ana", 20), pessoa("Renata", 25)]

print(sorted(pessoas, key=attrgetter("nome"))) #colocar em ordem alfabética pelo nome (A até Z)
print(sorted(pessoas, key=attrgetter("idade"))) #colocar em ordem pela idade (menor para maior)

>>> [pessoa(nome='Ana', idade=20), pessoa(nome='João', idade=40), pessoa(nome='Renata', idade=25)]
>>> [pessoa(nome='Ana', idade=20), pessoa(nome='Renata', idade=25), pessoa(nome='João', idade=40)]

--------------

Exemplo mais simplificado com collections, attrgetter e sorted:

from functools import partial
import collections
from operator import attrgetter

pessoa = collections.namedtuple("pessoa", "nome idade")
pessoas = [pessoa("João", 40), pessoa("Ana", 20), pessoa("Renata", 25)]

sort_name = partial(sorted, key=attrgetter("nome"))
sort_idade = partial(sorted, key=attrgetter("idade"))

print(sort_name(pessoas)) #colocar em ordem alfabética pelo nome (A até Z)
print(sort_idade(pessoas)) #colocar em ordem pela idade (menor para maior)

>>> [pessoa(nome='Ana', idade=20), pessoa(nome='João', idade=40), pessoa(nome='Renata', idade=25)]
>>> [pessoa(nome='Ana', idade=20), pessoa(nome='Renata', idade=25), pessoa(nome='João', idade=40)]

----------------------------------------------------------------

Utilizando o partial com uma api:

#tratando uma api
usuario = {
    "nome" : "Joao",
    "redes" : [ {
        "nome" : "facebook",
        "imagem_profile" : "",
        "imagem_capa" : "imagem1",
    } , {
        "nome" : "twitter",
        "imagem_profile" : "imagem2",
        "imagem_capa" : ""
    } ]
}

#retorna a imagem do profile
def get_imagem_profile(usuario):
    for rede in usuario["redes"]:
        if rede[imagem_profile]:
            return rede["imagem_profile"]
    return "default"

#retorna a imagem de capa
def get_imagem_capa(usuario):
    for rede in usuario["redes"]:
        if rede[imagem_capa]:
            return rede["imagem_capa"]
    return "default"

#utilizando partial
from functools import partial
def get_imagem(qual_imagem, usuario):
    for rede in usuario["redes"]:
        if rede[qual_imagem]:
            return rede[qual_imagem]
    return "default"

get_imagem_profile = partial(get_imagem, "imagem_profile")
get_imagem_capa = partial(get_imagem, "imagem_capa")

print(get_imagem_profile(usuario))
print(get_imagem_capa(usuario))
>>> imagem2 
>>> imagem1

////////////////////////////////////////////////////////////// &&&
SORTED
Paradigma funcional

Serve para colocar coisas em ordem.

Para colocar números em ordem do menor para o maior:

lista = [3, 7, 12, 26, 2, 8]
sorted(lista)     # ou print(sorted(lista))
>>> [2, 3, 7, 8, 12, 26]

Para colocar palavras em ordem alfabética:

lista = ["Brasil", "França", "Argentina", "Japão", "EUA", "Inglaterra"]
sorted(lista)   # ou print(sorted(lista))
>>> ['Argentina', 'Brasil', 'EUA', 'França', 'Inglaterra', 'Japão']

---------------------------------

É possível utilizar juntamente com collections, attrgetter e partial:

from functools import partial
import collections
from operator import attrgetter

pessoa = collections.namedtuple("pessoa", "nome idade")
pessoas = [pessoa("João", 40), pessoa("Ana", 20), pessoa("Renata", 25)]

print(sorted(pessoas, key=attrgetter("nome"))) #colocar em ordem alfabética pelo nome (A até Z)
print(sorted(pessoas, key=attrgetter("idade"))) #colocar em ordem pela idade (menor para maior)

>>> [pessoa(nome='Ana', idade=20), pessoa(nome='João', idade=40), pessoa(nome='Renata', idade=25)]
>>> [pessoa(nome='Ana', idade=20), pessoa(nome='Renata', idade=25), pessoa(nome='João', idade=40)]

--------------

Exemplo mais simplificado com collections, attrgetter e sorted:

from functools import partial
import collections
from operator import attrgetter

pessoa = collections.namedtuple("pessoa", "nome idade")
pessoas = [pessoa("João", 40), pessoa("Ana", 20), pessoa("Renata", 25)]

sort_name = partial(sorted, key=attrgetter("nome"))
sort_idade = partial(sorted, key=attrgetter("idade"))

print(sort_name(pessoas)) #colocar em ordem alfabética pelo nome (A até Z)
print(sort_idade(pessoas)) #colocar em ordem pela idade (menor para maior)

>>> [pessoa(nome='Ana', idade=20), pessoa(nome='João', idade=40), pessoa(nome='Renata', idade=25)]
>>> [pessoa(nome='Ana', idade=20), pessoa(nome='Renata', idade=25), pessoa(nome='João', idade=40)]

////////////////////////////////////////////////////////////// &&&
FILTER
Paradigma funcional

variavel = filter((lambda x: condição de x), lista)
ou 
variavel = filter((Função), lista)

Para imprimir:
print( list(variavel) )


É utilizada para filtrar elementos de um iterável (lista, tupla, dicionários etc.). O filtro é realizado utilizando uma função, que deve ser capaz de retornar true ou false (verdadeiro ou falso) para cada elemento do iterável.

Todo elemento que for avaliado como true será incluído em um novo iterável retornado pela função filter, que é pura e de alta ordem, pois depende apenas dos parâmetros e recebe uma função como parâmetro. 

A sua sintaxe é a seguinte:
filter(função, iterável)

O primeiro parâmetro da função filter é o nome da função (sem parênteses), que será executada para cada item do iterável. O segundo parâmetro é o iterável. A função filter sempre retorna um novo iterável, mesmo que vazio.

Nos exemplos a seguir, funções função_filtro_iterable.py, função_filter.py e função_filter_lambda.py, vamos criar três scripts. Todos fazem a mesma filtragem. Recebem uma lista e retornam os elementos ímpares, gerando uma nova lista, de forma a garantir a imutabilidade.

Exemplo 1 (sem filter):

# script funcao_filtro_iterable.py
lista = [1, 2, 3, 4, 5]

def impares(iterable):
    lista_aux = [ ]
    for item in iterable:
        if item % 2 != 0:
            lista_aux.append(item)
    return lista_aux

def main():
    nova_lista = impares(lista)
    print(nova_lista)

if __name__ == "__main__":
    main()

>>> [1, 3, 5]

--------------

Exemplo 2 (com filter):

# script funcao_filter.py
lista = [1, 2, 3, 4, 5]

def impar(item):
    return item % 2 != 0

def main():
    nova_lista = filter(impar, lista)
    print(list(nova_lista))

if __name__ == "__main__":
    main()

>>> [1, 3, 5]

---------------

Exemplo 3 (com filter e lambda):

# script funcao_filter_lambda.py
lista = [1, 2, 3, 4, 5]

nova_lista = filter(lambda item : item % 2 != 0, lista)

def main():
    print(list(nova_lista))

if __name__ == "__main__":
    main()

>>> [1, 3, 5]

----------------

Veja o que ocorreu com cada um dos scripts:

Exemplo 1 (sem filter):
Definimos uma função chamada ímpares, que recebe um iterável como parâmetro (def impares(iterable):), cria uma lista auxiliar para garantir imutabilidade (lista_aux = [ ]), percorre os itens do iterável passados como parâmetros (for item in iterable:), adiciona os itens ímpares à lista auxiliar (if item % 2 != 0:  /   lista_aux.append(item)) e retorna a lista auxiliar (return lista_aux).
Essa função é chamada com o argumento lista (nova_lista = impares(lista)) e o resultado é impresso (print(nova_lista)).

Exemplo 2 (com filter):
Definimos a função ímpar, que retorna true se o item passado como parâmetro é ímpar ou false caso contrário (def impar(item):   /   return item % 2 != 0). Utilizamos essa função, assim como a variável lista, como argumentos para a função filter (nova_lista = filter(impar, lista)).
A filter vai aplicar, internamente, a função passada como parâmetro em cada item da lista, retornando um novo iterável (que pode ser convertido em listas, tuplas etc.). O resultado da função filter é armazenado na variável nova_lista, para então ser impresso (print(list(nova_lista))).
A função filter garante a imutabilidade dos iteráveis passados como argumento. Como a função filter retorna um iterável, utilizamos o construtor list(iterável) para imprimir o resultado (print(list(nova_lista))).

Exemplo 3 (com filter e lambda):
Substituímos a função ímpar pela função lambda (lambda item: item%2 != 0) que foi utilizada como argumento para a função filter (nova_lista = filter(lambda item: item % 2 != 0, lista)).
Esta vai aplicar a função lambda em cada item da lista, retornando um novo iterável que foi impresso posteriormente (print(list(nova_lista))).

-------------------------------------------- %%%

Exemplo 1 simplificado (sem filter):

lista = [1, 2, 3, 4, 5]

def Função(lista):
    novalista = [ ]
    for x in lista:
        if x % 2 != 0:
            novalista.append(x)
    return novalista

variavel = Função(lista)
print(variavel)
>>> [1, 3, 5]

---------------------------------------------- %%%

Exemplo 2 simplificado (com filter):

lista = [1, 2, 3, 4, 5]

def Função(x):
    return x % 2 != 0

novalista = filter(Função, lista)
print(list(novalista))
>>> [1, 3, 5]

--------------------------------------------- %%%

Exemplo 3 simplificado (com filter e lambda):

lista = [1, 2, 3, 4, 5]

novalista = filter(lambda x : x % 2 != 0, lista)

print(list(novalista))
>>> [1, 3, 5]

-------------------------------------------- %%%

Exemplo 4-1 (sem programação funcional):

lista = [1, 2, 3, 4, 5]
novalista = [ ]

for x in lista:
    if x % 2 != 0:
        novalista.append(x)
       
print(novalista)
>>> [1, 3, 5]

-----------------

Exemplo 4-2 (sem usar programação funcional):

lista = [1, 2, 3, 4, 5]

for x in lista:
    if x % 2 != 0:
        print(x)
>>> 1
>>> 3
>>> 5

------------------------------- %%%

Usando o filter com resultados booleanos True e False:

lista = [0, 5, 10, 15, 20, 25, 30]

def Função(numero):
    if numero > 10:
        return True
    return False

novalista = filter(Função, lista)

print(list(novalista))
>>> [15, 20, 25, 30]

///////////////////////////////////////////////////////////// &&&
TUPLAS

Tuplas são sequências imutáveis, tipicamente usadas para armazenar coleções de itens heterogêneos.


Elas são aplicadas também quando é necessário utilizar uma sequência imutável de dados homogêneos. Uma tupla pode ser criada de algumas maneiras, tais como:

()
Usando um par de parênteses para denotar uma tupla vazia.

a, b, c ou (a, b, c)
Separando os itens por vírgulas.

tuple() ou tuple(iterable)
Usando o construtor do tipo tuple.

Igual as listas, iterable pode ser uma sequência, um container que suporte iteração ou um objeto iterador. 
Por exemplo, tuple('abc') retorna ('a', 'b', 'c') e tuple( [1, 2, 3] ) retorna (1, 2, 3). 
Se nenhum argumento for passado, o construtor cria uma tupla vazia: ().

Note que o uso das vírgulas é o que gera a tupla, e não o uso de parênteses. Os parênteses são opcionais, exceto no caso em que queremos gerar uma tupla vazia.


Exemplos:
( )
>>> ( )

(1,2,3)
>>>  (1,2,3)

('a','b','c')
>>>   ('a','b','c')

(123)
>>>  123

tuple(123)
>>> mensagem de erro

tuple('123')
>>> ('1', '2', '3')

tuple((1,2,3))
>>>  (1, 2, 3)

tuple(('123'))
>>>  ('1', '2', '3')

tuple('abc')
>>>  ('a', 'b', 'c')

tuple(('abc'))
>>>  ('a', 'b', 'c')

tuple(('a,b,c'))
>>>  ('a', ',', 'b', ',', 'c')

///////////////////////////////////////////////////////////// &&&
IMPRESSÃO DE SEQUENCIAS (EM LISTAS OU TUPLAS)    [ : ] ou [ :  : ]
(em ordem e de trás para frente)

x = [   ,   ,   ]
print(x)
>>>   [   ,   ,   ]

Exemplo:
seq = [0 , 1 , 2]
print(seq)
>>> [0 , 1 , 2]

Em Python, basta chamar a função print() passando como parâmetro a sequência.

Para imprimir uma substring, por exemplo, basta utilizar os colchetes para indicar o intervalo de índices que deve ser impresso. Vale lembrar que o primeiro caractere da string é indexado com 0.

Exemplo 1:
x = 'Hello World'
print(x[0:4]) 
>>>    Hell

Exemplo 2:
x = 'Hello World'
print(x[2:8])
>>>    llo Wo 

Atenção!
Usar [0:4] provoca a impressão dos índices 0, 1, 2 e 3, mas não do índice 4. Analogamente, usar [2:8] provoca a impressão dos índices de 2 a 7, mas não do 8.

Também é possível imprimir a string como lida da direita para a esquerda. Para isso, deve-se utilizar [: : -1]. Esse valor -1 indica que a leitura dos caracteres será feita no sentido oposto ao tradicional. Observe:

x = 'Hello World'
print(x[   :   : -1])
>>>     dlroW olleH

x = 'Hello World'
print(x[ 8 : 2 : -1 ])
>>>     roW ol

Fique atento quando utilizar o intervalo na impressão no sentido inverso, porque os limites do intervalo devem respeitar esse sentido.

Lembre-se:
Assim como em C ou Java, a indexação dos itens é iniciada com 0 e cada item tem o seu índice incrementado uma unidade em relação ao item anterior. Porém, Python também permite a indexação com valores negativos. O valor -1 é o índice do último item, e cada item anterior é decrementado de uma unidade em relação ao sucessor, veja:

índice	            0	 1	2	 3	4
s	                  t	 e	s	 t	e
índice negativo	   -5	-4 -3	-2 -1

-----

L = [1,2,3,4,5,6,7,8]
print L[::-1]
>>> [8,7,6,5,4,3,2,1]

///////////////////////////////////////////////////////////// &&&
RANGE()

O tipo range representa uma sequência imutável de números e frequentemente é usado em loops de um número específico de vezes, como o for.

Por exemplo, range(3) cria a sequência (0, 1, 2):

for x in range(3):
    print(x)
>>> 0
>>> 1
>>> 2

x = range(3)
for n in x:
  print(n)
>>> 0
>>> 1
>>> 2

list(range(3))
>>> [0, 1, 2]

Ele pode ser chamado de maneira simples, apenas com um argumento. Nesse caso, a sequência começará em 0 e será incrementada de uma unidade até o limite do parâmetro passado (exclusive). 

Para que a sequência não comece em 0, podemos informar o início e o fim como parâmetros, lembrando que o parâmetro fim não entra na lista (exclusive o fim). O padrão é incrementar cada termo em uma unidade. Ou seja, a chamada range(2, 7) cria a sequência (2, 3, 4, 5, 6).

Também é possível criar sequências mais complexas, indicando os parâmetros de início, fim e passo, nessa ordem. O passo é o valor que será incrementado de um termo para o próximo. Por exemplo, range(2, 9, 3) cria a sequência (2, 5, 8).

range(x,y,z)
x = primeiro número
y = último número (e que não aparecerá)
z = intervalo de números (o quanto é somado ao numero)

Outros exemplos:

x = range(3, 6)
for n in x:
  print(n)
>>> 3
>>> 4
>>> 5

x = range(3, 10, 2)
for n in x:
  print(n)
>>> 3
>>> 5
>>> 7
>>> 9

///////////////////////////////////////////////////////////// &&&
OPERADORES SEQUENCIAIS COMUNS

Os operadores sequenciais permitem a manipulação dos tipos sequenciais, inclusive as strings.
Vale ressaltar a sobrecarga dos operadores + e *, que realizam operações diferentes quando os operandos são numéricos ou sequenciais.

Ex: "gg" in "eggs"    =>   True

O operador == verifica se as strings dos dois lados são iguais.
Porém, os operadores < e > comparam as strings usando a ordem do dicionário.

A tabela a seguir traz um pequeno conjunto dos operadores disponíveis em Python para manipulação de sequências. Lembre-se de que você pode utilizar o utilitário help no Python Console para verificar a lista completa. Para isso, basta digitar help(str) e pressionar [ENTER] no teclado.

Uso	Resultado
x in s	           True se x for um subconjunto de s
x not in s	       False se x for um subconjunto de s
s + t	             Concatenação de s e t
n*s	               Concatenação de n cópias de s
s[i]	             Caractere de índice i em s
len(s)	           Comprimento de s
min(s)	           Menor item de s
max(s)	           Maior item de s

Existem três tipos sequenciais básicos em Python:
-Listas  (list)
-Tuplas  (tuple)
-Objetos Range  (range)

////////////////////////////////////////////////////////////// &&&
DICIONÁRIOS

Os dicionários permitem que itens de uma sequência recebam índices definidos pelo usuário.

Um dicionário contém pares de (chave, valor).

O formato geral de um objeto dicionário é:
{<chave 1>:<valor 1>, <chave 2>:<valor 2>, ..., <chave i>:<valor i>}

ou resumindo:
x = {' A ' : [' a '] , ' B ' : [' b ']}
x[' A ou B ']

Considerando que:    dicionario = {chave : valor}
Obs1: se a chave for letras = precisa estar entre parenteses
país = { 'asia' : 'japão' }

Obs2: se a chave for numero = não precisa estar entre parenteses
país = { 1 : 'japão' }

Obs3: o valor precisa estar entre parenteses
país = { 'asia' : 'japão' }   =>  Correto
país = { 'asia' : japão }   =>  Errado

Obs4: se o valor possuir mais de 1 item, precisa estar entre colchetes. 
país = { 'asia' : ['japão','china'] }       =>   Correto
país = { 'asia' : 'japão','china' }         =>   Errado

país = {1:'frança', 2:'japão', 3:'EUA'} 
país = {1:['frança'], 'asia':['japão'', ''china']}

Poderíamos criar um dicionário em que cada pessoa fosse representada pelo seu CPF, com nome e sobrenome. Para isso, teríamos:

pessoas = {'111222333-44':['João','Silva'], '222333444-55':['Maria','Santos'], '333444555-66':['Jorge','Silva']}

Se quisesse procurar por:
pessoas['111222333-44']

Resultaria em:
['João','Silva']

Nesse exemplo, o dicionário tem 3 entradas. Observe como foi possível recuperar nome e sobrenome de uma entrada, baseado na chave informada ‘111222333-44’.

Outro exemplo:
comida = {'fruta':['manga'], 'doce':['pudim']}
comida['doce']

Será apresentado:
['pudim']

////////////////////////////////////////////////////////////////////////// &&&
LEN()               (length)

A função len( ) retorna o número de itens em uma lista ou objeto.
Utiliza os sinais de + e * para contar os itens.

Exemplos de len () com listas:

mylist = ["apple", "banana", "cherry"]
len(mylist)
>>> 3
(A lista mylist possui 3 itens, apple, banana e cherry)

a = ['U'] + ['RN']
len(a)
>>>  2
(Há 2 itens entre colchetes nessa lista)
(As letras precisam estar entre aspas)

O operador + realiza operações de soma para tipos numéricos e concatenação para tipos sequenciais. Assim, a variável a na linha 1 do exemplo acima passa a ser composta dos itens ‘UF’ e ‘RN’. Assim, a chamada len(a) retorna o tamanho 2, número de elementos de a. Outro exemplo:

a = ['U'] + ['RN'] + ['Z']
len(a)
>>>  3
(Há 3 itens entre colchetes nessa lista)
(As letras precisam estar entre aspas)


Quando o objeto é uma string (texto), ela retorna o número de caracteres. Exemplos:

mylist = "Hello"
len(mylist)
>>> 5
(A palavra Hello tem 5 caracteres)

mylist = "Hello_World"
len(mylist)
>>> 11
(Há 11 caracteres contando com o underline)

mylist = "Hello World"
len(mylist)
>>> 11
(Há 11 caracteres contando com o espaço entre as 2 palavras)


Para operações matemáticas:

b = ['4'] * 4
len(b)   
>>>  4    (Há quatro 4 dentro dos colchetes)

b = ['5'] * 3
len(b)   
>>>  3    (Há três 5 dentro dos colchetes)

x = [2 + 3] * 5 * 2
len(x)
>>>   10    (Há dez 2+3 dentro dos colchetes)

No primeiro exemplo, o operador * realiza operações de multiplicação para tipos numéricos e concatenação de cópias para tipos sequenciais. Assim, a variável b na linha 3 passa a ser a lista ['4', '4', '4', '4']. E a chamada len(b) retorna o tamanho 4, número de elementos de b.

Aparentemente é possível não usar aspas nos números entre colchetes. Porém, é preciso usar aspas nas letras entre colchetes.

/////////////////////////////////////////////////////////////////////////////// &&&
IN

x in s = True se x for um subconjunto de s
x not in s = False se x for um subconjunto de s

Exemplos:

"gg" in "eggs"   
>>>  True

"14" in "1245"   
>>>  False

"13" in "1345"
>>> True

"america" in "americano"
>>> True

"america" not in "americano"
>>> False

list = [5, 8, 2, 0]
8 in list      #ou "8" in "list"
>>> True

list = [5, 8, 2, 0]
4 in list     #ou "4" in "list"
>>> False

list = [5, 8, 2, 0]
"bola" in list        #bola precisa estar entre aspas
>>> False

Outros exemplos:

x = ["apple", "banana"]
print("banana" in x)
# returns True because a sequence with the value "banana" is in the list

x = ["apple", "banana"]
print("pineapple" not in x)
# returns True because a sequence with the value "pineapple" is not in the list

fruits = ["apple", "banana", "cherry"]
if "banana" in fruits:
    print("yes")
>>> yes

The in keyword is used to check if a value is present in a sequence (list, range, string etc.).
The in keyword is also used to iterate through a sequence in a for loop.

///////////////////////////////////////////////////////////////////////////// &&&
FOR ... IN ...

The for keyword is used to create a for loop.
It can be used to iterate through a sequence, like a list, tuple, etc.

Exemplos:

for x in range(1, 4):
    print(x)
>>> 1
>>> 2
>>> 3

¨¨¨¨
for x in range (0, 6):
    if x == 3:
         break
    else:
         print(x)

>>> 0
>>> 1
>>> 2

¨¨¨¨
fruits = ["apple", "banana", "cherry"]
for x in fruits:
    print(x)
>>> apple 
>>> banana 
>>> cherry

¨¨¨¨
lista = [1 , 3 , 5 ]
for itens in lista:
    print(itens)
>>> 1
>>> 3
>>> 5

¨¨¨¨
for x in range(2, 5):
  print(x)
>>> 2
>>> 3
>>> 4

¨¨¨¨
for i in range(-2, 2):
  if i > 0:
    print("YES")
  elif i == 0:
    print("WHATEVER")
  else:
    print("NO")
>>> NO
>>> NO
>>> WHATEVER
>>> YES

¨¨¨¨
for x in "banana":
  print(x)
>>> b
>>> a
>>> n
>>> a
>>> n
>>> a

¨¨¨¨
s = 0
for i in range(5):
      s += 3*i
print(s)

>>> 30

Explicação:
range(5) = 0 , 1 , 2 , 3 , 4

s = 0
s = s + 3 x i

0 + 3 x 0  =>   s = 0
0 + 3 x 1  =>   s = 3
3 + 3 x 2  =>   s = 9
9 + 3 x 3 =>   s = 18
18 + 3 x 4 =>   s = 30

O laço for vai ser repetido cinco vezes, já que range(5) retorna a sequência (0, 1, 2, 3, 4).
Vale observar que a instrução print(s) está fora do laço for, o que a levará a ser executada apenas uma vez quando o laço se encerrar.
A variável s começa com valor zero e é acrescida, a cada iteração, do valor 3*i, sendo que i pertence à sequência (0, 1, 2, 3, 4). Ou seja, s recebe estes acréscimos: 0 + 3 + 6 + 9 + 12. Assim, ela termina o laço com o valor 30, que será impresso pela instrução print(s).

------------------------------------ ###

A sintaxe da estrutura for:
for <variável> in <sequência>:
     Bloco que será repetido para todos os itens da sequência

Instrução fora do for


Outro exemplo:
for item in range(2, 9, 3):
    print(item)
>>> 2
>>> 5
>>> 8

1 - A linha 1 mostra a criação do laço com a variável item percorrendo a sequência (2, 5, 8), que é criada pela chamada range(2, 9, 3);
2 - A linha 2 indica a instrução que será executada para cada repetição desse laço. O laço for executa a instrução da linha 2 três vezes, uma para cada elemento da sequência (2, 5, 8). O resultado está exemplificado na tabela seguinte.

O laço for com uma string:
Python também permite que a repetição aconteça ao longo de uma string. Para isso, basta lembrar que a string é uma sequência de caracteres individuais.
Suponha que você queira soletrar o nome informado pelo usuário. Ao informar um nome (string) no campo Input e clicar em Executar:

nome = input("Entre com seu nome: ")
for letra in nome:
    print(letra)
>>> Entre com seu nome: [  Jorge  ]
>>> J
>>> o
>>> r
>>> g
>>> e

1 - A linha 1 faz com que a palavra inserida pelo usuário seja armazenada na variável nome;
2 - A linha 2 mostra a criação do laço, com a variável letra percorrendo a sequência de caracteres armazenada na variável nome;
- A linha 3 indica a instrução que será executada para cada repetição desse laço. O laço for executará a instrução da linha 3 tantas vezes quanto forem os elementos da sequência que está na variável nome.

Uso do laço for com qualquer sequência:
Podemos utilizar o laço for com iterações sobre qualquer sequência - e não somente as numéricas e as strings.

nomes = ['Laura', 'Lis', 'Guilherme', 'Enzo', 'Arthur']
for nome in nomes:
    print(nome)
>>> Laura
>>> Lis
>>> Guilherme
>>> Enzo
>>> Arthur

----------------------------------------- ###
Para criar uma lista de zero até o número que o usuário digitar:

n = int(input("Digite um número: "))
for x in range(0, n):
    print(x)
>>> Digite um número : [  4  ]
>>> 0
>>> 1
>>> 2
>>> 3

É preciso especificar o número como int (ou float) ou usar eval, senão dá ERRO.

Caso queira que o último número também apareça:

n = int(input("Digite um número: "))
for x in range(0, n+1):
    print(x)
>>> Digite um número : [  4  ]
>>> 0
>>> 1
>>> 2
>>> 3
>>> 4

Caso queira a lista de trás para frente:

n = int(input("Digite um número: "))
for x in range(n, 0, -1):
    print(x)
>>> Digite um número : [  4  ]
>>> 4
>>> 3
>>> 2
>>> 1

É preciso inverter a ordem e colocar -1 no final:
range(0 , 6)   => 0, 1, 2, 3, 4, 5
range(6 , 0, -1)   => 6, 5, 4, 3, 2, 1

////////////////////////////////////////////////////////////////////////////// &&&
INPUT()

nome = input("Entre com seu nome: ")

print(nome)

--------------------- ###
INPUT COM NÚMEROS

É preciso especificar o número como int (ou float) ou usar eval, senão dá ERRO.

numero = int(input("Digite um número: "))
ou
numero = float(input("Digite um número: "))
ou
numero = eval(input("Digite um número: "))

--------------------- ###

input()

Ela tanto exibe na tela o pedido, como permite que o valor informado pelo usuário seja armazenado em uma variável do seu programa. 

Exemplo: 
nome = input('Entre com seu nome: ')
print(nome)
>>>    Entre com seu nome:   [Caixa de texto]

A linha 1 fará com que a frase Entre com seu nome: seja exibida no console, mas a execução do programa fica travada até que o usuário aperte [ENTER] no teclado. Tudo o que foi digitado até o [ENTER] vai ser armazenado na variável nome. A linha 2 fará a exibição do conteúdo da variável nome.

Caso alguém digite na caixa de texto a palavra Ricardo, aparecerá impresso:
Entre com seu nome:  Ricardo
Ricardo

É importantíssimo perceber que a função input() trata tudo o que for digitado pelo usuário como uma string, armazenando na variável designada pelo programador para isso. Mesmo que o usuário entre com apenas uma letra ou um número, isso será armazenado como uma string na variável.

Outros exemplos:

comida = input()
print(comida)

Se digitar a palavra "manga" aparecerá:
manga
manga


comida = input('Tipos de comida)
print(comida)

Se digitar a palavra "macarrão" aparecerá:
Tipos de comida: macarrão 
macarrão

-----
Em Python, considere que:

numero = input('Entre com um inteiro: ')
numero = numero + 2

Caso o usuário digite o número 3 e ENTER na caixa de texto, então aparecerá:

Mensagem de Erro

Mesmo sendo um valor, a variável numero trata como a string ‘3’. Isso impede que seja realizada a operação de soma com o inteiro 2, por exemplo. Poderíamos também usar a instrução print(type(numero)) na linha 2 para confirmar, veja:

numero = input('Entre com um inteiro: ')
print(type(numero))
>>>   <class 'str'>

O que é digitado dentro da caixa de texto é considerado como um texto string (str) e não um número (int ou float).

///////////////////////////////////////////////////////////////////////////// &&&
EVAL()

Para tratar a entrada do usuário como um número e, com isso, realizar operações algébricas, por exemplo, é necessário utilizar a função eval() em conjunto com a input(), veja:

numero = eval(input('Entre com um inteiro: '))
numero = numero + 2
print(numero)
>>>  Entre com um inteiro: [     3      ]      (digitei 3)
>>>  5

Outro exemplo:
x = eval(input('O valor de x é: '))
x = x + 2          (ou x += 2)
print(x)
>>>   O valor de x é:  [      8      ]       (digitei 8)
>>>   10

A função eval() recebe uma string, mas trata como um valor numérico.

Exemplo:
s = '1 + 2'
type(s)
>>>   <class 'str'>

eval(s)
>>>   3

Mesmo tendo recebido a string ‘1+2’ como parâmetro, a função eval() efetuou a soma de 1 com 2. Observe que confirmamos que s é uma string com a instrução type(s).

------------------------------- ###

Em Python, a função eval() recebe uma string, mas trata como um valor numérico.

Exemplo:
s = '1 + 2'
type(s)
>>>   <class 'str'>

eval(s)
>>>   3

Mesmo tendo recebido a string ‘1+2’ como parâmetro, a função eval() efetuou a soma de 1 com 2. Observe que confirmamos que s é uma string com a instrução type(s).
Para tratar a entrada do usuário como um número e, com isso, realizar operações algébricas, por exemplo, é necessário utilizar a função eval() em conjunto com a input(), veja:

numero = eval(input('Entre com um inteiro: '))
numero = numero + 2
print(numero)
>>>  Entre com um inteiro: [     3      ]
>>>  5

------------

p = eval(input('PESO: '))
a = eval(input('ALTURA: '))

imc = p / (a ** 2)           # ou imc = p / a ** 2

print('O IMC é igual a: ', imc)       
#ou print(f'O IMC é igual a: {imc}')

///////////////////////////////////////////////////////////////////////////// &&&
IS / IS NOT

is = Returns True if both variables are the same object
is not = Returns True if both variables are not the same object


Considerando que:
x = ["apple", "banana"]
y = ["apple", "banana"]
z = x

print(x is z)   
# returns True because z is the same object as x

print(x is y)   
# returns False because x is not the same object as y, even if they have the same content

print(x == y) 
# to demonstrate the difference betweeen "is" and "==": this comparison returns True because x is equal to y

print(x is not z) 
# returns False because z is the same object as x

print(x is not y) 
# returns True because x is not the same object as y, even if they have the same content

print(x != y)
# to demonstrate the difference betweeen "is not" and "!=": this comparison returns False because x is equal to y

/////////////////////////////////////////////////////////////////// &&&
MIN() / MAX()

min(x) = Menor item de x
max(x) = Maior item de x

Exemplos:

min(6,7,3,8,9,23)
>>>  3

max(6,7,3,8,9,23)
>>>  23

///////////////////////////////////////////////////////////////////// &&&
IF / ELSE

a = 10
b = 20

maior = a

if (b>maior):
  maior = b

print(f'O maior número é: {maior}')

>>>O maior número é: 20

-----------------

a = 10
b = 20

if (a>b):
  print(f'O maior número é A')
else:
  print(f'O maior número é B')

>>> O maior número é B

//////////////////////////////////////////////////////////////////// &&&
ELIF      (PARECIDO COM ELSE IF)

Ela permite o teste de duas condições de forma sequencial.

Essa estrutura não existe em C, sendo necessário o encadeamento de estruturas if-else.

Em geral, o formato da estrutura elif é:

if <condição 1>:
    Bloco de código que será executado caso condição seja True

elif <condição 2>:
   Bloco de código que será executado caso condição 1 seja False e condição 2 seja True

else:
    Bloco de código que será executado caso condição 1 seja False e condição 2 seja False

Instrução fora do if

Exemplo:

nota = eval(input("Nota do aluno: "))

if (nota < 5):
    resultado = "Reprovado"
elif (nota < 7):
    resultado = "em Recuperação"
else:  
    resultado = "Aprovado"

print(f"O aluno está {resultado}")

Outro exemplo:

idade = eval(input('Informe a idade da criança: \n'))
if idade < 5:
    print('A criança deve ser vacinada contra a gripe.')
    print('Procure o posto de saúde mais próximo.')
elif idade == 5:
    print('A vacina estará disponível em breve.')
    print('Aguarde as próximas informações.')
else:
    print('A vacinação só ocorrerá daqui a 3 meses.')
    print('Informe-se novamente neste prazo.')
print('Cuide da saúde sempre. Até a próxima.')

>>> Informe a idade da criança: [   8   ]
>>> A vacinação só ocorrerá daqui a 3 meses.
>>> Informe-se novamente neste prazo.
>>> Cuide da saúde sempre. Até a próxima.

Perceba que a indentação precisa ser ajustada, uma vez que o último else é relativo ao elif. Por isso, eles precisam estar alinhados.

//////////////////////////////////////////////////////////////////////// &&&
WHILE / DO-WHILE

A diferença básica entre elas é o momento em que a condição é testada.

No laço while, a condição é testada antes da iteração.
No laço do-while, a condição é testada após a iteração.

O laço while testa e executa caso a condição seja verdadeira.
O laço do-while executa e testa.

Infelizmente, a estrutura do-while não existe em Python. Isso não chega a ser um grande problema, porque podemos adaptar nosso programa e controlar as repetições com o laço while.

----------------------------------
While:

A linha de comando será repetida enquanto a condição for verdadeira, ou seja, enquanto o valor da variável for diferente do especificado. Quando esses valores forem iguais, a condição do laço while será falsa e o laço, encerrado;

Estrutura:
while <condição>:
    Instruções com 4 espaços de indentação
Instrução fora do while

Exemplo:

while x < 5:
  x = int(input("Digite um número: "))
>>> Digite um número: [   3   ]
>>> Digite um número: [   1   ]
>>> Digite um número: [   5   ]

Enquanto a condição especificada em while for verdadeira, o código continuará repetindo.

Como exemplo inicial do uso do laço while, vamos analisar um programa em que o usuário precisa digitar a palavra “sair” para que esse laço seja encerrado.

Para que o exemplo seja executado corretamente, deve-se inserir, no campo Input do emulador, uma sequência de palavras, uma por linha, sendo que a última tem de ser a palavra “sair”.

palavra = input('Entre com uma palavra: \n ')
while palavra != 'sair':
    palavra = input('Digite sair para encerrar o laço: \n')
print('Você digitou sair e agora está fora do laço')
>>> Entre com uma palavra: [   palavra 1  ]
>>> Digite sair para encerrar o laço: [   palavra 2  ]
>>> Digite sair para encerrar o laço: [  sair  ]
>>> Você digitou sair e agora está fora do laço

1 - A linha 1 representa a solicitação ao usuário para que ele insira uma palavra a ser armazenada na variável palavra;
2 - A linha 2 cria o laço while, que depende da condição <valor da variável palavra ser diferente de ‘sair’>;
3 - A linha 3 será repetida enquanto a condição for verdadeira, ou seja, enquanto o valor da variável palavra for diferente de ‘sair’. Quando esses valores forem iguais, a condição do laço while será falsa e o laço, encerrado;
4 - A linha 4 representa a impressão da mensagem fora do laço while.

Perceba que, ao digitar ‘sair’ logo na primeira solicitação, a linha 3 do nosso programa não é executada nenhuma vez. Ou seja, o programa nem chega a entrar no laço while.

-----------------------

s = 0
a = 1
while s < 5:
      s = 3*a
      a += 1
      print(s)

>>> 3
>>> 6

Ao ser testada pela primeira vez, a condição do while é verdadeira, já que s vale zero. Assim, a variável s recebe o valor 3 (3x1), enquanto a variável a é acrescida de uma unidade, ficando com o valor 2.

Em seguida, é impresso o valor de s (3). A condição do while é então testada novamente, sendo mais uma vez verdadeira, porque s tem o valor 3 (menor que 5). Nessa iteração, a variável s recebe o valor 6 (3x2), e a variável a é acrescida de uma unidade, ficando com o valor 3.

Em seguida, é impresso o valor de s (6). A condição do while é testada novamente e se revela falsa, pois s tem o valor 6 (maior que 5). Com isso, o laço while é encerrado e nada mais é impresso. Por isso, foram impressos os valores 3 e 6.

--------------------------------------------- ###
WHILE INFINITO

Laços infinitos são úteis quando queremos executar um bloco de instruções indefinidamente.
É uma boa prática, porém, devemos lembrar e ter muito cuidado para não esquecermos de colocar uma condição de parada dentro do While True para que ele não se torne um loop infinito, ou seja, algo que será executado para sempre

Exemplo:

password = "senha" 

while True: 
    palavra = input("Digite a password: ") 
    if palavra == password: 
           break
print("Você digitou a senha correta.")

>>> Digite a password: [    tentativa 1   ]
>>> Digite a password: [    tentativa 2   ]
>>> Digite a password: [    tentativa 3   ]
>>> Digite a password: [   senha   ]
>>> Você digitou a senha correta.

O While True é muito utilizado em Python quando queremos que o código que estará dentro do bloco de loop seja executado pelo menos uma vez, como por exemplo onde dependemos da entrada do usuário para acertar alguma palavra e caso ele acerte, terminaremos o loop (condição de parada).

O laço while infinito tem o seguinte formato:

while True:
    Bloco que será repetido indefinidamente

Exemplo:
Você deseja criar uma aplicação que permaneça por meses ou anos sendo executada, registrando a temperatura ou a umidade de um ambiente. Logicamente, você possui essa informação disponível a partir da leitura de algum sensor. Você, portanto, precisa tomar cuidado e ter a certeza de que seu uso é realmente necessário para evitar problemas de consumo excessivo de memória.

------------------------------------------- ###
Para criar um sistema de senha para o usuário digitar em um campo e validar:

password = "senha" 

while True: 
    palavra = input("Digite a password: ") 
    if palavra == password: 
           break
print("Você digitou a senha correta.")

>>> Digite a password: [    tentativa 1   ]
>>> Digite a password: [    tentativa 2   ]
>>> Digite a password: [    tentativa 3   ]
>>> Digite a password: [   senha   ]
>>> Você digitou a senha correta.

Outra alternativa:

while True: 
    palavra = input("Digite a password: ") 
    if palavra == 'senha': 
           break
print("Você digitou a senha correta.")

>>> Digite a password: [    tentativa 1   ]
>>> Digite a password: [    tentativa 2   ]
>>> Digite a password: [    tentativa 3   ]
>>> Digite a password: [   senha   ]
>>> Você digitou a senha correta.

//////////////////////////////////////////////////////////////////////// &&&
BREAK

A instrução break funciona da mesma maneira em C e em Python. Ela interrompe as repetições dos laços for e while. Quando a execução do programa chega a uma instrução break, a repetição é encerrada e o fluxo do programa segue a partir da primeira instrução seguinte ao laço.

Por exemplo:

for num in range(3, 8):
    if num == 5:
        break
    else:
        print(num)
print('Laço encerrado')
>>> 3
>>> 4
>>> Laço encerrado


while True:
    palavra = input('Entre com uma palavra: \n')
    if palavra == 'sair':
        break
print('Você digitou sair e agora está fora do laço.')

>>> Entre com uma palavra: [    palavra 1   ]
>>> Entre com uma palavra: [    palavra 2   ]
>>> Entre com uma palavra: [    palavra 3   ]
>>> Entre com uma palavra: [    sair   ]
>>> Você digitou sair e agora está fora do laço.

Para que o exemplo seja executado corretamente, deve-se inserir, no campo Input do emulador, uma sequência de palavras, uma por linha, sendo que a última tem de ser a palavra “sair”.

Caso haja vários laços aninhados, o break será relativo ao laço em que estiver inserido.

Outro exemplo:

password = "senha" 

while True: 
    palavra = input("Digite a password: ") 
    if palavra == password: 
           break
print("Você digitou a senha correta.")

>>> Digite a password: [    tentativa 1   ]
>>> Digite a password: [    tentativa 2   ]
>>> Digite a password: [    tentativa 3   ]
>>> Digite a password: [   senha   ]
>>> Você digitou a senha correta.

Mais um exemplo:

while True:
    print('Você está no primeiro laço.')
    opcao1 = input('Deseja sair dele? Digite SIM para isso. \n')
    if opcao1 == 'SIM':
        break  # este break é do primeiro laço
    else:
        while True:
            print('Você está no segundo laço.')
            opcao2 = input('Deseja sair dele? Digite SIM para isso. \n')
            if opcao2 == 'SIM':
                break  # este break é do segundo laço
        print('Você saiu do segundo laço.')
print('Você saiu do primeiro laço.')

>>> Você está no primeiro laço. 
>>> Deseja sair dele? Digite SIM para isso. [  nao  ] 
>>> Você está no segundo laço. 
>>> Deseja sair dele? Digite SIM para isso. [  nao  ] 
>>> Você está no segundo laço. 
>>> Deseja sair dele? Digite SIM para isso. [  SIM  ] 
>>> Você saiu do segundo laço. 
>>> Você está no primeiro laço. 
>>>Deseja sair dele? Digite SIM para isso. [  SIM  ] 
>>>Você saiu do primeiro laço.

/////////////////////////////////////////////////////////////////////////// &&&
CONTINUE

Basicamente serve para pular uma intrução de código, indo para a instrução seguinte.
Permite colocar algo na instrução que será pulada.

A instrução continue também funciona da mesma maneira em C e em Python. Ela atua sobre as repetições dos laços for e while, como a instrução break, mas não interrompe todas as repetições do laço. Essa instrução interrompe apenas a iteração corrente, fazendo com que o laço passe para a próxima iteração.

O exemplo a seguir imprime todos os números inteiros de 3 até 8, pulando apenas o 5. Veja abaixo:

for num in range(3, 8):
    if num == 5:
        continue
    else:
        print(num)
print('Laço encerrado')
>>> 3
>>> 4
>>> 6
>>> 7
>>> Laço encerrado

Para ressaltar a diferença entre as instruções break e continue, vamos alterar a linha 3 do código anterior, trocando a instrução continue pela instrução break. Ao clicar em Executar no emulador, a nova execução será:

for num in range(3, 8):
    if num == 5:
        break
    else:
        print(num)
print('Laço encerrado')
>>> 3
>>> 4
>>> Laço encerrado

Diferença entre continue e pass:

nome = "geeks"
for x in nome:
    if x == 'k':
        print('Pass executed')
        pass
    print (x)
print( )
>>> g
>>> e
>>> e
>>> Pass executed
>>> k
>>> s

nome = "geeks"
for x in nome:
    if x == 'k':
        print('Continue executed')
        continue
    print (x)
print( )
>>> g
>>> e
>>> e
>>> Continue executed
>>> s

No exemplo acima, quando o valor de x torna-se igual a ' k', a instrução pass não fez nada e, portanto, a letra ' k' também é impressa. Enquanto no caso da instrução continue, a instrução continue transfere o controle para o início do loop, portanto, a letra k não é impressa.

//////////////////////////////////////////////////////////////////////// &&&
PASS

Permite colocar algo entre as instruções.

A instrução pass atua sobre a estrutura if, permitindo que ela seja escrita sem outras instruções a serem executadas caso a condição seja verdadeira. Assim, podemos concentrar as instruções no caso em que a condição é falsa.

Suponha que queiramos imprimir somente os números ímpares entre 1 e 10. Veja a seguir:

for num in range(1, 11):
    if num % 2 == 0:
        pass
    else:
        print(num)
print('Laço encerrado')

>>> 1
>>> 3
>>> 5
>>> 7
>>> 9
>>> Laço encerrado

Claramente, seria possível reescrever a condição do if-else para que pudéssemos transformá-lo em um if simples, sem else. Entretanto, o objetivo aqui é mostrar o uso da instrução pass.

Diferença entre Continue e Pass:

nome = "geeks"
for x in nome:
    if x == 'k':
        print('Pass executed')
        pass
    print (x)
print( )
>>> g
>>> e
>>> e
>>> Pass executed
>>> k
>>> s

nome = "geeks"
for x in nome:
    if x == 'k':
        print('Continue executed')
        continue
    print (x)
print( )
>>> g
>>> e
>>> e
>>> Continue executed
>>> s

No exemplo acima, quando o valor de x torna-se igual a ' k', a instrução pass não fez nada e, portanto, a letra ' k' também é impressa. Enquanto no caso da instrução continue, a instrução continue transfere o controle para o início do loop, portanto, a letra k não é impressa.

/////////////////////////////////////////////////////////////////// &&&
FUNÇÕES / SUBPROGRAMAS     def

As funções definidas pelo desenvolvedor devem ser precedidas pela palavra reservada def

def calculaIMC (peso, altura):
  return peso * altura

--------

Procedimentos
São aqueles que não retornam valores.

Funções
São aquelas que retornam valores.

Na maioria das linguagens que não explicita a diferença entre ambos, as funções podem ser definidas sem retornar qualquer valor, tendo um comportamento de procedimento. Esse é o caso de Python.

---------

def my_function():
  print("Hello from a function")

my_function()

>>> Hello from a function

--------

def teste(x):
  print("Quero " + x + " o resto do texto")

teste("imprimir")

>>> Quero imprimir o resto do texto

---------

def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")

>>> Emil Refsnes
>>> Tobias Refsnes
>>> Linus Refsnes

----------

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes")

>>> Emil Refsnes

-----------

def teste(x , y , z):
  print(x , y , z)

teste(2,0,1)

>>> 2 0 1

----------

def teste(x , y , z):
  print(x + y + z)

teste(2,0,1)

>>> 3

---------

def teste(x , y , z):
  print(x , y , "c" , z)

teste(2,0,1)

>>> 2 0 c 1

---------

def teste(x , y , z):
  print(x , y , z)

teste("avião","carro","bicicleta")

>>> avião carro bicicleta

---------

def teste(x , y , z):
  print(x + y + z)

teste("avião","carro","bicicleta")

>>> aviãocarrobicicleta

----------

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil")

>>> Vai dar erro pois está faltando um "argumento". 

Para deixar correto:

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes")

-----------

def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus")

>>> The youngest child is Linus


----------------------------------------- ###

escolha = input("Escolha uma opção de função: 1 ou 2\n")
if escolha == "1":
    def func1(x):
        return x + 1
    s = func1(10)
else:
    def func2(x):
        return x + 2
    s = func2(10)
print(s)

>>> Escolha uma opção de função: 1 ou 2 
[    1    ]
>>> 11

ou

>>> Escolha uma opção de função: 1 ou 2 
[    2    ]
>>> 12

----------------------------------------------- ###
SUBPROGRAMAS ANINHADOS (Funções dentro de funções)

def taximetro(distancia):
    def calculaMult():
        if distancia < 5:
            return 1.2
        else:
            return 1

    multiplicador = calculaMult()
    largada = 3
    km_rodado = 2
    valor = (largada + distancia * km_rodado) * multiplicador
    return valor

A função taximetro() tem, dentro de sua definição, a definição de outra função denominada calculaMult(). Na linha 7, a função calculaMult() é chamada, e o seu retorno é armazenado na variável multiplicador.

----------------------------------------------- ###
FUNÇÃO RECURSIVA

Uma função recursiva é aquela que chama a si mesma. 

Exemplo:

def regressiva(x):
   print(x)
   regressiva(x - 1)

Na implementação da função regressiva(), tendo x como parâmetro, ela mesma é chamada com o parâmetro x – 1. Vamos analisar a chamada regressiva(2):

Ao chamar a regressiva(2), o valor 2 é exibido na tela pela linha 2 e ocorre uma nova chamada da função regressiva() na linha 3 com o parâmetro 1. Vamos continuar com esse caminho da regressiva(1).

Ao chamar a regressiva(1), o valor 1 é exibido na tela pela linha 2 e oicorre uma nova chamada da função regressiva() na linha 3 com o parâmetro 0.

Ao chamar a regressiva(0), o valor 0 é exibido na tela e ocorre uma nova chamada de função regressiva com o parâmetro -1, e assim sucessivamente.

Atenção!
Conceitualmente, essa execução será repetida indefinidamente até que haja algum erro por falta de memória. Perceba que não definimos adequadamente uma condição de parada para a função regressiva(), o que leva a esse comportamento ruim.

Em Python, o interpretador pode interromper a execução indefinida, mas essa não é uma boa prática. Uma forma de contornar esse problema é definir adequadamente uma condição de parada como a do exemplo a seguir:

def regressiva(x):
   if x <= 0:
        print("Acabou")
    else:
        print(x)
        regressiva(x-1)

Uma função recursiva que termina tem:
1 - Um ou mais casos básicos que funcionam como condição de parada da recursão.
2 - Uma ou mais chamadas recursivas que têm como parâmetros valores mais próximos do(s) caso(s) básico(s) que o ponto de entrada da função.

Alguns exemplos clássicos de funções que podem ser implementadas de forma recursiva são o cálculo do fatorial de um inteiro não negativo e a sequência de Fibonacci.

A sequência de Fibonacci é: 
1, 1, 2, 3, 5, 8, 13, 21...

Os dois primeiros termos são 1; a partir do 3º termo, cada termo é a soma dos dois anteriores.

-------------

def rec(n):
     if n < 2:
          return rec(n - 1)

print(rec(1))

>>> ERRO

A função não tem condição de parada.

A função é recursiva, mas não apresenta parada. Ao ser chamada com o parâmetro 1, o if da linha 2 tem condição verdadeira. Então ocorre a chamada a rec(0). Mas rec(0) não é definido; assim, ocorrerá a chamada a rec(-1) - e assim sucessivamente.

//////////////////////////////////////////////////////////////////////// &&&
ESCOPO DE VARIÁVEIS EM FUNÇÕES:

def func1(x):
    x = 5                                             //variável local
    print(f'Na função func1 o x é igual a {x}')

def func2(x):
    x = 17                                             //variável local
    print(f'Na função func2 o x é igual a {x}')

x = 23                                                 //variável global

func1(x)
func2(x)

print(f'Fora das duas funções o x é igual a {x}')

>>> Na função func1 o x é igual a 5 
>>> Na função func2 o x é igual a 17 
>>> Fora das duas funções o x é igual a 23

As funções func1(x) e func2(x) não possuem qualquer retorno. Ou seja, elas são funções com comportamento de procedimentos.

Em Python, as variáveis locais podem ser:

Dinâmicas da pilha e Estáticas.

Dinâmica da pilha:
São vinculadas ao armazenamento no início da execução do subprograma e desvinculadas quando essa execução termina. As variáveis locais dinâmicas da pilha têm diversas vantagens, e a principal delas é a flexibilidade. Suas principais desvantagens são o custo do tempo - para alocar, inicializar (quando necessário) e liberar tais variáveis para cada chamada ao subprograma - e o fato de que os acessos a essas variáveis locais devem ser indiretos, enquanto os acessos às variáveis estáticas podem ser diretos.

Estáticas:
São vinculadas a cédulas de memória antes do início da execução de um programa e permanecem vinculadas a essas mesmas cédulas até que a execução do programa termine. Elas são um pouco mais eficientes que as variáveis locais dinâmicas da pilha, já que não é necessário tempo para alocar ou liberar essas variáveis. Sua maior desvantagem é a incapacidade de suportar recursão.

Nas linguagens C e C++, as variáveis locais são dinâmicas da pilha, a menos que elas sejam especificamente declaradas como static. Todas as variáveis locais em Python são dinâmicas da pilha. As variáveis globais são declaradas em definições de método; além disso, qualquer variável declarada global em um método precisa ser definida fora dele. Caso haja uma atribuição à variável local com o mesmo nome de uma variável global, a global é implicitamente declarada como local.

------------------------------------- ###


def func1(x):
    global x
    x = 10
    print(f'Na função func1 o x é igual a {x}')


def func2(x):
    global x
    x = 20
    print(f'Na função func2 o x é igual a {x}')


x = 0
func1(x)
func2(x)
print(f'Fora das duas funções o x é igual a {x}')

>>> Na função func1 o x é igual a 10 
>>> Na função func2 o x é igual a 20 
>>> Fora das duas funções o x é igual a 20

Observando a execução do código anterior, percebe-se que o print() do programa principal está na linha 16, depois da chamada à função func2(x). Dessa forma, a variável global x, alterada na execução da func2(x), fica com o valor 20 quando a execução volta ao programa principal.

------------


def func1(x):
    global x
    x = 10
    print(f'Na função func1 o x é igual a {x}')


def func2(x):
    x = 20
    print(f'Na função func2 o x é igual a {x}')


x = 0
func1(x)
func2(x)
print(f'Fora das duas funções o x é igual a {x}')

>>> Na função func1 o x é igual a 10 
>>> Na função func2 o x é igual a 20 
>>> Fora das duas funções o x é igual a 10

--------------


def func1(x):
     x = 10
     print(x)

x = 0
print(x)
func1(x)
print(x)

>>> 0
>>> 10
>>> 0

A variável x da linha 6 é global. Mas, como existe outra variável com o mesmo nome dentro da função func1() – na linha 2, apenas dentro da função func1(), x vale 10 –, chamamos essa variável de local.
Assim, o print da linha 7 recebe o valor da variável global (0). A execução da linha 8 chama a função func1(), que imprime o valor de x válido dentro dela (10). Em seguida, a execução do programa sai da função func1() e o print da linha 9 volta a enxergar a variável global x, cujo valor é 0.

----------------

def func1(x):
     print(x)

x = 0
print(x)
func1(x)
print(x)

>>> 0
>>> 0
>>> 0

---------------

def func1(x):
     print(x)

x = 0
print( )
func1( )
print( )

>>> Mensagem de erro

func1() missing 1 required positional argument: 'x'

-----------------

def func1(x):
     print(x)

x = 0
print( )
print( )
print( )

>>> 
>>> 
>>> 

(Tudo vazio)

///////////////////////////////////////////////////////////////// &&&
IMPORTANDO FUNÇÕES

Para importar funções de outro arquivo .py para um novo arquivo:

from (nome do arquivo) import (nome da função)
ou
import (nome da função)

Forma 1 (para quando só queira usar 1 função apenas):
#arquivo teste1.py:
def função():
    print("Texto de exemplo")

#arquivo teste2.py :
from teste1 import função

função()
>>> Texto de exemplo

Forma 2 (para quando queira usar mais de 1 função):
#arquivo teste1.py:
def função1():
    print("Texto de exemplo 1")

def função2():
    print("Texto de exemplo 2")

#arquivo teste2.py :
import teste1

teste1.função1()
teste1.função2()
>>> Texto de exemplo 1
>>> Texto de exemplo 2

Porém estes dois métodos acabam imprimindo todos os elementos do arquivo importado. Por exemplo:

#arquivo teste1.py:
def função():
    print("Quero imprimir")

print("Não quero imprimir")

#arquivo teste2.py :
from teste1 import função

função()
>>> Não quero imprimir
>>> Quero imprimir

Para evitar que isso aconteça, é preciso colocar tudo que não quiser que seja impresso dentro de if __name__ == "__main__":
Por exemplo:

Forma 1:
#arquivo teste1.py:
def função():
    print("Quero imprimir")

if __name__ == "__main__":
    print("Não quero imprimir")

#arquivo teste2.py :
from teste1 import função

função()
>>> Quero imprimir

Forma 2:
#arquivo teste1.py:
def função():
    print("Quero imprimir")

if __name__ == "__main__":
    print("Não quero imprimir")

#arquivo teste2.py :
import teste1

teste1.função()
>>> Quero imprimir

--------------------------------------
OUTROS EXEMPLOS:

Exemplo 1:

#arquivo teste1.py:
def função():
    print("Teste de exemplo")

if __name__ == "__main__":
    print("Não quero que seja impresso")

#arquivo teste2.py :
import teste1

teste1.função()
>>> Teste de exemplo

----------

Exemplo 2:
#arquivo teste1.py:
def função():
    return ("Teste de exemplo")

if __name__ == "__main__":
    print("Não quero que seja impresso")

#arquivo teste2.py :
import teste1

print( teste1.função() )
>>> Teste de exemplo

---------

Exemplo 3:
#arquivo teste1.py:
def função():
    x = 10
    y = 5
    return x + y

if __name__ == "__main__":
    print("Não quero que seja impresso")

#arquivo teste2.py :
import teste1

print( teste1.função() )
>>> 15

----------

Exemplo 4:
#arquivo teste1.py:
def função():
    x = 10
    y = 5
    return x + y

if __name__ == "__main__":
    print("Não quero que seja impresso")

#arquivo teste2.py :
import teste1

z = 3

print( teste1.função() + z )
>>> 18

----------------------------------------------------
Importando de dois arquivos diferentes:

#arquivo teste1.py :
def A():
    x = 10
    return x

if __name__ == "__main__":
    print("Não quero que seja impresso 1")

#arquivo teste2.py :
def B():
    y = 5
    return y

if __name__ == "__main__":
    print("Não quero que seja impresso 2")

#arquivo teste3.py :
import teste1
import teste2

x = teste1.A()
y = teste2.B()
z = 3

print( x + y + z )

>>> 18

O terceiro arquivo (teste3.py) poderia também importar da seguinte forma:
#arquivo teste3.py :
import teste1, teste2

x = teste1.A()
y = teste2.B()
z = 3

print( x + y + z )

Então, ao invés de importar cada arquivo em uma linha diferente:
import (nome do arquivo 1)
import (nome do arquivo 2)
import (nome do arquivo 3)

Poderia ser colocado tudo em uma mesma linha, separando os nomes dos arquivos por vírgulas:
import (nome do arquivo 1) , (nome do arquivo 2) , (nome do arquivo 3)

///////////////////////////////////////////////////////////////// &&&
PARAMETROS DE FUNÇÕES

def func1(x):       //Parametro formal
  return x + 1 

func1(10)           //Parametro real

Quando a chamada da função ocorre sem nenhum parâmetro real, o valor padrão é usado.

-------------------- ###

def taximetro(distancia, multiplicador=1):
    largada = 3
    km_rodado = 2
    valor = (largada + distancia * km_rodado) * multiplicador
    return valor


pagamento = taximetro(3.5)
print(pagamento)

>>> 10.0

distancia * km_rodado = 3.5 * 2  =>  7.0
largada + 7.0 = 3 + 7.0  =>  10.0
10.0 * multiplicador = 10.0 * 1  =>  10.0


Observe que, mesmo com a definição da linha 1 de dois parâmetros formais, a chamada da função na linha 9 ocorre apenas com um parâmetro real. A palavra reservada return indica que a função retorna algum valor.

Isso implica que o valor retornado seja armazenado em uma variável do programa chamador (como ocorre na linha 9) ou utilizado como parâmetro para outra função.

Atenção!
Retornar um valor é diferente de imprimir na tela. Ao utilizar a função print(), ocorre apenas a impressão de algo nela, o que não significa o retorno de qualquer função definida pelo usuário.

------------------------------------------------ ###

Os métodos de passagem de parâmetros são as maneiras existentes para transmitir ou receber os parâmetros dos subprogramas chamados.

O método de passagem de parâmetros de Python é chamado de passagem por atribuição. Como todos os valores de dados são objetos, toda variável é uma referência para um objeto.
Ao se estudar a orientação a objetos, fica mais clara a diferença entre a passagem por atribuição e a passagem por referência. Por enquanto, podemos entender que a passagem por atribuição é uma passagem por referência, pois os valores de todos os parâmetros reais são referências.

Os parâmetros podem ser passados principalmente por:

Valor
O parâmetro formal funciona como uma variável local do subprograma, sendo inicializado com o valor do parâmetro real. Dessa maneira, não ocorre uma alteração na variável externa ao subprograma caso ela seja passada como parâmetro.

Referência
Em vez de passar o valor do parâmetro real, é transmitido um caminho de acesso (normalmente, um endereço) para o subprograma chamado. Isso fornece o caminho de acesso para a célula que armazena o parâmetro real. Assim, o subprograma chamado pode acessar esse parâmetro na unidade de programa chamadora.

---------

def teste(x = "1"):
  print("EXEMPLO " + x)

teste("2")

>>> EXEMPLO 2

---------

def teste(x = "1"):
  print("EXEMPLO " + x)

teste( )

>>> EXEMPLO 1

----------

def teste(**palavra):
  print(palavra["x"])

teste(x = "avião", y = "carro", z = "bicicleta")

>>> avião

--------------------------------------------------- ###

Em Python, qual a diferença entre:

Exemplo A:
def media(x, y):
     print((x + y)/2)
x = media(1, 3)
print(x)

Exemplo B:
def media(x, y):
     return ((x + y)/2)
x = media(1, 3)
print(x)

Se você averiguar um pouco mais a fundo, verá que quando usado print, embora o valor correto seja exibido, o valor de x que recebe o retorno da função será nulo, None.

def media(x, y):
     print((x + y)/2)
x = media(1, 3)
print(x)
>>> None

Ou seja, ao utilizar o print o resultado é enviado ao buffer de saída e depois descartado. O valor x, que iria receber o resultado, recebe um valor nulo, pois a função não tem retorno.
Diferente se você utilizar o return, pois o valor será retornado pela função e atribuído em x:

def media(x, y):
     return ((x + y)/2)
x = media(1, 3)
print(x)
>>> 2

Perceba que mesmo chamando a função, a saída não é exibida até ser executado o print(x), isso porque a função envia o retorno para x e não mais para o buffer de saída.

Imagine que você precisa somar 5 na média entre 1 e 3. Usando print você não conseguirá fazer x+5, pois x é nulo, uma vez que a função não teve retorno - e não é possível somar 5 em nulo. Já utilizando o return, o resultado 2 será armazenado em x e, assim, será possível somar 5.

De forma ideal, uma função não deve utilizar print, a menos que essa seja explicitamente seu objetivo: exibir os dados. Uma função que calcula a média não deveria ter a responsabilidade de exibir a média. Isso quebra o princípio de responsabilidade única e deixa seu código pouco reutilizável.

Quando você utiliza o return, você terá acesso direto e poder de manipular o retorno da função, o que gera um código muito mais versátil e maleável para você.

Imagine o seguinte problema:
Some a média entre 1 e 3 com a média entre 7 e 9.

Usando o print, o resultado a primeira média, 2, será exibido na tela, bem como o resultado da segunda média, 8. Precisará alguém fazer manualmente a soma de 2 e 8 para obter o resultado 10.

Quando você usa o return, você consegue acessar os resultados dentro do programa ainda, podendo fazer:

x = media(1, 3) 
y = media(7, 9) 
x+y 
>>> 10

Você não precisa saber quais são os resultados parciais para obter o total; se por acaso precisar mudar media(7, 9) para media(7, 11), o resultado x+y automaticamente passará a ser 11.

Apesar de parecerem iguais, elas são totalmente diferentes e são utilizadas em contextos completamente diferentes.

A função print é usada para imprimir uma dada informação no console (terminal) onde estiver programando. Observe: print significa impressão em inglês.

Quanto a função return, retorna alguma informação de "dentro" de uma função qualquer. 
Observe: return significa retornar em inglês

Essa coincidência acontece no python, mas em java por exemplo você não conseguiria ver a impressão de um return como foi feito sem uma função "print".

A sua confusão vem do fato do python, no prompt de comando (REPL) >>>, imprimir automaticamente o valor retornado.

Isso não ocorre normalmente, só quando está executando comandos no prompt imediato do python - é uma questão de conveniência - para facilitar o uso do interpretador imediato de comandos, tem um print() embutido que imprime o valor de retorno.

Em um programa verdadeiro, onde você escreve o código em um arquivo e comanda a execução do mesmo, somente o print() gera saída na tela. O return não vai gerar saída nenhuma neste caso.

///////////////////////////////////////////////////////////////////////////// &&&
MÓDULO MATH

Esse módulo provê acesso a funções matemáticas de argumentos reais. 
O módulo math não permite operações com números complexos.

Algumas das funções do módulo math são:

sqrt(x) = Raiz quadrada de x
ceil(x) = Menor inteiro maior ou igual a x
floor(x) = Maior inteiro menor ou igual a x
cos(x) = Cosseno de x
sin(x) = Seno de x
log(x, b) = Logaritmo de x na base b
pi = Valor de Pi (3.141592...)
e = Valor de e (2.718281...)

------------------------------------ ###
MATH.SQRT()
Para achar a raiz quadrada.

import math

x = math.sqrt(4)
print(x)
>>> 2.0

ou se quiser um número inteiro e não float:

import math
x = int(math.sqrt(4))
print(x)
>>> 2

---------

import math

x = math.sqrt(5)
print(x)
>>> 2.23606797749979

-------------------------------------- ###
MATH.CEIL()

módulo : math
função : ceil(x)

ceil = ceiling = teto
Ele acha o menor número inteiro maior ou igual a x.
(arredondar para cima)

Exemplo:

import math
x = math.ceil(9)
print(x)
>>> 9

import math
x = math.ceil(9.3)
print(x)
>>> 10

------

import math
n = 5.9
print(math.ceil(n))
>>> 6

ou 

import math
print(math.ceil(5.9))
>>> 6

-------------------------------------- ###
MATH.FLOOR()

módulo : math
função : floor(x)

floor = piso / chão
Ele acha o maior número inteiro menor ou igual a x.
(arredondar para baixo)

Exemplo:

import math
x = math.floor(9)
print(x)
>>> 9

import math
x = math.floor(9.3)
print(x)
>>> 9

-------------------------------------- ###
MATH.COS() / MATH.SIN() / MATH.TAN()


Para achar o cosseno de x:

módulo : math
função : cos(x)

Exemplo:

import math
x = math.cos(45)
print(x)
>>> 0.5253219888177297


¨¨¨¨
Para achar o seno de x:

módulo : math
função : cos(x)

Exemplo:

import math
x = math.sin(45)
print(x)
>>> 0.8509035245341184

¨¨¨¨
Para achar a tangente de x:

módulo : math
função : tan(x)

Exemplo:

import math
x = math.tan(45)
print(x)
>>> 1.6197751905438615

------------

TABELA TRIGONOMÉTRICA:
Seno, cosseno e tangente são conhecidos como razões trigonométricas. Eles são resultados da divisão de dois lados de um triângulo retângulo. Veja abaixo:

• Seno (sen) = cateto oposto / hipotenusa;
• Cosseno (Cos) = cateto adjacente / hipotenusa;
• Tangente (Tg) = cateto oposto / cateto adjacente.

Sendo cateto adjacente o maior e cateto oposto o menor.

Exemplo:
Se um triângulo retângulo possui: 
hipotenusa = 13 cm
cateto adjacente = 12 cm
cateto oposto = 5 cm
Qual o seno, cosseno e tangente do angulo alpha que fica entre o cateto oposto e adjacente?

sen = cateto oposto / hipotenusa = 5 / 13 +-= 0,384
cos = cateto adjacente / hipotenusa = 12 / 13 +-= 0,923
tan = cateto oposto / cateto adjacente = 5 / 12 +-= 0,416

Exemplo 2:
Se um triângulo retângulo possui um dos angulos em 45 graus e:
hipotenusa = 10 cm
cateto adjacente = x
cateto oposto =  y
Quem é x?

Observe que temos a medida da hipotenusa (10 cm) e queremos descobrir a medida de x, que é o cateto oposto ao ângulo de 45º. Desta forma, aplicaremos a fórmula do seno.
De acordo com a tabela trigonométrica, o valor do seno de 45.º é aproximadamente igual a 0,7071. Assim:
sen 45o = x / 10
0,7071 = x / 10
x = 0,7071.10
x = 7, 071
Portanto, o lado x mede 7,071 cm.

Os valores de seno, cosseno e tangente podem ser positivos ou negativos de acordo com as suas posições no círculo trigonométrico - circunferência elaborada em um sistema de coordenadas cartesianas. 

O círculo trigonométrico ao ser dividido em quatro partes, consequentemente, dá origem a quatro quadrantes, os quais são numerados no sentido anti-horário, e determinam os sinais das razões trigonométricas.

• 1° quadrante (0° a 90°): seno (+), cosseno (+) e tangente (+);
• 2° quadrante (90° a 180°): seno (+), cosseno (-) e tangente (-);
• 3°quadrante (180° a 270°): seno (-), seno (-) e tangente (+);
• 4° quadrante (270° a 360°): seno (-), cosseno (+) tangente (-).

seno (30) = 1 / 2
seno (45) = √2 / 2
seno (60) = √3 / 2

cos (30) = √3 / 2
cos (45) = √2 / 2
cos (60) = 1 / 2

tan (30) = √3 / 3
tan (45) = 1
tan (60) = √3


O valor exato de cos(60) é 1 / 2.
O resultado pode ser mostrado de várias formas.

Forma exata:
1 / 2
Forma decimal:
0.5

A Fórmula para Calcular o Cosseno de 60 é dada por: cosseno(60) = cos (60°) = 0,5. 
Para calcular o cosseno de 60, basta substituir os valores na fórmula e obter a resposta desejada. 
Por exemplo: cosseno(60) = cos (60°) = 0,5. 
Portanto, o cosseno de 60 é igual a 0,5.

A trigonometria estabelece relações entre as medidas de ângulos e segmentos. Para tais cálculos, utilizamos as razões trigonométricas que fornecem os valores do seno, cosseno e tangente de ângulos agudos. As razões mais conhecidas e utilizadas são as de 30º, 45º e 60º, mas as tabelas trigonométricas apresentam todas as razões envolvendo os ângulos agudos (< 90º).
Em algumas situações envolvendo cálculos de distâncias por meio da medida de ângulos, existe a necessidade de utilizarmos razões de ângulos obtusos (> 90º). Nesses casos, utilizamos fórmulas que relacionam os ângulos obtusos com os ângulos agudos. Observe:

sen x = sen (180º – x)
O seno de um ângulo obtuso é igual ao seno do suplemento desse ângulo.

cos x = – cos (180º – x)
O cosseno de um ângulo obtuso é o oposto do cosseno do suplemento desse ângulo.


Exemplo 1

O ângulo de 150º é obtuso, pois o valor de sua medida é maior que 90º. Vamos determinar o seno e o cosseno desse ângulo.
sen 150º = sen (180º – x)
sen 150º = sen (180º – 150º)
sen 150º = sen 30º
sen 30º = 1/2

Então:

sen 150º = 1/2

cos 150º = –cos (180º – x)
cos 150º = –cos (180º – 150)
cos 150º = –cos 30º
–cos 30º = –√3/2

Assim:

cos 150º = –√3/2"


Exemplo 2

Determine o seno e o cosseno de 120º

sen 120º = sen (180º – 120º)
sen 120º = sen 60º
sen 60º = √3/2
então:

sen 120º = √3/2

cos 120º = –cos (180º – 120º)
cos 120º = –cos 60º
–cos 60º = – 1/2
então:

cos 120º = –1/2

-------------------------------------------------- ###
MATH.LOG()

Serve para achar o logaritmo de b na base a:

módulo : math
função : log(b, a)

Exemplo:

Log(2)8   <=>   2 elevado a x = 8    (log de 8 na base 2)

import math

x = math.log(8, 2)

print(x)

>>> 3.0

2 elevado a 3 é igual a 8

¨¨¨¨
Log(6)36   <=>   6 elevado a x = 36    (log de 36 na base 6)

import math

x = math.log(36, 6)

print(x)

>>> 2.0

6 elevado a 2 é igual a 36

-------------------------------------- %%%

Logaritmo:
Considere dois números reais positivos a e b, com a ≠ 0. O logaritmo de b na base a é o número x se, e somente se, a elevado a x for igual ao número b.

Pode ser expresso de duas formas:
log(a)b = x  
a elevado a x = b

Sendo:
a → base
b → logaritmando
x → logaritmo

Exemplos:

log(6)36 = 2, pois 6 elevado a 2 = 36
log(2)16 = 4, pois 2 elevado a 4 = 16
log(1/5)5= -1, pois (1/5) elevado a -1 = 5

Quando um logaritmo possui a base igual a 10, esse é chamado logaritmo decimal. Ao registrar-se um logaritmo decimal, não é necessário escrever a base 10. É convencionado que:

log(10)b = log b

Exemplo 1:
Achar Log 1000:
Log 1000 é a mesma coisa que Log(10)1000 pois é um logaritmo decimal.
Para calcular esse logaritmo, devemos encontrar um número que, elevado a 10, seja igual a 1000, isto é, 10 elevado a x = 1000. 

10 elevado a x = 1000
10 elevado a x = 10 elevado a 3  (cortam-se os dois 10)
x = 3

Portanto log 1000 = 3

Exemplo 2:
Achar log(√7)1/49:
Devemos encontrar um número que, elevado à raiz de 7, seja igual a um quarenta e nove avos. Resolvendo a equação, temos:

√7 elevado a x = 1/49
7 elevado a x/2 = 1/7 elevado a 2
7 elevado a x/2 = 7 elevado a -2
x/2 = -2
x = -4

----------------------------------------------------------- ###
MATH.PI

Para achar pi

módulo : math
função : pi

Exemplo:

import math
x = math.pi
print(x)
>>> 3.141592653589793

------------------------------------------------------------ ###
MATH.E

Serve para achar o valor de e
(constante matemática)

módulo : math
função : e

Exemplo:

import math
x = math.e
print(x)
>>> 2.718281828459045

e (constante matemática):
O número e é uma constante matemática que é a base dos logaritmos naturais. 
Por vezes é chamado número de Euler (não confundir com a constante de Euler) em homenagem ao matemático suíço Leonhard Euler, número de Napier, em homenagem a John Napier, número de Neper, constante de Néper, número neperiano, número exponencial e outros. 

O valor é aproximadamente 2,718281828459045235360287.

//////////////////////////////////////////////////////////////////////// &&&
RANDOM()

Módulo random:
Serve como gerador de números pseudoaleatórios para várias distribuições

-------------------------------------- ###
RANDOM.RANDOM()

Exemplo para gerar número de ponto flutuante entre 0 e 1:
(Gera um número aleatório decimal entre 0 e 1. )

Módulo: random
Função: random()

Exemplo:

import random
x = random.random()
print(x)
>>> 0.40724090632196697

¨¨¨¨
import random
x = random.random()
print(x)
>>> 0.061517312640352984

¨¨¨¨
import random
x = random.random()
print(x)
>>> 0.9830849063862589

------------------------------------- ###
RANDOM.SEED()

Para gerar um número aleatório que sempre se repetirá.
(usado para inicializar um gerador de números aleatórios)

import random

x = random.seed(10)
print(random.random())

x = random.seed(10)
print(random.random())

>>> 0.5714025946899135
>>> 0.5714025946899135

The seed() method is used to initialize the random number generator.
Note: If you use the same seed value twice you will get the same random number twice. 

------------------------------------- ###
RANDOM.UNIFORM()

Para gerar um número de ponto flutuante N tal que a ≤ N ≤ b:
(Gerar um número aleatório inteiro ou decimal entre a e b)

Módulo: random
Função: uniform(a, b)

Exemplo:

import random
x = random.uniform(0, 7)
print(x)
>>> 3.8522291329516785

¨¨¨¨
Se quiser números inteiros apenas:

import random
x = int(random.uniform(0, 7))
print(x)
>>> 5

--------------------------------------- ###
RANDOM.GAUSS()

Para gerar um número com distribuição gaussiana
(Gerar um número aleatório inteiro ou decimal utilizando média e desvio padrão)

Módulo: random
Função: gauss(mu, sigma)
ou
Função: normalvariate(mu, sigma)

mu é a média e sigma é o desvio padrão.

Gera um número aleatório inteiro ou decimal usando mu (média) e sigma (desvio padrão).

Exemplo:

import random
x = random.gauss(3, 7)
print(x)
>>> 5.672865288831519

¨¨¨¨
import random
x = random.normalvariate(3, 7)
print(x)
>>> -2.922838700766702

¨¨¨¨
Se quiser usar números inteiros apenas:

import random
x = int(random.gauss(3, 7))
print(x)
>>> 12

------------------------------------ ###
RANDOM.RANDRANGE()

Serve para gerar um elemento selecionado aleatório de range(start, stop, step), mas sem construir um objeto range
(Gerar um número inteiro aleatório baseado nos números de um range)

Módulo: random
Função: randrange(stop)

Exemplo:

import random
x = random.randrange(6)
print(x)
>>> 3

Nesse caso ele gerou um número inteiro aleatório baseado em range(6), que poderiam ser os números 0, 1, 2, 3, 4 e 5.

É possível especificar o inicio, fim e intervalo da range, utilizando randrange(start, stop, step)
Exemplo:

import random
x = random.randrange(0, 11, 2)
print(x)
>>> 6

Nesse caso ele gerou um número inteiro aleatório baseado no range(0, 11, 2), em que começa no 0, termina no 11 e conta de 2 em 2. 
Lembrando que o último número de uma range não é contado.
Então os números que poderiam ser selecionados são 0, 2, 4, 6 , 8 e 10.

-------------------------------------- ###
RANDOM.RANDINT()

Serve para gerar um número inteiro aleatório entre a e b
(Só pode ser selecionado um número inteiro)

Número inteiro N tal que a ≤ N ≤ b
Gera um número inteiro aleatório entre a e b.

Módulo: random
Função: randint(a, b)

Exemplo:

import random
x = random.randint(0, 10)
print(x)
>>> 7

Foi escolhido um número inteiro entre 0 e 10.
Então poderiam ter sido os números 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 e 10.

Exemplo:

import random

x = random.randint(0, 10)

if (x <= 5):
  print(f"{x} é menor ou igual a 5")
else:
  print(f"{x} é maior que 5")

>>> 6 é maior que 5
>>> 2 é menor ou igual a 5
>>> 8 é maior que 5
etc...

É possível usar com dicionários também:

import random
paises = {1: ["brasil"], 2:["eua"], 3:["argentina"]}
x = paises[random.randint(1,3)]
print(x)
>>> ["eua"]

import random
paises = {1: ["brasil", "uruguai"], 2:["eua", "canada"], 3:["japao","china"]}
x = paises[random.randint(1,3)]
print(x)
>>> ['japao', 'china']

------------------------------------ ###
RANDOM.CHOICE()

Para gerar um elemento aleatório de uma sequência não vazia seq.?
(Escolher um item aleatório de uma lista ou range)

Módulo: random
Função: choice(seq)

Elemento aleatório de uma sequência não vazia seq.
Escolher um item aleatório de uma lista, range ou dicionário.

Exemplos:

import random
lista = [4, 8, 15, 16, 23, 42]
x = random.choice(lista)
print(x)
>>> 16
Escolheu um dos itens da lista x.

import random
lista = range(9)
x = random.choice(lista)
print(x)
>>> 8
Escolheu um dos itens da range(9)

É possível simplicar mais o código:

import random
lista = [4, 8, 15, 16, 23, 42]
print(random.choice(lista))
>>> 23

Para somar itens de mais de uma lista:

import random
lista1 = [4, 8, 15, 16, 23, 42]
lista2 = [5, 10, 15, 20, 25]
x = random.choice(lista1)
y = random.choice(lista2)
soma = x + y
print(f"A soma de {x} com {y} é igual a {soma}.")
>>> A soma de 4 com 15 é igual a 19.
>>> A soma de 16 com 10 é igual a 26.
etc...

ou dá para simplicar o código:

import random
lista1 = [4, 8, 15, 16, 23, 42]
lista2 = [5, 10, 15, 20, 25]
x = random.choice(lista1)
y = random.choice(lista2)
print(f"A soma de {x} com {y} é igual a {x + y}.")
>>> A soma de 16 com 25 é igual a 41.
etc...


import random
lista = ["A" , "B" , "C" , "D" , "E"]
x = random.choice(lista) + " e " + random.choice(lista)
print(x)
>>> C e A

------------------------------------- ###
RANDOM.SHUFFLE()

Serve para embaralhar a sequência x no lugar

Módulo: random
Função: shuffle(x)

Exemplos:

import random
lista = [1, 2, 3, 4, 5, 6]
random.shuffle(lista)
print(lista)
>>> [4, 1, 3, 5, 2, 6]

¨¨¨¨
import random
mylist = ["apple", "banana", "cherry"]
random.shuffle(mylist)
print(mylist)
>>> ['cherry', 'apple', 'banana']

-------------------------------------- ###
RANDOM.SAMPLE()

Módulo: random
Função: sample(lst, x)

Escolhe uma quantidade de itens (x) dentro de uma lista (lst).
(Para gerar uma sequência de tamanho k de elementos escolhidos da população pop, sem repetição)
Usada para amostragem sem substituição.

Exemplos:

import random
lista = [4, 62, 7, 12, 15, 22]
random.sample(lista, 4)
>>> [7, 12, 4, 22]        #Escolheu 4 itens da lista.

import random
lista = [4, 62, 7, 12, 15, 22]
x = random.sample(lista, 3)
print(f"Os três números escolhidos foram {x}.")
>>> Os três números escolhidos foram [12, 4, 7].

import random
lista = ["bola", "carro", "boneco", "brinquedo"]
x = random.sample(lista, 2)
print(f"As duas palavras escolhidas foram {x}.")
>>> As duas palavras escolhidas foram ['carro', 'brinquedo'].

----------------------------------- ###

O módulo MATH pode ser para:

Números inteiros:
Para inteiros, existe:
- Uma seleção uniforme a partir de um intervalo.

Sequências
Para sequências, existem:
- Uma seleção uniforme de um elemento aleatório; 
- Uma função para gerar uma permutação aleatória das posições na lista; 
- Uma função para escolher aleatoriamente sem substituição.

Distribuições de valores reais
A lista a seguir mostra algumas das principais funções disponíveis para distribuições de valores reais no módulo random:

random( ) = Número de ponto flutuante no intervalo (00,0, 1,0)
uniform(a, b) = Número de ponto flutuante N tal que a ≤ N ≤ b
gauss(mu, sigma) = Distribuição gaussiana. mu é a média e sigma é o desvio padrão.
normalvariate(mu, sigma) = Distribuição gaussiana. mu é a média e sigma é o desvio padrão.

Funções para números inteiros
Veja algumas das principais funções disponíveis para inteiros no módulo random:
randrange(stop) = Um elemento selecionado aleatório de range(start, stop, step), mas sem construir um objeto range.
randrange(start, stop, [step]) = ????
randint(a, b) = Número inteiro N tal que a ≤ N ≤ b

Funções para sequências
Esta tabela mostra algumas das principais funções disponíveis para sequências no módulo random:
choice(seq) = Elemento aleatório de uma sequência não vazia seq.
shuffle(x[, random]) = Embaralha a sequência x no lugar.
sample(pop, k) = Uma sequência de tamanho k de elementos escolhidos da população pop, sem repetição. Usada para amostragem sem substituição.

/////////////////////////////////////////////////////////////////////// &&&
SMTPLIB

Esse módulo define um objeto de sessão do cliente SMTP que pode ser usado a fim de enviar e-mail para qualquer máquina da internet com um serviço de processamento SMTP ou ESMTP. 

O exemplo a seguir vai permitir que você envie um e-mail a partir do servidor SMTP do Gmail.

Como a Google não permite, por padrão, realizar o login com a utilização do smtplib por considerar esse tipo de conexão mais arriscada, será necessário alterar uma configuração de segurança. Para resolver isso, siga estas instruções:
1 - Acesse sua conta no Google.
2 - Depois acesse Segurança.
3 - Acesso a app menos seguro.
Atenção! Em algumas contas, os nomes estarão escritos no idioma inglês (Allow less secure apps).
4 - Mude para "ativada" a opção de "Permitir aplicativos menos seguros".

Para fazer seu primeiro envio, crie um programa no seu projeto. O codigo a seguir mostra as importações necessárias para o envio:

#import dos pacotes necessários
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import smtplib 

O código seguinte mostra a criação da mensagem com o corpo e seus parâmetros:

#criação de um objeto de mensagem
msg = MIMEMultipart()
texto = "Estou enviando um email com Python"

#parâmetros
senha = "SUA SENHA"
msg['From'] = "SEU E-MAIL"
msg['To'] = "E-MAIL DESTINO"
msg['Subject'] = "ASSUNTO"

#criação do corpo da mensagem
msg.attach(MIMEText(texto, 'plain'))

A linha [msg = MIMEMultipart()] mostra a criação de um objeto de mensagem.
A linha [texto = "Estou enviando um email com Python"] exibe o corpo da mensagem em uma string.
As linhas de [senha = "SUA SENHA"] a [msg['Subject'] = "ASSUNTO"] devem ser preenchidas com os valores adequados para que seu programa seja executado com sucesso.
A linha [msg.attach(MIMEText(texto, 'plain'))] anexa o corpo da mensagem (que estava em uma string) ao objeto msg.

O próximo código mostra os passos necessários para o próprio envio:

#criação do servidor
server = smtplib.SMTP('smtp.gmail.com: 587')
server.starttls()

#Login na conta para envio
server.login(msg['From'], senha)

#envio da mensagem
server.sendmail(msg['From'], msg['To'], msg.as_string())

#encerramento do servidor
server.quit()

print('Mensagem enviada com sucesso')

As duas primeiras linhas mostram a criação do servidor e a sua conexão no modo TLS.
A linha [server.login(msg['From'], senha)] mostra o login na conta de origem do e-mail.
A linha [server.sendmail(msg['From'], msg['To'], msg.as_string())] representa o envio propriamente dito.
A linha [server.quit()] exibe o encerramento do servidor.

//////////////////////////////////////////////////////////////////////////// &&&
DATETIME

Para importar data e horario atual no Python
(dia / mes / ano / hora / minuto / segundo / dia da semana)

Dia, mês e ano:

from datetime import date

dia = date.today().day
mes = date.today().month
ano = date.today().year

print(f"{dia} / {mes} / {ano}")

>>> 13 / 10 / 2023

---------------------------------------
Dia da semana:

import datetime

semana = datetime.datetime.today()
print(semana.strftime("%a")) 

>>> Fri
------------------------------------------
Mês:

import datetime

mes = datetime.datetime.today()
print(mes.strftime("%b")) 

>>> Oct
-------------------------------------------
Data completa:

import datetime

data = datetime.datetime.today()
print(data.strftime("%c")) 

>>> Fri Oct 13 18:23:10 2023
-------------------------------------------
Dia:

import datetime

dia = datetime.datetime.today()
print(dia.strftime("%d")) 

>>> 13
--------------------------------------------
AM ou PM:

import datetime

ampm = datetime.datetime.today()
print(ampm.strftime("%p")) 

>>> PM
---------------------------------------------
Mes + Dia + Ano:

import datetime

data = datetime.datetime.today()
print(data.strftime("%x")) 

>>> 10/13/23
--------------------------------------------
Ano-Mês-Dia Hora:Minuto:Segundo

import datetime

data = datetime.datetime.today()

print(data)

>>> 2023-10-14 00:55:54.810730

/////////////////////////////////////////////////////////////////////////// &&&
TIME

Módulo para lidar com tempo (hora, data, etc.)

---------------------------------------------- ###
TIME.TIME()

Permite gerar o número de segundos passados desde o início da contagem (epoch)
(quantidade de segundos passados desde 1970)

Módulo = time
Função = time(x)

Número de segundos passados desde o início da contagem (epoch). 
Por padrão, a variável x recebe o número de segundos desde 00:00:00 do dia 1 de janeiro de 1970.

Exemplo:

import time
x = time.time()
print(x)
>>> 1693691102.4221542
Esse foi o número de segundos passados desde 00:00:00 do dia 1 de janeiro de 1970.

Para saber a data e hora atual (baseado no Meridiano de Greenwich), é preciso utilizar em conjunto com a função ctime(). Exemplo:

import time
x = time.time()
print(time.ctime(x))
>>> Sat Sep 2 21:48:02 2023

import time
x = time.time()
print(f'Data: {time.ctime(x)}')
>>>  Data: Sat Sep 2 21:38:45 2023

---------------------------------------------------------- ###
TIME.CTIME()

Permite gerar uma string representando o horário local, calculado a partir do número de segundos passado como parâmetro
(data e tempo passados desde 1970)

Módulo = time
Função = ctime(x)

Uma string representando o horário local, calculado a partir do número de segundos passado como parâmetro.
Conta o número de segundos de x e vê quanto tempo se passou desde 00:00:00 do dia 1 de janeiro de 1970.

import time
x = time.ctime(60)
print(x)
>>> Thu Jan 1 00:01:00 1970
Quer dizer que passaram 60 segundos (1 minuto) desde 00:00:00 do dia 1 de janeiro de 1970.

import time
x = time.ctime(1000)
print(x)
>>> Thu Jan 1 00:16:40 1970
Quer dizer que passaram 1000 segundos (16 minutos e 40 segundos) desde 00:00:00 do dia 1 de janeiro de 1970.

Para saber a data e hora atual (baseado no Meridiano de Greenwich), é preciso utilizar em conjunto com a função time(). Exemplo:

import time
x = time.time()
print(time.ctime(x))
>>> Sat Sep 2 21:48:02 2023

import time
x = time.time()
print(f'Data: {time.ctime(x)}')
>>>  Data: Sat Sep 2 21:38:45 2023

-------------------------------------------------------------------- ###
TIME.GTIME()

Permite converter o número de segundos em um objeto struct_time
(Mostra a data atual em uma struct_time)

Módulo = time
Função = gmtime( )

Converte o número de segundos em um objeto struct_time.

Exemplo: 

import time
x = time.gmtime( )
print(x)
>>> time.struct_time(tm_year=2023, tm_mon=9, tm_mday=2, tm_hour=22, tm_min=3, tm_sec=54, tm_wday=5, tm_yday=245, tm_isdst=0)

Caso seja informado algum parâmetro de segundos dentro dos parênteses, o resultado será baseado em 00:00:00 do dia 1 de janeiro de 1970.

import time
x = time.gmtime(40)
print(x)
>>> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=40, tm_wday=3, tm_yday=1, tm_isdst=0)

-------------------------------------------------------------------- ###
TIME.LOCALTIME()

Permite converter para o horário local
(Mostra a data atual em uma struct_time, convertendo para o horário local)

Módulo = time
Função = localtime(segundos)

Semelhante à gmtime(), mas converte para o horário local.

Exemplo: 

import time
x = time.localtime( )
print(x)
>>> time.struct_time(tm_year=2023, tm_mon=9, tm_mday=2, tm_hour=22, tm_min=9, tm_sec=33, tm_wday=5, tm_yday=245, tm_isdst=0)

Caso seja informado algum parâmetro de segundos dentro dos parênteses, o resultado será baseado em 00:00:00 do dia 1 de janeiro de 1970.

import time
x = time.localtime(40)
print(x)
>>> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=40, tm_wday=3, tm_yday=1, tm_isdst=0)

-------------------------------------------------------------------- ###
TIME.SLEEP()

Permite suspender a execução por determinado número de segundos
(contador de tempo)

Módulo = time
Função = sleep(x)

A função suspende a execução por determinado número de segundos (x).

Exemplo: 

import time
for x in range(1,6):
    print(x)
    time.sleep(1)
print("Acabou")
>>> 1     #espera 1 segundo
>>> 2     #espera 1 segundo
>>> 3     #espera 1 segundo
>>> 4     #espera 1 segundo
>>> 5     #espera 1 segundo
>>> Acabou

Dá para utilizar outra forma de importar o sleep:

from time import sleep
for x in range(1,6):
   print(x)
   sleep(1)
print("Acabou")
>>> 1     #espera 1 segundo
>>> 2     #espera 1 segundo
>>> 3     #espera 1 segundo
>>> 4     #espera 1 segundo
>>> 5     #espera 1 segundo
>>> Acabou


Caso queira aumentar ou diminuir o tempo de espera:
sleep(0.5) = meio segundo
sleep(1) = 1 segundo
sleep(2) = 2 segundos
sleep(5) = 5 segundos
sleep(30) = 30 segundos


Para fazer uma contagem regressiva de 10 a zero, com uma pausa de 1 segundo entre eles:

import time 
for x in range(10,-1,-1):
   print(x)
   time.sleep(1)

>>> 10  (espera 1 segundo)
>>> 9   (espera 1 segundo)
>>> 8   (espera 1 segundo)
>>> 7   (espera 1 segundo)
>>> 6   (espera 1 segundo)
>>> 5   (espera 1 segundo)
>>> 4   (espera 1 segundo)
>>> 3   (espera 1 segundo)
>>> 2   (espera 1 segundo)
>>> 1   (espera 1 segundo)
>>> 0   (espera 1 segundo)

Caso quisesse de 2 em 2 ficaria:
for x in range(10,-1,-2):
  print(x)

/////////////////////////////////////////////////////////////////////////// &&&
TKINTER

O pacote tkinter é a interface Python padrão para o Tk GUI (interface gráfica com o usuário) toolkit. Na maioria dos casos, basta importar o próprio tkinter, mas diversos outros módulos estão disponíveis no pacote. A biblioteca tkinter permite a criação de janelas com elementos gráficos, como a entrada de dados e botões, por exemplo.

----------------------------------------------------- ###
CABEÇALHO

O exemplo a seguir vai permitir que você crie a primeira janela com alguns elementos. Para isso, crie um programa novo no seu projeto. O código adiante mostra a criação da sua primeira janela, ainda sem qualquer elemento gráfico.

Para criar o "cabeçalho" no módulo tkinter:

from tkinter import *

janelaPrincipal = Tk()
janelaPrincipal.mainloop()

A linha 1 mostra a importação de todos os elementos disponíveis em tkinter. O objeto janelaPrincipal é do tipo Tk. Um objeto Tk é um elemento que representa a janela GUI. Para que essa janela apareça, é necessário chamar o método mainloop();

-------------------------------------------------- ###
JANELA

Para exibir textos, vamos usar o elemento Label. O próximo código mostra as linhas 4 e 5, com a criação do elemento e o seu posicionamento. O tamanho padrão da janela é 200 X 200 pixels, com o canto superior esquerdo de coordenadas (0,0) e o inferior direito de coordenadas (200,200).

Para criar uma janela:

from tkinter import *

janelaPrincipal = Tk()
texto = Label(master = janelaPrincipal, text = "Minha janela exibida")
texto.place(x = 50 y = 100)
janelaPrincipal.mainloop()

A linha 1 mostra a importação de todos os elementos disponíveis em tkinter. O objeto janelaPrincipal é do tipo Tk. Um objeto Tk é um elemento que representa a janela GUI. Para que essa janela apareça, é necessário chamar o método mainloop();

--------------------------- %%%
Para modificar o tamanho de uma janela de interface no módulo tkinter:

J.geometry(".... x ....")

Sendo:
J = nome de identificação da janela de interface que está sendo criada


Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")
janela.geometry("400x400")

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 10 , pady = 10)

botao = Button( janela, text="Aperte aqui.", command = função )
botao.grid(column = 0 , row = 1 , padx = 10 , pady = 10)

texto_funcao = Label(janela, text=" ")
texto_funcao.grid(column = 0 , row = 2 , padx = 10 , pady = 10)

janela.mainloop()

--------------------------------------------------------- ###
TITULO

Para adicionar um título à uma janela de interface no módulo tkinter:

J.title("Nome da janela")

J = nome de identificação da janela de interface que está sendo criada

Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")

janela.mainloop()

-------------------------------------------------------- ###
TEXTO

Para adicionar um texto à uma janela de interface no módulo tkinter
(sem especificar a posição)

frase1 = Label(janela, text="Aperte o botão abaixo.")

Estrutura:
T = Label( J , text="........") 

T = nome de identificação deste texto
J = nome de identificação da janela de interface que está sendo criada


Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")

frase1 = Label(janela, text="Aperte o botão abaixo.")

janela.mainloop()


Obs: O nome "janela" pode ser modificado para o que você quiser.

-------------

Para adicionar um texto à uma janela de interface no módulo tkinter:
(especificando a posição)

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

Estrutura:
T = Label( J , text="........") 
T.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

T = nome de identificação deste texto
J = nome de identificação da janela de interface que está sendo criada

Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

janela.mainloop()

-------------------------------------------------------- ###
BOTÃO

Para adicionar um botão à uma janela de interface no módulo tkinter:
(especificando a posição)

botao = Button( janela, text="Aperte aqui.", command = função )
botao.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

Estrutura:

B = Button( J , text="........", command = F )
B.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

B = nome de identificação deste botão
J = nome de identificação da janela de interface que está sendo criada
F = Nome da função a ser declarada no código

Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 10 , pady = 10)

botao = Button( janela, text="Aperte aqui.", command = função )
botao.grid(column = 0 , row = 1 , padx = 10 , pady = 10)

janela.mainloop()

-----------------------------
Para adicionar um botão à uma janela de interface no módulo tkinter:
(sem especificar a posição)

botao = Button( janela, text="Aperte aqui.", command = função )

Estrutura:

B = Button( J , text="........", command = F )

B = nome de identificação deste botão
J = nome de identificação da janela de interface que está sendo criada
F = Nome da função a ser declarada no código

Exemplo: 

from tkinter import *

janela = Tk()
janela.title("Nome")

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 10 , pady = 10)

botao = Button( janela, text="Aperte aqui.", command = função )
botao.grid(column = 0 , row = 1 , padx = 10 , pady = 10)

janela.mainloop()

-------------------------------------------------------- ###
IMAGEM E BOTÃO

Vamos agora incrementar um pouco essa janela. Para isso, acrescentaremos uma imagem e um botão. A imagem precisa estar na mesma pasta do seu arquivo .py.

Para adicionar imagem e botão:

from tkinter import *

def funcClicar():
    print("Botão pressionado")

janelaPrincipal = Tk()
texto = Label(master = janelaPrincipal, text = "Minha janela exibida")
texto.pack()

pic = PhotoImage(file="logoEstacio.gif")
logo = Label(master = janelaPrincipal, image = pic)
logo.pack()

botao = Button(master = janelaPrincipal, text = 'Clique', command = funcClicar)
botao.pack()

janelaPrincipal.mainloop()

No código anterior, há a inserção do elemento de imagem e o botão. Nas linhas 10, 11 e 12, é feita a criação do objeto Label para conter a imagem e seu posicionamento. Observe que passamos a utilizar o método pack(), que coloca o elemento centralizado e posicionado o mais perto possível do topo, depois dos elementos posicionados anteriormente.

O elemento botão é criado na linha 14 com os atributos text e command, os quais são respectivamente o texto exibido no corpo do botão e a função a ser executada quando o botão é clicado.

Para o funcionamento correto do botão, é preciso definir a função funcClicar(), nas linhas 3 e 4. Essa função serve apenas para imprimir na tela a string “Botão pressionado”.

--------------------------------------------------------- ###
RESULTADO DE UMA FUNÇÃO

Para fazer aparecer o resultado de uma função em uma janela de interface no módulo tkinter:
(Após clicar em um botão)

def função( ):
    .....
    .....
    F["text"]

F = Label(janela, text=" ")
F.grid(column = 0 , row = 0 , padx = 0 , pady = 0)

Sendo:
F = nome de identificação da função no tkinter


Exemplo: 

from tkinter import *

def função( ):
    .....
    .....
    texto_funcao["text"]

janela = Tk()
janela.title("Nome")

frase1 = Label(janela, text="Aperte o botão abaixo.")
frase1.grid(column = 0 , row = 0 , padx = 10 , pady = 10)

botao = Button( janela, text="Aperte aqui.", command = função )
botao.grid(column = 0 , row = 1 , padx = 10 , pady = 10)

texto_funcao = Label(janela, text=" ")
texto_funcao.grid(column = 0 , row = 2 , padx = 10 , pady = 10)

janela.mainloop()

---------------------------------------------------- ###
PACK

É um método para colocar o elemento centralizado e posicionado o mais perto possível do topo, depois dos elementos posicionados anteriormente

pack( )

Exemplo de método pack():

from tkinter import *

janela = Tk()
janela.title("Nome")
janela.geometry("400x400")

frase1 = Label(janela, text="Texto.")
frase1.pack()

janela.mainloop()

É possível usar os parâmetros side e expand:
frase1.pack(side=TOP,expand=TRUE)

Porém é preferível usar o método grid ao invés de pack.

Exemplo de método grid():

from tkinter import *

janela = Tk()
janela.title("Nome")
janela.geometry("400x400")

frase1 = Label(janela, text="Texto.")
frase1.grid(column=0, row=0, padx=10, pady=10)

janela.mainloop()

/////////////////////////////////////////////////////////////////////////////// &&&
PACOTES

A característica open-source do Python permite que qualquer desenvolvedor, com o conhecimento adequado, desenvolva a própria biblioteca e os próprios módulos, os quais chamaremos, a partir de agora, de pacotes.

Como forma de facilitar a distribuição dos pacotes entre os usuários, existe um grupo dentro da comunidade Python que mantém o chamado Python package index, ou PyPI, um grande servidor no qual os desenvolvedores podem hospedar os seus pacotes, contendo bibliotecas e/ou módulos, para que sejam baixados e instalados por outras pessoas.

É possível acessar o PyPI por meio do pip, um programa que pode ser instalado com a distribuição do Python. Para isso, certifique-se de que a caixa “pip” está marcada durante a instalação.

Atenção!
Para verificar se a sua instalação Python incluiu o pip, procure pela pasta Scripts dentro do diretório de instalação que você escolheu para o Python. Dentro dessa pasta, localize o arquivo pip.exe. Caso não o encontre, pesquise sobre como instalar o pip. O mais recomendado é tentar reinstalar o Python sem esquecer de marcar a opção de incluir o pip durante o processo de instalação.

Além do pip, é necessário ter em mãos o endereço para acessar o pip dentro da variável de ambiente PATH. O processo de instalação do Python também permite incluir automaticamente o Python no seu PATH, porém, caso não tenha feito isso, siga os passos abaixo:

1- Clique na tecla do Windows e escreva “Editar as variáveis de ambiente para a sua conta”.
2- Na janela que abrir, procure pela variável Path, selecione-a e clique no botão “Editar”.
3- Clique no botão “Novo” e digite o endereço da sua instalação do Python (por exemplo, D:\Python).
4- Clique no botão “Novo” uma segunda vez e digite o endereço da pasta Scripts dentro da sua instalação do Python (por exemplo, D:\Python\Scripts).
5- Aperte Ok até fechar todas as janelas.

É importante que você se certifique de que a opção Add Python to PATH está marcada durante a instalação.

---------------------

Em Python, quando estiver trabalhando com pacotes externos, é extremamente recomendado o uso de Ambientes virtuais (em inglês, virtual environments ou simplesmente virtualenvs ).

Esses ambientes isolam o projeto em que você está trabalhando.

Uma das vantagens disso é que você consegue saber exatamente quais pacotes externos estão sendo usados no projeto. É possível usar esses pacotes sem o uso de ambientes virtuais, porém isso pode causar uma confusão caso você tenha vários projetos Python no seu computador.

Pesquise mais sobre ambientes virtuais e configure um em cada projeto. Não é muito difícil - e vai ajudá-lo a deixar o seu código mais profissional!

------------------------

Em Python, os desenvolvedores podem criar os próprios módulos de forma a reutilizar as funções que já escreveram e organizar melhor seu trabalho. Para isso, basta criar um arquivo .py e escrever nele suas funções.

O arquivo do módulo precisa estar na mesma pasta do arquivo para onde ele será importado.

------------------------

Em Python, quais são os pacotes externos mais comuns e utilizados no mercado são:

numpy = Cálculos, operações matemáticas e simulações
pandas = Manipulaçao de dados
scikit-learn = Modelos de aprendizado de máquina
matplotlib = Visualização de dados
requests = Biblioteca de comandos de comunicação pelo protocolo HTTP
flask = Construção de aplicações web

///////////////////////////////////////////////////////////////////////////////////// &&&
NUMPY

Este pacote serve para cálculos, operações matemáticas e simulações

Exemplos:

import numpy as np
np.sqrt(4)
>>> 2.0

A função sqrt é usada para achar a raiz quadrada. Então o módulo numpy pode ser usado ao invés do módulo math.

import math
x = math.sqrt(4)
print(x)
>>> 2.0

ou 

import math
print(math.sqrt(4))
>>> 2.0

-----------

import numpy as np
np.sqrt(36)
>>> 6.0

ou

import numpy as np
int(np.sqrt(36))
>>> 6

Caso queira usar o módulo math:

import math
x = math.sqrt(36)
print(x)
>>> 6.0

ou 

import math
print(math.sqrt(36))
>>> 6.0

---------------------------------------- ###

cCmo criar uma função para visualizar os dados de vendas de produtos em um gráfico de barras?

Por exemplo, utilize os seguintes dados:
x = ["A","B","C","D"]
y = [3, 8, 1, 10]

import matplotlib.pyplot as plt
import numpy as np

x = np.array(["A","B","C","D"])
y = np.array([3, 8, 1, 10])
plt.bar(x,y)
plt.show()

¨¨¨¨
outra solução:

import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
x = ["A","B","C","D"]
y = [3, 8, 1, 10]
ax.bar(x,y)
plt.show()

///////////////////////////////////////////////////////////////////////////////////// &&&
PANDAS

Este pacote serve para manipulaçao de dados.

////////////////////////////////////////////////////////////////////////////////////// &&&
scikit-learn

Este pacote serve para modelos de aprendizado de máquina

////////////////////////////////////////////////////////////////////////////////////// &&&
MATPLOTLIB

Este pacote serve para visualização de dados

-------------------------------------- ###
HISTOGRAMA

Exemplo:

import matplotlib.pyplot as plt

idades=[65,26,67,50,47,73,1,58,2,94,12,22,12,95,25,13]

plt.title('Titulo do histograma')
plt.xlabel('Nome do eixo x')
plt.ylabel('Nome do eixo y')
plt.hist(idades, 5, rwidth=0.9)
plt.show()

---------------------- %%%
Mudando a cor e contorno das barras:

plt.hist( lista , 5 , rwidth=0.9, color="lightblue", ec="red")

Sendo:
color = cor da barra
ec = contorno da barra

Exemplo:

import matplotlib.pyplot as plt

idades=[65,26,67,50,47,73,1,58,2,94,12,22,12,95,25,13]

plt.title('Idades de um grupo')
plt.xlabel('Idade')
plt.ylabel('Frequência Absoluta')
plt.hist(idades, 5,  rwidth=0.9, color="lightblue", ec="red")
plt.show()

---------------------- %%%

Exemplo de histograma:

import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
x = ["A","B","C","D"]
y = [3, 8, 1, 10]
ax.bar(x,y)
plt.show()

>>> O resultado mostra um gráfico de barras com eixo e e y mostrando os valores A3, B8, C1 e D10

------------------------- %%%

Exemplo de gráfico em linha:

import matplotlib.pyplot as plt

anos = [2005, 2006, 2007, 2008]
idade = [12, 13, 14, 15]

plt.plot(anos, idade, color='blue')

plt.xlabel('Anos')
plt.ylabel('Idade')

plt.show()

-----------------------  %%%

import matplotlib.pyplot as plt

list = [1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10]
 
plt.hist( list , 5 , rwidth=0.9)
plt.show()

Sendo:
list = É o nome da lista contendo os itens dentro dela.
5 = É o número de classes que queremos que nosso histograma tenha. Com isso o histograma terá 5 barras. (Opcional) 
rwidth = É o tamanho relativo das barras. (Opcional) 

Caso queira modificar as cores e contorno da barra:

plt.hist( lista , 5 , rwidth=0.9, color="lightblue", ec="red")

Caso queira adicionar titulo ao histograma:

plt.title('Título do Histograma')

Caso queira adicionar nomes para o eixo x e y:

plt.xlabel('Nome do Eixo X')
plt.ylabel('Nome do Eixo Y')


Então tudo junto ficaria assim:

import matplotlib.pyplot as plt

lista = [1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10]
 
plt.title('Título do Histograma')
plt.hist( lista , 5 , rwidth=0.9, color="lightblue", ec="red")
plt.xlabel('Nome do Eixo X')
plt.ylabel('Nome do Eixo Y')
plt.show()

----------------------------- %%%

Outro exemplo:

import matplotlib.pyplot as plt

idades=[65,26,67,50,47,73,1,58,2,94,12,22,12,95,25,13,61,41,24,95,
3,71,53,24,23,44,83,30,19,32,71,66,45,6,99,4,76,27,50,18,58, 61,53,72,14,78,36,89,6,71,58,69,22,34,38,51,71,83,22,22,36,44, 16,58,20,49,28,55,21,26,23,41,21,95,18,63,55,2,61,81,39,20,39,
17,66,60,73,26,54,16,76,83,9,12,15,35,54,11,7,61]

plt.title('Idades de um grupo')
plt.xlabel('Idade')
plt.ylabel('Frequência Absoluta')
plt.hist(idades, 5, rwidth=0.9)
plt.show()

------------------------------ %%%

Implementar uma solução para gerar 1000 pontos seguindo a distribuição Normal com média 20 e desvio-padrão 2.
Além disso, exiba os dados em um histograma.

import matplotlib.pyplot as plt
import numpy as np

np.random.seed(1)
dados = np.random.normal(loc=20, scale=2, size=1000)
plt.hist(dados)
plt.show()


Obs: Caso não tenha "plt.show()" será mostrado antes do histograma o conjunto de números gerados. Exemplo:
(array([ 10., 37., 103., 223., 286., 224., 90., 24., 1., 2.]), array([13.89247124, 15.29494466, 16.69741807, 18.09989149, 19.50236491, 20.90483832, 22.30731174, 23.70978516, 25.11225857, 26.51473199, 27.91720541]), <BarContainer object of 10 artists>)

/////////////////////////////////////////////////////////////////////////// &&&
REQUESTS

Este pacote externo é uma biblioteca de comandos de comunicação pelo protocolo HTTP

/////////////////////////////////////////////////////////////////////////// &&&
FLASK

Este pacote externo serve para construção de aplicações web

Flask é um micro framework Web em Python.

------------------------------------ ###
GET / POST

Para usar os Métodos HTTP com o Flask
(GET, POST)

Métodos HTTP
Precisamos, para isso, utilizar o parâmetro methods do decorador @app.route(), que espera uma lista de strings com o nome dos métodos aceitos.

As aplicações Web disponibilizam diversos métodos para acessar uma URL: GET, POST, PUT e DELETE. Por padrão, as rotas do Flask somente respondem às requisições GET. 
Para responder a outros métodos, é necessário explicitar, na rota, quais métodos serão aceitos.

Observe no script flask6.py, a seguir, em que criamos a rota para a função logar e passamos como argumento uma lista contendo duas strings, ‘GET’ e ‘POST’ (linha 15). 
@app.route('/logar', methods=['GET', 'POST'])

Isso indica que essa rota deve responder às requisições do tipo GET e POST.

#script flask6.py
from flask import Flask, request

app = Flask(__name__)
app.debug = True

@app.route('/')
def index():
    return "Página principal."

@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome):
    return "Olá, " + nome

@app.route('/logar', methods=['GET', 'POST'])
def logar():
    if request.method == 'POST':
        return "Recebeu post! Fazer login!"
    else:
        return "Recebeu get! Exibir FORM de login."

if __name__ == '__main__':
        app.run()

Para verificar o método que foi utilizado na requisição, usamos o atributo method do objeto request, que retorna uma das strings: GET, POST, PUT ou DELETE.

O objeto request é uma variável global disponibilizada pelo Flask e pode ser utilizada em todas as funções. 
Para cada requisição, um novo objeto request é criado e disponibilizado.

Com o objeto request, temos acesso a muitas outras propriedades da requisição, como: cookie, parâmetros, dados de formulário, mimetype etc.

Neste exemplo, utilizamos o atributo method do objeto request para verificar o método passado na requisição e retornar conteúdos diferentes dependendo do método (linhas 17 a 20):
if request.method == 'POST':
    return "Recebeu post! Fazer login!"
else:
    return "Recebeu get! Exibir FORM de login."

Ao acessar a url http://127.0.0.1:5000/logar , foi apresentado:
Recebeu get! Exibir FORM de login.

Atenção!
Caso seja requisitada uma rota que exista, porém o método não seja aceito pela rota, o erro retornado é o 405 – Method Not Allowed (método não permitido), e não o 404 – Not Found (não encontrado), como ocorre quando a rota não existe.

Observe que ativamos o modo debug do servidor interno do Flask (linha 4):
app.debug = True

Isso nos permite visualizar melhor os avisos e erros durante o desenvolvimento.

---------------------------------------------------- ###
MODELOS

As funções no Flask precisam retornar algo. O retorno das funções pode ser uma string simples e até uma string contendo uma página inteira em HTML. Porém, criar páginas dessa maneira é muito complicado, principalmente devido à necessidade de escapar (scape) o HTML, para evitar problemas de segurança, por exemplo.

Para resolver esse problema, o Flask, por meio da extensão Jinja2, permite utilizar modelos (templates) que são arquivos texto com alguns recursos a mais, inclusive escape automático.

No caso de aplicações Web, os modelos normalmente são páginas HTML, que são pré-processadas antes de retornarem ao requisitante, abrindo um novo leque de possibilidades no desenvolvimento Web.

A cada requisição, podemos alterar uma mesma página de acordo com um contexto (valores de variáveis, por exemplo). Com a utilização de marcadores (tags) especiais, é possível injetar valores de variáveis no corpo do HTML, criar laços (for), condicionantes (if/else), filtros etc.

Para criar e utilizar os modelos, por convenção, os HTMLs precisam ficar dentro da pasta templates, no mesmo nível do arquivo que contém a aplicação Flask.

Para ilustrar, no próximo exemplo (script flask7.py), vamos alterar nossa aplicação de forma que seja retornada uma página HTML ao se acessar a raiz da aplicação (‘/’).

Para isso, criaremos um arquivo chamado indice.html na pasta templates, no mesmo nível do script flask7.py, conforme vemos na árvore de diretório a seguir:



O conteúdo do modelo indice.html está exibido abaixo do script flask7.py.

Para o modelo ser acessado na URL raiz (‘/’), a função index() deve ser a responsável por retorná-lo. Para isso, vamos utilizar a função render_template disponibilizada pelo Flask, que recebe o nome do arquivo que desejamos retornar.

Observe a linha 7 do script flask7.py, em que utilizamos essa função e passamos “indice.html” como parâmetro:
return render_template('indice.html')

O arquivo final então ficará assim:

from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('indice.html')

@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome="mundo"):
    return "Olá, " + nome

if __name__ == '__main__':
    app.run()

Ao acessar http://127.0.0.1:5000, recebemos o resultado a seguir:
Página principal!
Usando Templates

Como dito anteriormente, os modelos são páginas HTML turbinadas, nas quais podemos utilizar delimitadores especiais para alterar nossa página. Os dois tipos de delimitadores são:

- Expressões: {{ ... }}
Serve para escrever algo no modelo, como o valor de uma variável.

- Declarações: {% ... %}
Serve para ser utilizado em laços e condicionantes, por exemplo.

Antes de serem retornadas ao usuário, essas páginas são renderizadas, ou seja, os delimitadores são computados e substituídos.

No próximo exemplo, alteraremos a nossa aplicação de forma que o nome passado como parâmetro para a rota ‘/ola/’ seja exibido dentro do HTML.

Para isso, vamos criar um arquivo chamado ola.html na pasta templates, conforme abaixo no script flask8.py. Observe que utilizamos o delimitador de expressões com a variável ({{nome_recebido}}), indicando que escreveremos o conteúdo dessa variável nesse local após a renderização (linha 4 do arquivo ola.html após o script flask8.py):
<h1>Olá, {{ nome_recebido }}</h1>

#script flask8.py
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('indice.html')

@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome="mundo"):
    return "Olá, ", nome_recebido = nome

if __name__ == '__main__':
    app.run()


#modelo ola.html
<!DOCTYPE html>
<html>
    <body>
        <h1>Olá, {{ nome_recebido }}</h1>
    </body>
</html>

Além de informar a página que queremos renderizar na função render_templates, podemos passar uma ou mais variáveis para essa função. Essas variáveis ficarão disponíveis para serem utilizadas em expressões ({{ }}) e declarações ({% %}) dentro do modelo (template).

No exemplo, desejamos exibir o nome passado via URL na página. Para passar a variável nome para o HTML, precisamos chamar a função render_template com um parâmetro a mais, conforme linha 12 e destacado na imagem a seguir:

Destaque da sintaxe da função render_template do Flask.


A variável nome_recebido estará disponível para ser usada dentro do modelo ola.html. Esse nome pode ser qualquer outro escolhido pelo programador, mas lembre-se de que ele será usado, também, dentro do modelo.

Para finalizar, utilizamos o delimitador de expressões envolvendo o nome da variável (linha 4 do html):
<h1>Olá, {{ nome_recebido }}</h1>

Ao ser renderizada, essa expressão será substituída pelo valor da variável, conforme a imagem seguinte, onde passamos a string “Amigo” para a variável nome e, consequentemente, nome_recebido:

• Resultado do acesso a http://127.0.0.1:5000/ola/Amigo:
Olá, Amigo

Então arquivo ola.py ficaria assim:

from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('ola.html', nome_recebido = nome)

@app.route('/ola/')
@app.route('/ola/<nome>')
def ola_mundo(nome="mundo"):
    return "Olá, " + nome

if __name__ == '__main__':
    app.run()

#modelo ola.html
<!DOCTYPE html>
<html>
    <body>
        <h1>Olá, {{ nome_recebido }}</h1>
    </body>
</html>

---------------------------------------------- ###
Considere o código a seguir, em que temos um servidor Flask escutando na porta 5000, e responda:

from flask import Flask

app = Flask(__name__)

@app.route('/ola')
def ola_mundo():
    return "Olá,mundo"

@app.route('/ola/<nome>')
def hola_mundo(nome):
    return "Olá, " + nome

if __name__ == '__main__':
    app.run()

O que será apresentado no navegador se acessarmos a URL http://127.0.0.1:5000/ola/EAD?

>>> Olá, EAD.

------------------------------------------------ ###
Considere o código a seguir, no qual temos um servidor Flask escutando na porta 5000, e responda:

from flask import Flask

app = Flask(__name__)

@app.route('/ola', methods=['POST'])
def ola_post():
    return "Olá, GET"

@app.route('/ola')
def ola_get(nome="mundo"):
    return "Olá, POST"

if __name__ == '__main__':
    app.run()

O que será apresentado no navegador se acessarmos a URL http://127.0.0.1:5000/ola?

>>> Olá, POST.

O navegador utiliza, por default, o método GET. Com isso, será executada a rota para a função ola_get, da linha 10:
def ola_get(nome="mundo"):

--------------------------------------------- ###
Implementar uma solução em Python com Flask que faça:

a. Exiba a mensagem: "Olá, programadores!" no endereço raiz de uma página web e apareça o link "/user/Usuário"

b. Exiba a mensagem: "Olá, Usuário!" no endereço "/user/" e exiba a mensagem "Altere o endereço do browser e recarregue a página"

c. Exiba a mensagem: "Olá, nome_usuário!" no endereço "/user/nome_do_usuário" de uma página web

from flask import Flask

app = Flask(__name__)

@app.route('/')
def cumprimento():
    boas_vindas = "<h1>Olá, programadores!</h1>"
    link = "<p><a href ='/user/Usuário'>Clique aqui!</a></p>"
    return boas_vindas + link

@app.route('/user/')
@app.route('/user/<nome>')
def user(nome="Usuário"):
    personalizar = f"<h1>Olá, {nome}!</h1>"
    instrucao = "<p>Altere o nome no <em> endereço do browser</em> e recarregue a página.</p>"
    return personalizar + instrucao

if __name__ == '__main__':
    app.run(debug=True)

Então será impresso em:

• http://127.0.0.1:5000/ :
Olá, programadores!
Clique aqui!

• http://127.0.0.1:5000/user/ :
Olá, Usuário!
Altere o nome no endereço do browser e recarregue a página.

• http://127.0.0.1:5000/user/Maria :
Olá, Maria!
Altere o nome no endereço do browser e recarregue a página.

------------------------------------------------- ###
Implementar uma solução em Python com Flask que faça:

a. Exiba a mensagem: "Olá, programadores!" no endereço raiz de uma página web e apareça a mensagem "Entre com dois números"

b. Exiba a mensagem: "0.0" no endereço "/somar/"

c. Exiba a mensagem: "30.0" no endereço "/somar/10/20" de uma página web

from flask import Flask

app = Flask(__name__)

@app.route('/')
def cumprimento():
    boas_vindas = "<h1>Olá, programadores!</h1>"
    instr = "<p>Entre com dois números</p>"
    return boas_vindas + instr

@app.route('/somar/')
@app.route('/somar/<num01>/') #opcional
@app.route('/somar/<num01>/<num02>')
def soma(num01 = 0 , num02 = 0):    
    resultado = float(num01) + float(num02)
    return f"<h1>{str(resultado)}</h1>"  # ou return str(resultado)

if __name__ == '__main__':
    app.run(debug=True)


Então será impresso em:

• http://127.0.0.1:5000/ :
Olá, programadores!
Entre com dois números

• http://127.0.0.1:5000/somar/ :
0.0

• http://127.0.0.1:5000/somar/10 :
10.0

• http://127.0.0.1:5000/somar/10/20 :
30.0



//////////////////////////////////////////////////////////////////////////// &&&
FRAMEWORKS

Atualmente, existem diversas opções de linguagem de programação para desenvolver aplicações Web, sendo as principais:
PHP, ASP.NET, Ruby e Java

De acordo com o site de pesquisas W3Techs, o PHP é a linguagem mais utilizada nos servidores, com um total de 79% de todos os servidores utilizando essa linguagem.

Grande parte da utilização do PHP se deve aos gerenciadores de conteúdo, como WordPress, Joomla e Drupal, escritos em PHP e que têm muita representatividade na Web hoje.

O Python também pode ser utilizado para desenvolver aplicações Web?
Atualmente, existem diversos frameworks que facilitam a criação de aplicações Web em Python.

Os frameworks podem ser divididos em, basicamente, dois tipos: full-stack e não full-stack. Veja cada um deles a seguir:

-Frameworks full-stack:
Disponibilizam diversos recursos internamente, sem a necessidade de bibliotecas externas. Dentre os recursos, podemos citar:
• Respostas à requisição;
• Mecanismos de armazenamento (acesso ao banco de dados);
• Suporte a modelos (templates);
• Manipulação de formulários;
• Autenticação;
• Testes;
• Servidor para desenvolvimento, entre outros.
O principal framework Python full-stack é o Django.

- Frameworks não full-stack:
Oferecem os recursos básicos para uma aplicação Web, como resposta à requisição e suporte a modelos. Os principais frameworks dessa categoria são o Flask e o CherryPy.
Normalmente, para aplicações maiores, são utilizados os frameworks full-stack, que também são um pouco mais complexos de se utilizar.

-------------------------------------- ###
micro (framework)

Pela descrição de seus desenvolvedores, micro não quer dizer que toda a aplicação precisa ficar em apenas um arquivo ou que falta alguma funcionalidade, mas que o núcleo de funcionalidades dele é limpo e simples, porém extensível.

O desenvolvedor fica livre para escolher qual suporte a modelos (templates) utilizar, qual biblioteca de acesso ao banco de dados e como lidar com formulários. Existem inúmeras extensões compatíveis com o Flask.


/////////////////////////////////////////////////////////////////////////// &&&
TIPOS DE ERROS

Em Python, os erros são descobertos pelo componente do interpretador Python, que é chamado analisador ou parser.

Erros e exceções em um programa Python

Erros de sintaxe:
São aqueles que ocorrem devido ao formato incorreto de uma instrução. Esses erros são descobertos pelo componente do interpretador Python, que é chamado analisador ou parser.

Exemplo de erro de sintaxe 1:
print 'hello'
>>> SyntaxError: Missing parentheses in call to 'print'. Did you mean print('hello')?

Exemplo de erro de sintaxe 2:
lista = [1 ; 2 ; 4]
>>> SyntaxError: invalid syntax

Erros que ocorrem em tempo de execução do programa:
Não se devem a uma instrução escrita errada, e sim ao fato de que o programa entrou em um estado indevido.

Elencamos os seguintes exemplos:
1- A divisão por 0.
2- A tentativa de acessar um índice indevido em uma lista.
3- Um nome de variável não atribuído.
4- Um erro causado por tipos incorretos de operando.

Em cada caso, quando o programa atinge um estado inválido, é dito que o interpretador Python levanta uma exceção. Isso significa que é criado um objeto que contém as informações relevantes sobre o erro.

A tabela a seguir traz alguns tipos comuns de exceção:

KeyboardInterrupt	= Levantado quando o usuário pressiona CTRL+C, a combinação de interrupção.
OverflowError =	Levantado quando uma expressão de ponto flutuante é avaliada como um valor muito grande.
ZeroDivisionError	= Levantado quando se tenta dividir por 0.
IOError	= Levantado quando uma operação de entrada/saída falha por um motivo relacionado a isso.
IndexError = Levantado quando um índice sequencial está fora do intervalo de índices válidos.
NameError	= Levantado quando se tenta avaliar um identificador (nome) não atribuído.
TypeError	= Levantado quando uma operação da função é aplicada a um objeto do tipo errado.
ValueError = Levantado quando a operação ou função tem um argumento com o tipo correto, mas valor incorreto.

Em Python, as exceções são objetos. A classe Exception é derivada de BaseException, classe base de todas as classes de exceção. BaseException fornece alguns serviços úteis para todas as classes de exceção, mas normalmente não se torna uma subclasse diretamente.

------------------------------ ###
TRY / CATCH / EXCEPTION

Para evitar que os programas sejam interrompidos quando uma exceção é levantada, é possível planejar um comportamento alternativo.
Assim, o programa não será interrompido e a exceção poderá ser tratada.
Chamamos esse processo de captura da exceção.

Vamos considerar um exemplo de programa que solicita ao usuário, com a função input(), um número inteiro. Embora essa função trate a entrada do usuário como string, é possível utilizá-la em conjunto com a função eval() para que os dados inseridos sejam avaliados como números.

O próximo emulador mostra uma implementação simples desse exemplo:
num = eval(input("Entre com um número inteiro: "))
print(num)

Mas o que aconteceria se o usuário digitasse uma palavra em vez de números? Faça essa experiência e digite uma palavra, como, por exemplo, dois, no emulador anterior e clique em Executar.
Veja que o programa foi encerrado com uma exceção sendo levantada. Uma forma de fazer a captura e a manipulação de exceções é usar o par de instruções try/except:

Bloco try
O bloco try é executado primeiramente. Devem ser inseridas nele as instruções do fluxo normal do programa.

Bloco except
O bloco except só será executado se houver o levantamento de alguma exceção.

Isso permite que o fluxo de execução continue de maneira alternativa. O emulador seguinte mostra uma implementação possível desse exemplo:

try:
    num = eval(input("Entre com um número inteiro: \n"))
    print(num)
except:
    print("Entre com o valor numérico e não letras")

O formato padrão de uso do par try/except é:

try:
   Bloco 1
except:
   Bloco 2
Instrução fora do try/except

O bloco 1 representa o fluxo normal do programa. Caso uma exceção seja levantada, o bloco 2 será executado, permitindo o tratamento adequado dela. Esse bloco 2 é chamado de manipulador de exceção.

Atenção!
Em Python, o manipulador de exceção padrão é que executa o trabalho de captura da exceção caso não haja um tratamento explícito feito pelo desenvolvedor. É esse manipulador o responsável pela exibição das mensagens de erro no console.

Em Python, o manipulador de exceção padrão é que executa o trabalho de captura da exceção caso não haja um tratamento explícito feito pelo desenvolvedor.

É esse manipulador o responsável pela exibição das mensagens de erro no console.

----------------------------------- ###

Em Python, ao tratar exceções, as cláusulas else e finally NÃO são obrigatórias

As cláusulas else e finally podem ser usada, embora não sejam obrigatórias.

Exemplo:

try:
    num = eval(input("Digite um número inteiro: \n"))
    print(num)
except ValueError:
    print("Mensagem 1")
except IndexError:
    print("Mensagem 2")
except:
    print("Mensagem 3")

else:           #OPCIONAL
    print("Mensagem do else")       #OPCIONAL
finally:       #OPCIONAL
    print("Acabou")       #OPCIONAL

---------------------------------- ###

O Python permite que o bloco relativo ao except só seja executado caso a exceção levantada seja de determinado tipo. Para isso é preciso especificar qual o erro de tipo.

O except precisa trazer o tipo de exceção que se deseja capturar.

O emulador a seguir traz uma possível variação do exemplo anterior com a captura apenas das exceções do tipo NameError:

try:
    num = eval(input("Entre com um número inteiro: \n"))
    print(num)
except NameError:
    print("Entre com o valor numérico e não letras")
>>> asd
>>> Entre com o valor numérico e não letras

--------

Para fazer a implementação da captura de exceções de múltiplos tipos:
(como fazer mais de uma exceção?)

try:
    num = eval(input("Digite um número inteiro: \n"))
    print(num)
except ValueError:
    print("Mensagem 1")
except IndexError:
    print("Mensagem 2")
except:
    print("Mensagem 3")

A instrução "print("Mensagem 1")" somente será executada se a exceção levantada no bloco try for do tipo ValueError e se, na instrução "print("Mensagem 2")", a exceção for do tipo IndexError.
Caso a exceção seja de outro tipo, a instrução "print("Mensagem 3")" será executada.

---------
Em Python, a forma geral completa para lidar com as exceções em Python é:
(código completo com mais de uma exceção e final)

try:
    Bloco 1
except Exceção1:
    Bloco tratador para Exceção1
except Exceção2:
    Bloco tratador para Exceção2
...
else:
    Bloco 2 – executado caso nenhuma exceção seja levantada
finally:
    Bloco 3 – executado independente do que ocorrer
Instrução fora do try/except

As cláusulas else e finally são opcionais.

Exemplo:

try:
    num = eval(input("Digite um número inteiro: \n"))
    print(num)
except ValueError:
    print("Mensagem 1 = Erro de valor")
except IndexError:
    print("Mensagem 2 = Erro de índice")
except:
    print("Mensagem 3")
else:
    print("Mensagem do else")
finally:
    print("Acabou")
>>> Digite um número inteiro: [ qe ]  
>>> Mensagem 3 
>>> Acabou

------------------------------------------------ ###
Em Python, considerando os exemplos abaixo, o que aparecerá se digitarmos um texto no campo?

x = eval(input("Digite algo: "))
print(x)

x = input("Digite algo: ")
print(x)

E se digitarmos um número?

Resumo:
input("Considera como uma string / texto")
eval(input("Considera como um número int ou float")


x = eval(input("Digite algo: "))
print(x)
>>> Digite algo: [  abc  ]
>>> Mensagem de erro      (NameError pois eval só aceita números)
>>> Digite algo: [  123  ]
>>> 123

x = input("Digite algo: ")
print(x)
>>> Digite algo: [  abc  ]
>>> abc
>>> Digite algo: [  123  ]
>>> 123

Porém se:
x = input("Digite algo: ")
y = 7
soma = x + y
print(soma)
>>> Digite algo: [  5  ]
>>> Mensagem de erro     (TypeError pois x é uma string e y um número int)

------------------------------------------------------- ###
Considere o seguinte trecho de um programa escrito em Python:

try:
      num = eval(input("Entre com um número inteiro: "))
      print(num)
except ValueError:
      print("Mensagem 1")
except IndexError:
      print("Mensagem 2")
except:
      print("Mensagem 3")

Suponha que, durante a execução, o usuário entre com a palavra “numero” quando solicitado. O que aparecerá como resultado?

Mensagem 3

Como o usuário inseriu uma palavra, e não um número, a exceção não será do tipo ValueError nem do tipo IndexError. Assim, a cláusula except a ser executada é a da linha 8, imprimindo Mensagem 3.

Resumo:
input("Considera como uma string / texto")
eval(input("Considera como um número int ou float")

x = eval(input("Digite algo: "))
print(x)
>>> Digite algo: [  abc  ]
>>> Mensagem de erro      (NameError pois eval só aceita números)
>>> Digite algo: [  123  ]
>>> 123

----------------------------------------------------- ###
Implementar uma solução em Python que faça o tratamento de exceção para verificar se a entrada é, de fato, um número:

try:
    x = int(input("Digite um número: "))
except ValueError:
    print("Entre com um número válido.")

>>> Digite um número: [  abc  ]
>>> Entre com um número válido.

----------------------------------------------------- ###
Implementar uma solução em Python que faça o tratamento de exceção para verificar se uma entrada é numérica e que, além disso, insista que o usuário difite um número válido:

while True:
   try:
      x = int(input("Digite um número: "))
      print(f"Você digitou o número {x}.")      #Opcional
      break
   except ValueError:
      print("Entre com um número válido.")

>>> Digite um número: [  d  ]
>>> Entre com um número válido. 
>>> Digite um número: [  f  ]
>>> Entre com um número válido. 
>>> Digite um número: [  3  ] 
>>> Você digitou o número 3.

----------------------------------------------------- ###
Implementar uma solução em Python que faça o tratamento de exceção da divisão por Zero:

x = int(input("Digite um número: "))
y = int(input("Digite um número: "))
try:
    d = x / y
except ZeroDivisionError:
    print("Não pode dividir por zero.")
>>> Digite um número: 4 
>>> Digite um número: 0 
>>> Não pode dividir por zero.


Não é possível realizar divisões por zero:
s = 3 / 0
print(s)
>>> ZeroDivisionError: division by zero

Solução do professor:

def dividir(x, y):
   try:
      d = x / y
      print(f"A resposta é {d}.")
   except ZeroDivisionError:
      print("Divisão por zero.")
dividir(3, 0)
dividir(3, 2)
>>> Divisão por zero. 
>>> A resposta é 1.5.

------------------------------------------- ###

Como diversas linguagens orientadas a objetos, o Python permite a criação de tipos de exceções para diferenciar os erros gerados pelas bibliotecas da linguagem daqueles gerados pelas aplicações desenvolvidas. Deve-se, para isso, usar a característica da herança para herdar novas exceções a partir da classe Exception do Python (MENEZES, 2020).

O Tratamento de Exceções é fundamental para tratarmos de problemas de execução e impormos regras de negócio.
Ao usar uma exceção, ao invés do programa dar erro e parar quando encontrar um problema, ele mostrará a mensagem de erro e continuará.

Exemplo 1 do video:

x = 10
if x > 5:
    raise Exception(f"x não pode ser maior do que 5. O valor de x foi de: {x}")

Aparecerá uma mensagem de erro dizendo:
>>> Exception: x não pode ser maior do que 5. O valor de x foi de: 10


Exemplo 2 do video:

x = 2
y = 3
print(x + y)

try:
    print(z)
except:
    print("Esta variável ainda não foi definida")

Será impresso:
>>> 5
>>> Esta variável ainda não foi definida

Então ao invés do programa dar erro e parar, ele apresentou a mensagem de erro e continuou normalmente. Caso não tivesse implementado o try/except o programa pararia, por exemplo:

x = 2
y = 3
print(x + y)

print(z)

Daria a seguinte mensagem de erro:
>>> NameError: name 'z' is not defined

Exemplo 3 do video:
É possível customizar as exceções:

class ExcecaoCustomizada(exception):
    pass

x = -1
if x < 0:
    raise Exception("Valor negativo!!!")

x = "hello"
if not type(x) is int:
    raise TypeError("Use apenas números inteiros")

Desmembrando o exemplo acima:

x = -1
if x < 0:
    raise Exception("Valor negativo!!!")
>>> Exception: Valor negativo!!!

x = "hello"
if not type(x) is int:
    raise TypeError("Use apenas números inteiros")
>>> TypeError: Use apenas números inteiros


Colacando dentro de uma função:

x = "texto"
def teste():
    if not type(x) is int:
        return ("Apenas números inteiros!!!")
print(teste())
>>> Apenas números inteiros!!!

x = -1
def teste():
    if x < 0:
        return ("Valor negativo!!!")
print(teste())
>>> Valor negativo!!!

--------------------------------------------

Outro exemplo (da apostila):

class ExcecaoCustomizada(exception):
    pass
   
    def throws(): (2)
        raise ExcecaoCustomizada
        try:
            throws()
        except ExcecaoCustomizada as ex:
            print ("Exceção lançada")

No código acima:

- Na linha 1, define-se a exceção customizada ExcecaoCustomizada com o método pass, pois ele não executa nada relevante.
class ExcecaoCustomizada(exception):

- Na linha 4, é definido um método que, se for chamado, criará a exceção na memória ExcecaoCustomizada.
def throws(): (2)

- Na linha 6, é utilizado o try...except, que indica para o interpretador que a área do código localizada entre o try e o except poderá lançar exceções que deverão ser tratadas nas linhas de código após o except.
try:
    throws()
except ExcecaoCustomizada as ex:
    print ("Exceção lançada")

Ao final da execução, será impressa a “Exceção lançada” pela captura da exceção, a qual, por sua vez, é lançada pelo método throws().

//////////////////////////////////////////////////////////////////////// &&&
EVENTOS

Em Python, o tratamento de eventos é similar ao de exceções.

Assim como no caso das exceções ocorridas em tempo de execução, podemos tratar os eventos criados por ações externas, como as interações de usuário realizadas por meio de uma interface gráfica de usuário (GUI).

Um evento é a notificação de que alguma coisa aconteceu, como um clique de mouse sobre um elemento botão. O tratador do evento é o segmento de código que será executado em resposta à ocorrência do evento.

Em Python, um evento é a notificação de que alguma coisa aconteceu, como um clique de mouse sobre um elemento botão. O tratador do evento é o segmento de código que será executado em resposta à ocorrência do evento.

///////////////////////////////////////////////////////////////////////// &&&
CLASSES

Forma 1 (reduzida):

class CLASSE:
    def __init__(self, atributo1, atributo2):
        self.atributo1 = atributo1
        self.atributo2 = atributo2

    def get_Atributo1(self):
        return self.atributo1

    def get_Atributo2(self):
        return self.atributo2

objeto = CLASSE("info1" , "info2")

print( objeto.get_Atributo1() , objeto.get_Atributo2() )

¨¨¨¨
Forma 2:

class CLASSE:
    def __init__(self, atributo1, atributo2):
        self.set_Atributo1(atributo1)
        self.set_Atributo2(atributo2)

    def set_Atributo1(self, atributo1):
        self.atributo1 = atributo1

    def set_Atributo2(self, atributo2):
        self.atributo2 = atributo2

    def get_Atributo1(self):
        return self.atributo1

    def get_Atributo2(self):
        return self.atributo2

objeto = CLASSE("info1" , "info2")

print( objeto.get_Atributo1() , objeto.get_Atributo2() )

---------------------- %%%

Exemplo:

class Pessoa:
    def __init__(self, nome, ender):
        self.set_nome(nome)
        self.set_ender(ender)

    def set_nome(self, nome):
        self.nome=nome

    def set_ender(self, ender):
        self.ender=ender

    def get_nome(self):
        return self.nome

    def get_ender(self):
        return self.ender


Com a classe criada, agora podemos criar os objetos:

pessoa1 = Pessoa("Maria" , "Rua 01234")
pessoa2 = Pessoa("João" , "Rua 56789")


Agora só resta imprimir cada um dos objetos:

print(f"Nome: {pessoa1.get_nome()}, Endereço: {pessoa1.get_ender()}")

>>> Nome: Maria, Endereço: Rua 01234

print(f"Nome: {pessoa2.get_nome()}, Endereço: {pessoa2.get_ender()}")

>>> Nome: João, Endereço: Rua 56789

-------------------------- %%%

Outro exemplo:

class Pessoa:
    def __init__(self, nome, idade):
        self.setNome(nome)
        self.setIdade(idade)

    def setNome(self, nome):
        self.nome=nome

    def setIdade(self, idade):
        self.idade=idade

    def getNome(self):
        return self.nome

    def getIdade(self):
        return self.idade

pessoa1 = Pessoa("Ana" , 25)

print(f"{pessoa1.getNome()} tem {pessoa1.getIdade()} ano(s)")

¨¨¨¨
Outra forma:

class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def getNome(self, nome):
        return self.nome

    def getIdade(self):
        return self.idade

    def imprimir(self):
        print(self.nome,"tem",self.idade,"ano(s)")

p = Pessoa("Ana" , 25)
p.imprimir()

------------------------------------------------------- ###
HERANÇA + POLIMORFISMO

A herança e o polimorfismo podem ser visto nas classes da seguinte maneira:

Herança:
class Profissional(Pessoa):
    def __init__(self, nome, idade, profissao):
        super().__init__(nome, idade)
        self.profissao = profissao
    def imprimir(self):
        super().imprimir()
        print("\t e trabalha como ",self.profissao)

Polimorfismo:
p = Profissional("Ana", 25, "balconista")
p.imprimir()

------------------------ %%%

Obs: super() não funciona com heranças múltiplas

Exemplo 1 (herdando um atributo da classe Pai):

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1

class Filho(Pai):
    def __init__(self, atributo1):
        super().__init__(atributo1)

objeto_filho = Filho("ATRIBUTO 1")

print(objeto_filho.atributo1)
>>> ATRIBUTO 1

---------------------

Exemplo 2 ( sem usar super() ):

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1

class Filho(Pai):
        pass

objeto_filho = Filho("ATRIBUTO 1")

print(objeto_filho.atributo1)
>>> ATRIBUTO 1

--------------------

Exemplo 3 (herdando um atributo da classe Pai e adicionando um novo atributo próprio):

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1

class Filho(Pai):
    def __init__(self, atributo1, atributo2):
        super().__init__(atributo1)
        self.atributo2 = atributo2

objeto_filho = Filho("ATRIBUTO 1", "ATRIBUTO 2")

print(objeto_filho.atributo1)
>>> ATRIBUTO 1

-------------------------

Exemplo 4 (herdando um método da classe Pai):

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1

    def Metodo(self):
        print(self.atributo1)
     
class Filho(Pai):
    def __init__(self, atributo1):
        super().__init__(atributo1)

objeto_filho = Filho("ATRIBUTO 1")

objeto_filho.Metodo()
>>> ATRIBUTO 1

-----------------------

Exemplo 5 (herdando um método da classe Pai e usando um atributo da classe Filho como valor):

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1  #não está sendo usado

    def Metodo(self, atributo3):
        print(atributo3)

class Filho(Pai):
    def Metodo(self, atributo3 = "ATRIBUTO 3"):
        return super().Metodo(atributo3)

objeto_pai = Pai("ATRIBUTO 1")  #não está sendo usado
objeto_filho = Filho("ATRIBUTO 2")

objeto_filho.Metodo()
>>> ATRIBUTO 3


O exemplo acima poderia ser feito usando pass também:

class Pai:
    def __init__(self, atributo1):
        self.atributo1 = atributo1  #não está sendo usado

    def Metodo(self, atributo3):
        print(atributo3)

class Filho(Pai):
    pass

objeto_pai = Pai("ATRIBUTO 1")  #não está sendo usado
objeto_filho = Filho("ATRIBUTO 2")  #ATRIBUTO 2 não está sendo usado

objeto_filho.Metodo("ATRIBUTO 3")

--------------------------------------------------------- ###
HERANÇA MÚLTIPLA

Para implementar herança múltipla:
(aplicando herança múltipla em mais de uma classe sem usar super() )

A herança múltipla é um mecanismo que possibilita a uma classe herdar o código de duas ou mais superclasses. Esse mecanismo é implementado por poucas linguagens orientadas a objetos e insere uma complexidade adicional na arquitetura das linguagens.

Herança múltipla é permitido no Python e C, mas não é permitido no Java.

Para nosso sistema, vamos considerar a necessidade de um novo produto, que consiste em uma conta corrente similar àquela definida anteriormente no sistema, com as seguintes características:

- Deverá ter um rendimento diário com base no rendimento da conta-poupança.
- Terá de ser cobrada uma taxa de manutenção mensal, mesmo se o rendimento for de apenas um dia.

A Classe Poupança também será criada para armazenar a taxa de remumeração e o cálculo do rendimento mensal da poupança.

Este será o diagrama com as novas classes criadas no sistema de conta corrente:



A implementação está detalhada nestes códigos:

#arquivo contapoupanca.py :
import datetime

class ContaPoupanca:
   def __init__(self,taxaremuneracao):
      self.taxaremuneracao = taxaremuneracao
      self.data_abertura = datetime.datetime.today()   #não é usado neste exemplo

   def remuneraConta(self):
      self.saldo += self.saldo * self.taxaremuneracao

#arquivo contaremunerada.py :
from conta import Conta
from contapoupanca import ContaPoupanca

class ContaRemuneradaPoupanca(Conta, ContaPoupanca):
    def __init__(self, taxaremuneracao, clientes, numero, saldo):
        Conta.__init__(self,clientes,numero,saldo)
        ContaPoupanca.__init__(self,taxaremuneracao)
        self.taxaremuneracao = taxaremuneracao
       
    def remuneraConta(self):
        self.saldo += self.saldo * (self.taxaremuneracao/30)
        self.saldo -= self.taxaremuneracao

Execução no terminal:
#arquivo terminal.py :
from clientes import Cliente
from conta import Conta
from contapoupanca import ContaPoupanca
from contaremunerada import ContaRemuneradaPoupanca

cliente1 = Cliente("123","Joao","Rua X")
cliente2 = Cliente("456","Maria","Rua W")

conta1 = Conta([cliente1,cliente2],1,2000)
contapoupanca1 = ContaPoupanca(0.1)
contaremunerada1 = ContaRemuneradaPoupanca(0.1,cliente1,5,1000)

contaremunerada1.remuneraConta()
contaremunerada1.gerarsaldo()

>>> numero: 5
>>> saldo: 998.3333333333334


Eis alguns pontos importantes sobre a implementação no arquivo contaremunerada.py :

- Declaração de herança múltipla:
A linha 4 indica que a classe é herdeira de Conta e de Poupança, nesta ordem. Tal ordem tem importância, pois existem dois métodos no pai com o mesmo nome. O Python dá prioridade para a primeira classe que implementa esse método na ordem da declaração (PYTHON COURSE, 2000).
linha 4:
class ContaRemuneradaPoupanca(Conta, Poupanca):

- Construtor da classe:
Deve ser chamado o construtor explicitamente das superclasses com o seguinte formato:
nomeclasse.__init__(construtores). 
Isso pode ser visto nas linhas 6 e 7:
Conta.__init__(self,clientes,numero,saldo)
Poupanca.__init__(self,taxaremuneracao)

--------------------------------------- %%%

O código completo ficaria assim:

#arquivo clientes.py :
class Cliente:
    def __init__(self, cpf, nome, endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco

#arquivo conta.py :
import datetime

class Conta:
    def __init__(self, clientes, numero, saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo

    def gerarsaldo(self):
        print(f"Número da conta: {self.numero}\nSaldo: {self.saldo}")

#arquivo contapoupanca.py :
class ContaPoupanca:
    def __init__(self, taxaremuneracao):
        self.taxaremuneracao = taxaremuneracao

    def remuneraConta(self):
        self.saldo += self.saldo * self.taxaremuneracao

#arquivo contaremunerada.py :
from conta import Conta
from contapoupanca import ContaPoupanca

class ContaRemuneradaPoupanca(Conta, ContaPoupanca):
    def __init__(self, taxaremuneracao, clientes, numero, saldo):
        Conta.__init__(self, clientes, numero, saldo)
        ContaPoupanca.__init__(self, taxaremuneracao)
        self.taxaremuneracao = taxaremuneracao
       
    def remuneraConta(self):
        self.saldo += self.saldo * (self.taxaremuneracao/30)
        self.saldo -= self.taxaremuneracao

#arquivo terminal.py :
from clientes import Cliente
from conta import Conta
from contapoupanca import ContaPoupanca
from contaremunerada import ContaRemuneradaPoupanca

cliente1 = Cliente("123","Joao","Rua X")
cliente2 = Cliente("456","Maria","Rua W")

conta1 = Conta( [cliente1,cliente2] , 1 , 2000 )
contapoupanca1 = ContaPoupanca(0.1) #Não está sendo usado
contarenumerada1 = ContaRemuneradaPoupanca(0.1, cliente1 , 5 , 1000)

contarenumerada1.remuneraConta()
contarenumerada1.gerarsaldo()

>>> Número da conta: 5 
>>> Saldo: 1003.2333333333333

---------------------------------------------- %%%

Exemplo simples de herança múltipla :

class Pai:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def somar1(self):
        return self.a + self.b

class Mae:
    def __init__(self, c, d):
        self.c = c
        self.d = d
    def somar2(self):
        return self.c + self.d

class Filho(Pai, Mae):
    def __init__(self, a, b, c, d):
      Pai.__init__(self, a, b)
      Mae.__init__(self, c, d)

x = Filho(10, 20, 30, 40)

print( x.somar1() )
print( x.somar2() )

>>> 30
>>> 70

Na herança múltipla não seria possível usar super(). Então não poderia usar:
super().__init__(a, b)
super().__init__(c, d)

-------------------------------------------------- %%%

# HERANÇA MÚLTIPLA (exemplo do video)

#arquivo clientes.py :
class Cliente:
    def __init__(self, cpf, nome, endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco

#arquivo conta.py :
import datetime

class Conta:
    def __init__(self, clientes, numero, saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo

#arquivo contapoupanca.py :
class ContaPoupanca:
    def __init__(self, taxaremuneracao):
        self.taxaremuneracao = taxaremuneracao

    def remuneraConta(self):    #não está sendo usado neste exemplo
        self.saldo += self.saldo * self.taxaremuneracao

#arquivo contaremunerada.py :
from conta import Conta
from contapoupanca import ContaPoupanca

class ContaRemuneradaPoupanca(Conta, ContaPoupanca):
    def __init__(self, clientes, numero, saldo, taxaremuneracao):
        Conta.__init__(self, clientes, numero, saldo)
        ContaPoupanca.__init__(self, taxaremuneracao)
       
    def remuneraConta(self):
        self.saldo += self.saldo * (self.taxaremuneracao / 30)

#arquivo terminal.py :
from clientes import Cliente
from conta import Conta
from contapoupanca import ContaPoupanca
from contaremunerada import ContaRemuneradaPoupanca

c1 = Cliente("123","Joao","Rua X")
c2 = Cliente("456","Maria","Rua W")

cx = ContaRemuneradaPoupanca( [c1, c2] , 98939123 , 1500.00 , 0.03 )

print("Saldo antigo:", cx.saldo)

cx.remuneraConta()

print("Saldo novo:", cx.saldo)

>>> Saldo antigo: 1500.0 
>>> Saldo novo: 1501.5

----------------------------------------------------------------------- ###
POLIMORFISMO

Para implementar polimorfismo:
(aplicando polimorfismo em mais de uma classe usando super() )

Polimorfismo é o mecanismo que permite a um método com o mesmo nome ser executado de modo diferente a depender do objeto que está chamando o método. A linguagem define em tempo de execução (late binding) qual método deve ser chamado. Essa característica é bastante comum em herança de classes devido à redefinição da implementação dos métodos nas subclasses.

Vamos imaginar que agora tenhamos uma entidade Banco que controla todas as contas criadas no sistema de conta corrente. As contas podem ser do tipo conta, contacomum ou contarenumerada. O cálculo do rendimento da conta Cliente desconta IOF e IR; a conta Renumerada, apenas o IOF. Já a conta Cliente não tem desconto nenhum.

Todos os descontos são realizados em cima do valor bruto após o rendimento mensal. Uma vez por mês, o banco executa o cálculo do rendimento de todos os tipos de contas.

O diagrama será apresentado na imagem adiante:


Vamos analisar agora a implementação das classes:

#arquivo contacliente.py :
import datetime

class ContaPoupanca:
    def __init__(self, taxaremuneracao):
        self.taxaremuneracao = taxaremuneracao
        self.data_abertura = datetime.datetime.today()  #não está sendo usado

    def remuneracaoConta(self):
        self.saldo += self.saldo * self.taxaremuneracao

class ContaCliente:
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        self.numero = numero
        self.IOF = IOF
        self.IR = IR
        self.valorinvestido = valorinvestido
        self.taxarendimento = taxarendimento

    def CalculoRendimento(self):
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)
        self.valorinvestido = self.valorinvestido - (self.taxarendimento * self.IOF * self.IR)

    def Extrato(self): #(1)
        print (f"O saldo atual da conta {self.numero} é {self.valorinvestido:10.2f}")

#arquivo contacomum.py :
from contacliente import ContaCliente

class ContaComum(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): #(2)
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)

#arquivo contaremunerada.py :
from contacliente import ContaCliente

class ContaRemunerada(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): #(3)
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)
        self.valorinvestido -= self.valorinvestido * self.IOF


Em (#1), foi definido um método Extrato, que é igual para as três classes, ou seja, as subclasses herdarão o código completo desse método. Em (#2) e (#3), as subclasses possuem regras de negócios diferentes; portanto, elas sobrescrevem o método CalculoRendimento para atender às suas necessidades.
Vamos analisar a implementação da classe Banco e do programa que a utiliza:

#arquivo banco.py :
class Banco():
    def __init__(self, codigo, nome):
        self.codigo = codigo
        self.nome = nome
        self.contas = [ ]

    def adicionaconta(self, contacliente):
        self.contas.append(contacliente)

    def calcularendimentomensal(self): #(7)
        for c in self.contas:
            c.CalculoRendimento()
           
    def imprimesaldocontas(self):
        for c in self.contas:
            c.Extrato()
       
banco1 = Banco(999,"teste")

contacliente1 = ContaCliente(1, 0.01 , 0.1 , 1000 , 0.05)
contacomum1 = ContaComum(2, 0.01 , 0.1 , 2000 , 0.05)
contaremunerada1 = ContaRemunerada(3, 0.01 , 0.1 , 2000 , 0.05)

banco1.adicionaconta(contacliente1) #(4)
banco1.adicionaconta(contacomum1) #(5)
banco1.adicionaconta(contaremunerada1) #(6)

banco1.calcularendimentomensal() #(7)
banco1.imprimesaldocontas() #(8)

• Em (#4), (#5) e (#6), o banco adiciona todas as contas da hierarquia em um único método devido ao teste “É-UM” das linguagens orientadas a objetos. No método, isso é definido para receber um objeto do tipo ContaCliente. Toda vez que o método é chamado, a linguagem testa se o objeto passado “É-UM” objeto do tipo ContaCliente.

• Em (#4), o objeto é da própria classe ContaCliente. Em (#5), o objeto contacomum1 passado é uma ContaComum, que passa no teste “É-UM”, pois uma ContaComum também é uma ContaCliente.

• Em (#6), o objeto contaremunerada1 “É-UM” objeto ContaComum. Essas ações são feitas de forma transparente para o programador.

• Em (#7), acontece a “mágica” do polimorfismo, pois, em (#4), (#5) e (#6), são adicionadas contas de diferentes tipos para o array conta da classe Banco. Assim, no momento da execução do método c.calculorendimentomensal(), o valor de c recebe, em cada loop, um tipo de objeto diferente da hierarquia da classe ContaCliente. Portanto, na instrução c.CalculoRendimento(), o interpretador tem de identificar dinamicamente de qual objeto da hierarquia ContaCliente deve ser chamado o método CalculoRendimento.

• Em (#8), acontece uma característica que vale ser ressaltada. Pelo polimorfismo, o interpretador verificará o teste “É-UM”, porém esse método não foi sobrescrito pelas subclasses da hierarquia ContaCliente. Portanto, será chamado o método Extrato da superclasse.

O polimorfismo é bastante interessante em sistemas com dezenas de subclasses herdeiras de uma única classe; assim, todas as subclasses redefinem esse método. Sem o polimorfismo, haveria a necessidade de “perguntar” para a linguagem qual é a instância do objeto em execução para chamar o método correto. Com base nele, essa checagem é feita internamente pela linguagem de maneira transparente.

---------------------------------------------- %%%

O arquivo completo ficaria assim:

#arquivo contacliente.py :
import datetime

class ContaPoupanca:
    def __init__(self, taxaremuneracao):
        self.taxaremuneracao = taxaremuneracao
        self.data_abertura = datetime.datetime.today()  #não está sendo usado

    def remuneracaoConta(self):
        self.saldo += self.saldo * self.taxaremuneracao

class ContaCliente:
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        self.numero = numero
        self.IOF = IOF
        self.IR = IR
        self.valorinvestido = valorinvestido
        self.taxarendimento = taxarendimento

    def CalculoRendimento(self):
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)
        self.valorinvestido = self.valorinvestido - (self.taxarendimento * self.IOF * self.IR)

    def Extrato(self): 
        print (f"O saldo atual da conta {self.numero} é {self.valorinvestido:10.2f}")

#arquivo contacomum.py :
from contacliente import ContaCliente

class ContaComum(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): 
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)

#arquivo contaremunerada.py :
from contacliente import ContaCliente

class ContaRemunerada(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): 
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)
        self.valorinvestido -= self.valorinvestido * self.IOF

#arquivo banco.py :
class Banco():
    def __init__(self, codigo, nome):
        self.codigo = codigo
        self.nome = nome
        self.contas = [ ]

    def adicionaconta(self, contacliente):
        self.contas.append(contacliente)

    def calcularendimentomensal(self): 
        for c in self.contas:
            c.CalculoRendimento()
           
    def imprimesaldocontas(self):
        for c in self.contas:
            c.Extrato()
       
banco1 = Banco(999,"teste")

contacliente1 = ContaCliente(1, 0.01 , 0.1 , 1000 , 0.05)
contacomum1 = ContaComum(2, 0.01 , 0.1 , 2000 , 0.05)
contaremunerada1 = ContaRemunerada(3, 0.01 , 0.1 , 2000 , 0.05)

banco1.adicionaconta(contacliente1) 
banco1.adicionaconta(contacomum1) 
banco1.adicionaconta(contaremunerada1) 

banco1.calcularendimentomensal() 
banco1.imprimesaldocontas() 

--------------------------------------------- %%%

Exemplo simples de polimorfismo:

#arquivo teste1.py :
class A:
    def __init__(self, valor):
        self.valor = valor

    def soma(self):
        aa = self.valor + 1
        print("Teste1 =",aa)

#arquivo teste2.py :
from teste1 import A

class B(A):
    def __init__(self, valor):
        super().__init__(valor)
       
    def soma(self):
        bb = self.valor + 2
        print("Teste2 =",bb)

#arquivo teste3.py :
from teste1 import A

class C(A):
    def __init__(self, valor):
        super().__init__(valor)

    def soma(self):
        cc = self.valor + 3
        print("Teste3 =",cc)

#arquivo terminal.py :
from teste1 import A
from teste2 import B
from teste3 import C

class D():
    def __init__(self, nome):
        self.nome = nome

    def link(self):
        for x in abc:
            x.soma()

teste = D("Nome")

a1 = A(10)
b1 = B(10)
c1 = C(10)

abc = [a1 , b1 , c1]

teste.link() 

>>> Teste1 = 11
>>> Teste2 = 12 
>>> Teste3 = 13

----------------------------------------------------- %%%

POLIMORFISMO (exemplo do VIDEO)
exemplo com banco de dados

class Argentina():
    def capital(self):
        print("Buenos Aires é a capital da Argentina.")
    def lingua_oficial(self):
        print("O espanhol é a língua oficial da Argentina.")

class Brasil():
    def capital(self):
        print("Brasília é a capital do Brasil.")
    def lingua_oficial(self):
        print("O português é a língua oficial do Brasil.")

obj_arg = Argentina()
obj_bra = Brasil()

for pais in (obj_arg, obj_bra):
    pais.capital()
    pais.lingua_oficial()

>>> Buenos Aires é a capital da Argentina. 
>>> O espanhol é a língua oficial da Argentina. 
>>> Brasília é a capital do Brasil. 
>>> O português é a língua oficial do Brasil.

------------------------------------------------ %%%

POLIMORFISMO (exemplo do VIDEO)
exemplo 2 usando super()

class Veiculo:
    def rodar(self):
        print("Reduz o consumo de combustível.")

class VeiculoEletrico(Veiculo):
    def rodar(self):
        super().rodar()
        print("Esse veículo utiliza eletricidade.")

veiculo_eletrico = VeiculoEletrico()
veiculo_eletrico.rodar()

>>> Reduz o consumo de combustível.
>>> Esse veículo utiliza eletricidade.

O super() faz referência ao construtor da classe mãe. No exemplo acima, ele está referenciando o método rodar () presente na classe Veiculo.

--------------------------------------------- %%%

POLIMORFISMO (exemplo do video)
utilização do pass

class ContaCliente:
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        self.numero = numero
        self.IOF = IOF
        self.IR = IR
        self.valorinvestido = valorinvestido
        self.taxarendimento = taxarendimento

    def CalculoRendimento(self):
        pass    #quer dizer que não será implementado e deixará por conta do filho (ContaComum) que herdar este método

#arquivo contacomum.py :
from contacliente import ContaCliente

class ContaComum(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): 
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)

#arquivo contaremunerada.py :
from contacliente import ContaCliente

class ContaRemunerada(ContaCliente):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        super().__init__(numero, IOF, IR, valorinvestido, taxarendimento)

    def CalculoRendimento(self): 
        self.valorinvestido += (self.valorinvestido * self.taxarendimento)
        self.valorinvestido -= self.valorinvestido * self.IOF

#arquivo banco.py :
class Banco():
    def __init__(self, codigo, nome):
        self.codigo = codigo
        self.nome = nome
        self.contas = [ ]

    def adicionaconta(self, contacliente):
        self.contas.append(contacliente)

    def calcularendimentomensal(self): 
        for c in self.contas:
            c.CalculoRendimento()
           
    def imprimesaldocontas(self):
        for c in self.contas:
            c.Extrato()
       
banco1 = Banco(999,"teste")

contacliente1 = ContaCliente(1, 0.01 , 0.1 , 1000 , 0.05)
contacomum1 = ContaComum(2, 0.01 , 0.1 , 2000 , 0.05)
contaremunerada1 = ContaRemunerada(3, 0.01 , 0.1 , 2000 , 0.05)

banco1.adicionaconta(contacliente1) 
banco1.adicionaconta(contacomum1) 
banco1.adicionaconta(contaremunerada1) 

banco1.calcularendimentomensal() 
banco1.imprimesaldocontas() 

--------------------------------------------------------- ###
BOAS PRATICAS E OBSERVAÇÕES

Como boa prática, cada classe deve fazer parte de um único arquivo.py para ajudar na estruturação do sistema orientado a objetos em Python.

------

Outra boa prática consiste no nome da classe semelhante ao do arquivo, como, por exemplo, definir no ambiente de desenvolvimento Python a classe Conta. O nome final do arquivo tem de ser Conta.py.

Uma classe é definida mediante a utilização da instrução class e de : para indicar o início do bloco de declaração da classe.
(criação de uma classe)


A palavra reservada pass, por sua vez, indica que a classe será definida posteriormente, servindo apenas para permitir que o interpretador a execute até o final sem erros.

class Conta:
    pass

A classe Conta foi criada, porém não foram definidos atributos e instanciados objetos para ela. Ambos são uma característica básica dos programas orientados a objetos.

--------------------------------------------------------- ### 
__INIT__()

Nas linguagens orientadas a objetos, para se instanciar objetos, é preciso criar os construtores da classe.
(criação de um construtor __init__() )


Em Python, a palavra reservada __init__() serve para a inicialização de classes, como é possível verificar abaixo:

class Conta:
    def__init__(self, numero, cpf, nomeTitular, saldo):
        self.numero = numero
        self.cpf = cpf
        self.nomeTitular = nomeTitular
        self.saldo = saldo

Diferentemente de outras linguagens de programação orientadas a objetos, o Python constrói os objetos em duas etapas. A primeira etapa é utilizada com a palavra reservada __new__, a qual, em seguida, executa o método __init__.

O __new__ cria a instância e é utilizado para alterar as classes dinamicamente nos casos de sistemas que envolvam metaclasses e frameworks. Após __new__ ser executado, esse método chama o __init__ para a inicialização da classe como seus valores iniciais (MENEZES, 2019).

Para efeitos de comparação com outras linguagens de programação (e por questões de simplificação), consideraremos o __init__ como o construtor da classe. Portanto, toda vez que instanciarmos objetos da classe conta, o método __init__ será chamado.

Analisando o nosso exemplo anterior, vimos a utilização da palavra self como parâmetro no construtor. Como o objeto já foi instanciado implicitamente pelo __new__, o método __init__ recebe uma referência do objeto instanciado como self.

Analisando o restante do construtor da figura Classe Conta Inicial vista anteriormente, notamos que o código possui diversos comandos self, o que indica uma referência ao próprio objeto. Por exemplo, o comando self.numero é uma indicação de que o número é um atributo do objeto, ao qual, por sua vez, é atribuído um valor. O restante dos comandos self indica a criação dos atributos cpf, nomeTitular e saldo referentes à classe Conta.

Vamos instanciar agora o nosso objeto com o método __init__ no emulador (clique em Executar e verifique a saída do código no console do emulador):

class Conta:
    def __init__(self, numero, cpf, nomeTitular, saldo):
        self.numero = numero
        self.cpf = cpf
        self.nomeTitular = nomeTitular
        self.saldo = saldo

def main():
    c1 = Conta(1,1,"Joao",1000) # Objeto sendo instanciado
    print (f"Nome do titular da conta: {c1.nomeTitular}")
    print (f"Número da conta: {c1.numero}")
    print (f"CPF do titular da conta: {c1.cpf}")
    print (f"Saldo da conta: {c1.saldo}")

if __name__ == "__main__":
    main()

Quando um script python é executado, a variável reservada NAME referente a ele tem valor igual a "__main__".
Nesse caso, a condição do IF a seguir será TRUE.
Então o que está no corpo do IF será executado. No caso, é um chamado ao método main do script.

É importante ressaltar que, em Python, não é obrigatório ter um método construtor na classe. Isso ocorrerá apenas se for necessária alguma ação na construção do objeto, como a inicialização e/ou a atribuição de valores.

Segue um exemplo de uma classe sem um método construtor:

class A():
    def função(self):
        print("texto de exemplo")

def main():
    obj_A = A() # Objeto sendo instanciado
    obj_A.função()

if __name__ == "__main__":
    main()


Outra forma (sem o if):

class A():
    def função(self):
        print("texto de exemplo")

def main():

    obj_A = A()
    obj_A.função()

main()


Outra forma (simplificada):

class A():

    def função(self):
        print("texto de exemplo")

obj_A = A()
obj_A.função()

----------------------

Exemplo simples 1:

class Classe:
    def Metodo(self):
        print("Texto")

objeto = Classe()

objeto.Metodo()
>>> Texto

Exemplo simples 2:

class Classe:
    def __init__(self, atributo1, atributo2):
      self.atributo1 = atributo1
      self.atributo2 = atributo2

    def Metodo(self):
        print(self.atributo1)

objeto = Classe("ATRIBUTO 1", "ATRIBUTO 2")

objeto.Metodo()
>>> ATRIBUTO 1

---------------------------------------------------------- ###

Toda classe precisa possuir um conjunto de métodos para manipular os atributos e, por consequência, o estado do objeto.


Por exemplo, precisamos depositar dinheiro na conta para aumentar o valor da conta corrente:

def __depositar__(self,valor)
     self.saldo += valor

No código acima, foi definido um método __depositar__, que recebe a própria instância do objeto por meio do self e de um parâmetro valor. O número passado por intermédio do parâmetro será adicionado ao saldo da conta do cliente.

Vamos supor que o estado anterior do objeto representasse o saldo com o valor zero da conta. Após a chamada desse método, passando como parâmetro o valor 300, o estado da conta foi alterado com o novo saldo de 300 reais graças à referência self.

Segue o novo código:

class Conta:
    def__init__(self, numero, cpf, nomeTitular, saldo):
         self.numero = numero
         self.cpf = cpf
         self.nomeTitular = nomeTitular
         self.saldo = saldo

    def depositar(self, valor):
         self.saldo += valor

     def sacar(self, valor):
         self.saldo -= valor

No exemplo anterior, adicionamos mais um método sacar(self, valor), do qual subtraímos o valor, passado como parâmetro, do saldo do cliente. Pode ser adicionado um método extrato para avaliar os valores atuais da conta corrente, ou seja, o estado atual do objeto.

A conta tinha, por exemplo, um saldo de 300 reais após o primeiro depósito. Após a chamada de sacar (100), o saldo da conta será de 200 reais. Desse modo, se o método gerarextrato() for executado, o valor impresso será 200.

class Conta:
    def __init__(self, numero, cpf, nomeTitular, saldo):
        self.numero = numero
        self.cpf = cpf
        self.nomeTitular = nomeTitular
        self.saldo = saldo
       
    def depositar(self, valor):
        self.saldo += valor
       
    def sacar(self, valor):
        self.saldo -= valor
       
    def gerar_extrato(self):
        print(f"Número: {self.numero}\nCPF: {self.cpf}\nSaldo: {self.saldo}")    

def main():
    c1 = Conta(1,1,"Joao",0)
    c1.depositar(300)
    c1.sacar(100)
    c1.gerar_extrato()

if __name__ == "__main__":
    main()


Caso queira que o saldo seja mostrado com 2 casas decimais para os centavos:

    def gerar_extrato(self):
        print("Número: {}\nCPF: {}\nSaldo: {:.2f}".format(self.numero, self.cpf, self.saldo))    

---------------------------------------------------------- ###

Em Python, não é obrigatório haver um comando para indicar quando o método deve ser finalizado. 
Porém, na orientação a objetos é bastante comum, como é o caso da programação procedural, retornar um valor a partir da análise do estado do objeto.


Conforme exemplificaremos adiante, o saque de um valor maior do que o saldo atual do cliente não é permitido; portanto, retorna a resposta “False” para o objeto que está executando o saque.

A seguir, apresentaremos como o método ficará e um exemplo de uso desse método:

class Conta():
    def __init__(self, numero, cpf, nomeTitular, saldo):
        self.numero = numero
        self.cpf = cpf
        self.nomeTitular = nomeTitular
        self.saldo = saldo
       
    def depositar(self, valor):
        self.saldo += valor
       
    def sacar(self,valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            return True
           
    def gerar_extrato(self):
        print(f"Número: {self.numero}\nCPF: {self.cpf}\nSaldo: {self.saldo}")    
       
def main():
    c1 = Conta(1,1,"Joao",0)
    c1.depositar(300)
    saque = c1.sacar(400)
    c1.gerar_extrato()
    print(f"O saque foi realizado? {saque}")
   
if __name__ == "__main__":
    main()

-------------------------------------------------------- ###
Uma classe pode ter mais de uma ou várias instâncias de objetos na memória, por exemplo:

Usando como exemplo o arquivo Conta.py:

class Conta():
    def __init__(self, numero, cpf, nomeTitular, saldo):
        self.numero = numero
        self.cpf = cpf
        self.nomeTitular = nomeTitular
        self.saldo = saldo
       
    def depositar(self, valor):
        self.saldo += valor
       
    def sacar(self,valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            return True
           
    def gerar_extrato(self):
        print(f"Número: {self.numero}\nCPF: {self.cpf}\nSaldo: {self.saldo}")    
       
def main():
    c1 = Conta(1,1,"Joao",0)
    c1.depositar(0)
    saque = c1.sacar(0)
    c1.gerar_extrato()
    print(f"O saque foi realizado? {saque}")

if __name__ == "__main__":
    main()


Para importar as informações do arquivo Conta.py:

from Conta import Conta
conta1 = Conta(1, 123, ‘Joao’,0)
conta2 = Conta(3, 456, ‘Maria’,0)

O resultado na memória após a execução é apresentado na figura seguinte:



Na memória, foram criados dois objetos diferentes referenciados pelas variáveis conta1 e conta2 do tipo conta. Os operadores “==” e “!=” comparam se as duas variáveis de referência apontam para o mesmo endereço de memória (CAELUM, 2020).

if (conta1 != conta2):
    print("Endereços diferentes de memória")

Pelo esquema da memória apresentado na figura anterior, realmente conta1 e conta2 apontam para endereços diferentes de memória. O comando “=” realiza o trabalho de igualar a posição de duas referências na memória.
Fazendo conta1 = conta2, podemos ver este resultado:

conta1 = conta2
if (conta1 == conta2):
    print("enderecos iguais de memoria")



Se executarmos os comandos referenciando o CPF da conta, verificaremos que eles, conforme mostramos acima, possuem os mesmos valores.

conta1.cpf
>>> 456

conta2.cpf
>>> 456

Esse exemplo pode ser estendido para realizar uma transferência de valores de uma conta para outra. A segunda conta precisa ser passada como parâmetro do método para a transferência ser executada.
O método precisa ficar da seguinte maneira:

class Conta:
  def __init__(self, numero, cpf, nomeTitular, saldo):
      self.numero = numero
      self.cpf = cpf
      self.nomeTitular = nomeTitular
      self.saldo = saldo

  def depositar(self, valor):
      self.saldo += valor

  def sacar(self,valor):
      if self.saldo < valor:
         return False
      else:
         self.saldo -= valor
         return True

  def gerarextrato(self):
      print(f"Número:{self.numero}\nCPF:{self.cpf}\nSaldo:{self.saldo}")

  def transfereValor(self,contaDestino,valor):
      if self.saldo < valor:
           return ("Não existe saldo suficiente")
      else:
           contaDestino.depositar(valor)
           self.saldo -= valor
      return("Transferencia Realizada")


Ao importar os contas 1 e 2 do arquivo Conta.py:

from Conta import Conta

conta1 = Conta(1, 123,'Joao',0)
conta2 = Conta(3, 456,'Maria',0)
conta1.depositar(1000)
conta1.transfereValor(conta2,500)
print(conta1.saldo)
print(conta2.saldo)

Em resumo, 1.000 reais foram depositados na conta1, enquanto foi realizada uma transferência no valor de 500 reais para a conta2. No final, o saldo ficou 500 para conta1 e 500 para conta2.

Devemos ressaltar que, no comando conta1.transfereValor(conta2,500), é passada uma referência da conta2 para o objeto contaDestino por meio de um operador “=”. O comando contaDestino = conta2 é executado internamente no Python.

--------------------------------------------------------------- ###
AGREGAÇÃO

Utilizando os exemplos anteriores de depósito, saque e transferência em um banco, para atender a novas necessidades do sistema de conta corrente do banco, agora é necessário adicionar uma funcionalidade para o gerenciamento de conta conjunta, ou seja, uma conta corrente pode ter um conjunto de clientes associados. Isso pode ser representado como uma agregação, conforme aponta o esquema a seguir. Uma observação: o losango na imagem tem a semântica da agregação.

Classe agrega 1 ou vários clientes.


Classe cliente.py :

class Cliente:
    def __init__(self,cpf,nome,endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco


Classe contas.py :

class Conta:
   def __init__(self, clientes, numero, saldo):
      self.clientes = clientes
      self.numero = numero
      self.saldo = saldo

   def depositar(self, valor):
      self.saldo += valor

   def sacar(self,valor):
      if self.saldo < valor:
         return False
      else:
         self.saldo -= valor
         return True

   def transfereValor(self,contaDestino,valor):
      if self.saldo < valor:
         return ("Não existe saldo suficiente")
      else:
         contadestino.depositar(valor)
         self.saldo -= valor
         return("Transferencia Realizada")

   def gerarsaldo(self):
      print(f"Número:{self.numero}\nSaldo: {self.saldo}")

Um programa testecontas.py deve ser criado para ser usado na instanciação dos objetos das duas classes e gerar as transações realizadas nas contas dos clientes.

Classe testecontas.py :

from contas import Conta
from clientes import Cliente

cliente1 = Cliente(123, "Joao", "Rua 1")
cliente2 = Cliente(345, "Maria","Rua 2")
conta1 = Conta([cliente1,cliente2], 1,0)
conta1.gerarsaldo()
conta1.depositar(1500)
conta1.sacar(500)
conta1.gerarsaldo()

Na linha número 6, é instanciado um objeto conta1 com dois clientes agregados, cliente1 e cliente2. Esses dois objetos são passados como parâmetros:
conta1 = Conta([cliente1,cliente2], 1,0)

---------------------------------- %%%

Exemplo do vídeo:

# Classe Salário (arquivo 1)
class Salario:
    def __init__(self, base, bonus):
        self.base = base
        self.bonus = bonus

     def salario_anual(self):
        return (self.base*12)+self.bonus

# Classe Empregado (arquivo 2)
class Empregado:
    def __init__(self, nome, idade, salario):
        self.nome = nome
        self.idade = idade
        self.salario_agregado = salario   # Agregação

    def salario_total(self):
        return self.salario_agregado.salario_anual()

# (arquivo 3 ???)
salario = Salario(10000, 700)
emp = Empregado( "Carlos", 46, salario )
print( emp.salario_total() )

>>> 120700

Simplificando:

# Classe Salário (arquivo 1)
class Salario:
    def __init__(self, base, bonus):
        self.base = base
        self.bonus = bonus
        self.salario_anual = (self.base*12)+self.bonus

# Classe Empregado (arquivo 2)
class Empregado:
    def __init__(self, nome, idade, salario):
        self.nome = nome
        self.idade = idade
        self.salario_agregado = salario   # Agregação
       
    def salario_total(self):
        return self.salario_agregado.salario_anual

# (arquivo 3 ???)
salario = Salario(10000, 700)
emp = Empregado( "Musashi", 46, salario )
print( emp.salario_total() )

-------------------------- %%%

Exemplo do outro video:

#Agregação (parte 1)
class Conta:
    def __init__(self, clientes, numero, saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo

    def depositar(self, valor):
        self.saldo += valor

    def sacar(self, valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            return True

#Agregação (parte 2)
class Cliente:
    def __init__(self,cpf,nome,endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco

c1 = Cliente("111111111-11", "Ana", "Rua das Marrecas")
c2 = Cliente("222222222-22", "Carlos", "Rua dos Gansos")

contaconjunta = Conta( [c1,c2], 24237891, 2500.00 )

print(contaconjunta.saldo)
print(c1.nome)
print(c2.nome)

print(f"{c1.nome} e {c2.nome} tem R$ {contaconjunta.saldo:.2f} de saldo.")

>>> 2500.0
>>> Ana
>>> Carlos
>>> Ana e Carlos tem juntos R$ 2500.00 de saldo.

Na agregação, os elementos (classes Conta e Cliente) são independentes. 

----------------------------------------------------------------- ###
COMPOSIÇÃO

Utilizando o exemplo de conta corrente, a classe Conta ainda não está completa de acordo com as necessidades do sistema de conta corrente do banco. Isso ocorre porque o banco precisa gerar extratos contendo o histórico de todas as operações realizadas para conta corrente.

Para isso, o sistema precisa ser atualizado para adicionar uma composição de cada conta com o histórico de operações realizadas. O diagrama a seguir representa a composição entre as classes Conta e Extrato. Essa composição representa que uma conta pode ser composta por vários extratos.
Uma observação: o losango preenchido tem a semântica da composição.

Classe Conta composta de 1 ou mais extratos.


A classe Extrato tem as responsabilidades de armazenar todas as transações realizadas na conta e de conseguir imprimir um extrato com a lista dessas transações.

Classe extrato.py :

class Extrato:
    def __init__(self):
        self.transacoes = [ ]

    def extrato(self, numeroconta):
        print(f"Extrato: {numeroconta} \n")
        for p in self.transacoes:
            print(f"{p[0]:15s} {p[1]:10.2f} {p[2]:10s} {p[3].strftime('%d/%b/%y')}")

A classe Conta possui todas as transações, como sacar, depositar e transferir_valor. Cada transação realizada deve adicionar uma linha ao extrato da conta.

A composição Conta->Extrato inclusive precisa ser inicializada no construtor da classe Conta, conforme exemplificava a figura anterior. No construtor de Extrato, foi adicionado um atributo transações, o qual foi inicializado para receber um array de valores – transações da conta.

A classe Conta alterada deve ficar da seguinte maneira:
(Classe conta.py composta)

import datetime
from Extrato import Extrato

class Conta:
    def __init__(self,clientes,numero,saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo
        self.data_abertura = datetime.datetime.today()
        self.extrato = Extrato ()

    def depositar(self, valor):
        self.saldo += valor
        self.extrato.transacoes.append(["DEPOSITO", valor, "Data",datetime.datetime.today ()])

    def sacar(self, valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            self.extrato.transacoes.append(["SAQUE", valor, "Data", datetime.datetime.today()])
            return True

    def transfereValor(self, contadestino, valor):
        if self.saldo < valor:
            return "Não existe saldo suficiente"
        else:
            contadestino.depositar(valor)
            self.saldo -= valor
            self.extrato.transacoes.append(["TRANSFERENCIA", valor, "Data", datetime.datetime.today()])
            return "Transferência Realizada"

    def gerarsaldo(self):
        print(f"Número: {self.numero}\nSaldo:{self.saldo}")

Com isso foi adicionado:
- Adição da linha nº 10 – criação de um atributo extrato, fazendo referência a um objeto Extrato:
• self.extrato = Extrato ()

- Adição das linhas nºs 14, 21 e 30 – adição de linhas ao array de transações do objeto Extrato por meio do atributo extrato:
• self.extrato.trasacoes.append(["DEPOSITO", valor, "Data",datetime.datetime.today ()])
• self.extrato.transacoes.append(["SAQUE", valor, "Data", datetime.datetime.today()])
• self.extrato.transacoes.append(["TRANSFERENCIA", valor, "Data", datetime.datetime.today()])

Execução no terminal:

from clientes import Cliente
from ContasClientesExtrato import Conta

cliente1 = Cliente("123","Joao","Rua X")
cliente2 = Cliente ("456","Maria","Rua W")
conta1 = Conta([cliente1,cliente2],1,2000)
conta1.depositar(1000)
conta1.sacar(1500)
conta1.extrato.extrato(conta1.numero)

Será impresso:

Extrato : 1
DEPÓSITO 1000.00 Data 14/Jun/2020
SAQUE 1500.00 Data 14/Jun/2020


O código completo ficaria assim:

import datetime

#arquivo cliente.py :
class Cliente:
    def __init__(self,cpf,nome,endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco

#arquivo extrato.py :
class Extrato:
    def __init__(self):
        self.transacoes = [ ]

    def imprimir(self, numeroconta):
        print(f"Extrato: {numeroconta} \n")
        for p in self.transacoes:
            print(f"{p[0]:15s} {p[1]:10.2f} {p[2]:10s} {p[3].strftime('%d/%b/%y')}")

#arquivo conta.py (composta)
#import datetime (já foi colocado lá no começo)
#from Extrato import Extrato

class Conta:
    def __init__(self,clientes,numero,saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo
        self.data_abertura = datetime.datetime.today()   #Não está sendo usado neste exemplo
        self.extrato = Extrato ()

    def depositar(self, valor):
        self.saldo += valor
        self.extrato.transacoes.append(["DEPOSITO", valor, "Data",datetime.datetime.today ()])

    def sacar(self, valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            self.extrato.transacoes.append(["SAQUE", valor, "Data", datetime.datetime.today()])
            return True

    def transfereValor(self, contadestino, valor):   #Não está sendo usado neste exemplo
        if self.saldo < valor:
            return "Não existe saldo suficiente"
        else:
            contadestino.depositar(valor)
            self.saldo -= valor
            self.extrato.transacoes.append(["TRANSFERENCIA", valor, "Data", datetime.datetime.today()])
            return "Transferência Realizada"

    def gerarsaldo(self):    #Não está sendo usado neste exemplo
        print(f"Número: {self.numero}\nSaldo:{self.saldo}")

#from clientes import Cliente
#from ContasClientesExtrato import Conta

cliente1 = Cliente("123","Joao","Rua X")
cliente2 = Cliente ("456","Maria","Rua W")

conta1 = Conta([cliente1,cliente2],1,2000.00)

conta1.depositar(1000)
conta1.sacar(1500)
conta1.extrato.imprimir(conta1.numero)

>>> Extrato: 1 
>>>
>>> DEPOSITO             1000.00 Data            14/Oct/23 
>>> SAQUE                   1500.00 Data            14/Oct/23

-----------------------------------

Exemplo do video:

#Composição:
class Extrato:
    def __init__(self):
        self.transacoes = [ ]
       
    def imprimir(self):
        for p in self.transacoes:
            print(p[0], p[1])

class Conta:
    def __init__(self, clientes, numero, saldo):
        self.clientes = clientes
        self.numero = numero
        self.saldo = saldo
        self.extrato = Extrato()

    def depositar(self, valor):
        self.saldo += valor
        self.extrato.transacoes.append(["DEPOSITO", valor])
   
    def sacar(self, valor):
        if self.saldo < valor:
            return False
        else:
            self.saldo -= valor
            self.extrato.transacoes.append(["SAQUE", valor])
            return True

c1 = Cliente("111111111-11", "Ana", "Rua das Marrecas")
c2 = Cliente("222222222-22", "Carlos", "Rua dos Gansos")
conta = Conta( [c1,c2], 24237891, 2500.00 )

conta.depositar(1000)
conta.sacar(500)
conta.extrato.imprimir()

>>> DEPOSITO 1000 
>>> SAQUE 500

--------------------------------------------------------------- ###
ENCAPSULAMENTO

O encapsulamento é fundamental para a manutenção da integridade dos objetos e a proibição de qualquer alteração indevida nos valores dos atributos (estado) do objeto (CAELUM, 2020). Esse ponto foi fundamental para a popularização da orientação aos objetos: reunir dados e funções em uma única entidade e proibir a alteração indevida dos atributos.

Exemplo
No caso da classe Conta, imagine que algum programa tente realizar a seguinte alteração direta no valor do saldo:
conta1.saldo = -200

Esse comando viola a regra de negócio do método sacar(), que indica a fim de não haver saque maior que o valor e de deixar a conta no negativo (estado inválido para o sistema).

Método sacar no estado inválido:

def sacar(self, valor):
  if self.saldo < valor:
     return False
  else:
     self.saldo -= valor
     self.extrato.transacoes.append(["SAQUE", valor, "Data", datetime.datetime.today()])
     return True

Como proibir alterações indevidas dos atributos em Python? 

Atributos públicos e privados

Para seguir o encapsulamento e proibir alterações indevidas dos atributos, deve-se definir atributos privados para a classe. Por default, em Python, os atributos são definidos como público, ou seja, podem ser acessados diretamente sem respeitar o encapsulamento - acesso feito apenas por meio de métodos do objeto.

Para tornar um atributo privado, é preciso iniciá-lo com dois underscores (‘__’). E qual seria o retorno do interpretador ao se acessar um atributo privado para classe Conta? Um erro seria gerado.

class Conta:
    def __init__(self, numero, saldo):
        self.__numero = numero
        self.__saldo = saldo

def main():
    conta = Conta(1, 1000)
    saldo = conta.__saldo
   
if __name__ == "__main__":
    main()

No exemplo acima existe uma classe chamada Conta com todos os atributos privados.

É importante ressaltar que, em Python, não há realmente atributos privados. O interpretador renomeia o atributo privado para _nomedaClasse__nomedoatributo.

O atributo, portanto, ainda pode ser acessado. Embora ele funcione, isso é considerado uma prática que viola o princípio de encapsulamento da orientação a objetos.

conta._Conta__saldo
>>> 1000


Exemplo completo sem atributos privados:
class Conta:
    def __init__(self, numero, saldo):
        self.numero = numero
        self.saldo = saldo
c1 = Conta(1, 1000)
c1.saldo

Exemplo completo com atributos privados:
class Conta:
    def __init__(self, numero, saldo):
        self.__numero = numero
        self.__saldo = saldo
c1 = Conta(1, 1000)
c1._Conta__saldo

Na prática, deve haver uma disciplina para que os atributos como __ ou _ definido nas classes não sejam acessados diretamente.

---------------------------------------------------------------- ###
Decorator @property

Uma estratégia importante disponibilizada pelo Python são as properties. Utilizando o decorator property nos métodos, mantém-se os atributos como protegidos, os quais, por sua vez, são acessados apenas por meio dos métodos “decorados” com property (CAELUM, 2020).

No caso da classe Conta, não se pode acessar o atributo saldo (privado) para leitura. Com o código, ele será acessado pelo método decorator @property.

Definição de uma propriedade:

@property
def saldo(self):
   return self._saldo

Os métodos decorados com a property @setter forçam todas alterações de valor dos atributos privados a passar por esses métodos.

Notação:
@< nomedometodo >.setter

Definição de um método setter:

@saldo.setter
def saldo(self, saldo):
  if (self.saldo < 0):
    print(“saldo inválido”)
  else:
    self._saldo = saldo

Os properties ajudam a garantir o encapsulamento no Python.

Uma boa prática implementada em todas as linguagens orientadas a objetos será a de definir esses métodos apenas se realmente houver regra de negócios diretamente associada ao atributo. Caso não haja, deve-se deixar o acesso aos atributos conforme definido na classe.

No código a seguir, demonstraremos como acessar os métodos decorados com @property e @< nomedometodo >.setter :

class Conta:
    def __init__(self, numero):
        self.numero = numero
        self._saldo = 0
       
    @property
    def saldo(self):
        return self._saldo
   
    @saldo.setter
    def saldo(self, saldo):
        if saldo < 0:
            print ("saldo inválido")
        else:
            self._saldo = saldo
           
def main():
    conta = Conta(1)
    conta.saldo = 1000 # usando o @saldo.setter
    print(f'saldo da conta = {conta.saldo}') # usando o @property
   
if __name__ == "__main__":
    main()

-------------------------------- %%%
Exemplo do video:

# Atributo:
class Pessoa:
    _contador = 0  #atributo estático

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade
        Pessoa._contador += 1

    def imprimir(self):
        print(self.nome," tem ",self.idade," ano(s)")

# Propriedade:
    @property
    def Contador(self):
        return type(self)._contador    #é o mesmo que Pessoa._contador

p = Pessoa("Carlos", 18)
p = Pessoa("Maria", 23)
p = Pessoa("Jorge", 35)

print(p.contador)  #Opção 1
print(Pessoa._contador)  #Opção 2

>>> 3
>>> 3

------------------------------ %%%

class Pessoa:
    _contador = 0  #atributo estático

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade
        Pessoa._contador += 1

p1 = Pessoa("Carlos", 18)
p2 = Pessoa("Maria", 21)
p3 = Pessoa("José", 35)
print(Pessoa._contador)  

>>> 3

------------------------------- %%%
# Atributo
class Pessoa:
    _contador = 0  #atributo estático

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade
        Pessoa._contador += 1

p1 = Pessoa("Carlos", 18)
p2 = Pessoa("Maria", 23)
p3 = Pessoa("Jorge", 35)
print(p1._contador)  

>>> 3

---------------------- %%%

class Pessoa:

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def imprimir(self):
        print(self.nome," tem ",self.idade," ano(s)")

p1 = Pessoa("Carlos", 18)
p2 = Pessoa("Maria", 18)
Pessoa.imprimir(p2)

--------------------------------------------------------- ###
ATRIBUTOS DE CLASSE

Existem algumas situações em que os sistemas precisam controlar valores associados à classe, e não aos objetos (instâncias) das classes. É o caso, por exemplo, ao se desenvolver um aplicativo de desenho, como o Paint, que precisa contar o número de círculos criados na tela.
Inicialmente, a classe Círculo vai ser criada:

class Circulo:
  def __init__(self,pontox,pontoy,raio):
    self.pontox = pontox
    self.pontoy = pontoy
    self.raio = raio

No entanto, conforme mencionamos, é necessário controlar a quantidade de círculos criados.

Classe Círculo com atributo de classe:

class Circulo:
    total_circulos = 0
   
    def __init__(self,pontox, pontoy, raio):
        self.pontox = pontox
        self.pontoy = pontoy
        self.raio = raio
        self.total_circulos +=1

Na linha 2, indicamos para o interpretador que seja criada uma variável total_circulos. Como a declaração está localizada antes do init, o interpretador “entende” que se trata de uma variável de classe, ou seja, que terá um valor único para todos objetos da classe.
Na linha 8, o valor da variável de classe a cada instanciação de um objeto da classe Círculo é atualizado.

from Circulo import Circulo

circ1 = Circulo(1,1,10)
circ1.total_circulos
>>> 1

circ2 = Circulo(2,2,20)
circ2.total_circulos
>>> 2

Circulo.total_circulos
>>> 2

Esse acesso direto ao valor da variável de classe não é desejado. Deve-se colocar a variável com atributo privado com o underscore ‘_’.
Como isso fica agora? O resultado será apresentado adiante.

Classe Círculo com atributo de classe privado:

class Circulo:

  _total_circulos = 0

  def __init__(self,pontox, pontoy, raio):
    self.pontox = pontox
    self.pontoy = pontoy
    self.raio = raio
    circulo._total_circulos += 1


Repetindo o mesmo código:

from Circulo import Circulo

circ1 = Circulo(1,1,10)
circ1._total_circulos
>>> 1

Circulo.total_circulos
>>> Traceback (most recent call last):
>>> File '<input>', line 1, in <module>
>>> AttributeError: type object 'Circulo' has no attribute 'total_circulos'

-------------------------------------------------------------- ###
METODOS PUBLICOS E PRIVADOS

As mesmas regras definidas para atributos são válidas para os métodos das classes. Desse modo, o método pode ser declarado como privado, mesmo que ainda possa ser chamado diretamente como se fosse um método público.

Os dois underscores antes do método indicam que ele é privado.

Método privado:

class Conta:

  def __init__(self,clientes,numero,saldo):
    self.clientes = clientes
    self.numero = numero
    self.saldo = saldo
   
  def __gerarsaldo(self):
    print(f"Número: {self.numero}\nSaldo:{self.saldo}")

No código acima, foi definido o método __gerarsaldo como privado. Portanto, ele pode ser acessado apenas internamente pela classe Conta.

Um dos principais padrões da orientação a objetos consiste nos métodos públicos e nos atributos privados. Desse modo, respeita-se o encapsulamento.

class Conta:

  def __init__(self, numero, nome, saldo):
    self.numero = numero
    self.nome = nome
    self.saldo = saldo

  def __gerarsaldo(self):
    print(f"Número: {self.numero}\nNome: {self.nome}\nSaldo:{self.saldo}")

conta1 = Conta(1, "Pedro", 200)
conta1._Conta__gerarsaldo()

--------------------------- %%%

Quando é privado (private), ele só pode ser visto no interior da sua classe.
Quando é público (public), todos podem ver (inclusive de classes diferentes).
Quando é protected ele pode também ser acessado pelas classes filhos.

Python: (coloca-se o underscore _ antes para tornar privado)
class Cliente:
    def __init__(self):
        self.nome = "";      #público
        self._saldo = 0.0;      #privado


-------------------------------------------------------------------- ###
MÉTODOS DE CLASSE
@classmethod

Os métodos de classe são a maneira indicada para se acessar os atributos de classe. Eles têm acesso diretamente à área de memória que contém os atributos de classe.

O esquema é apresentado nesta imagem:


Para definir um método como estático, deve-se usar o decorator @classmethod. Observe agora a classe Círculo alterada:

class Circulo:
    _total_circulos = 0

    def __init__(self,pontox, pontoy, raio):
        self.pontox = pontox
        self.pontoy = pontoy
        self.raio = raio
        type(self)._total_circulos +=1

    @classmethod
    def get total_circulos(cls):
        return cls._total_circulos

Na linha 11, é criado o parâmetro cls como referência para classe. Na linha 12, é retornado o valor do atributo de classe _total_circulos.

O código completo ficaria:

#arquivo 1:
class Circulo:
    _total_circulos = 0

    def __init__(self, pontox, pontoy, raio):
        self.pontox = pontox
        self.pontoy = pontoy
        self.raio = raio
        type(self)._total_circulos += 1

    @classmethod
    def get_total_circulos(cls):
        return cls._total_circulos

#arquivo 2:
#from Circulo import Circulo
circ1 = Circulo(1,1,10)
print(circ1._total_circulos)

circ2 = Circulo(2,2,20)
print(circ2._total_circulos)

------------------------------- %%%

Exemplo do video:

class Pessoa:
    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    # Método Estático: verificar se é maior de idade
    @staticmethod
    def ehMaiorIdade(idade):
        return idade >= 18

pessoa1 = Pessoa("Maria", 16)

print(pessoa1.idade)

# imprimir o resultado
print(pessoa1.ehMaiorIdade(pessoa1.idade))


Outra forma:

from datetime import date

class Pessoa:
    def __init__(self, nome, ano):
        self.nome = nome
        self.ano = ano

    def apartirAnoNascimento(self):
        return (date.today().year - self.ano)

    # Método Estático: verificar se é maior de idade
    @staticmethod
    def ehMaiorIdade(idade):
        if idade >= 18:
          return ("É maior de idade.")
        else:
          return ("É menor de idade.")

pessoa1 = Pessoa("Ana", 1996)
pessoa1.ehMaiorIdade(pessoa1.apartirAnoNascimento())


Sem usar @staticmethod:

from datetime import date

class Pessoa:
    def __init__(self, nome, ano):
        self.nome = nome
        self.ano = ano
        self.idade = date.today().year - self.ano

    def ehMaiorIdade(self):
        if self.idade >= 18:
          return ("É maior de idade.")
        else:
          return ("É menor de idade.")

pessoa1 = Pessoa("Ana", 1996)
print(pessoa1.idade)
print(pessoa1.ehMaiorIdade())

pessoa2 = Pessoa("Carlos", 2012)
print(pessoa2.idade)
print(pessoa2.ehMaiorIdade())

----------------------------- %%%

Exemplo do outro video:

#Padrão Factory
class NomeCompleto:
    def __init__(self, nome, sobrenome):
        self.nome = nome
        self.sobrenome = sobrenome

    @classmethod
    def fromString(cls, texto):
        nome, sobrenome = map(str, texto.split(" "))
        objeto = cls(nome, sobrenome)
        return objeto

registro1 = NomeCompleto.fromString("Luiz Braga")
print(registro1.nome)
print(registro1.sobrenome)

>>> Luiz
>>> Braga

No exemplo acima foi usado o map e split para dividir o nome e sobrenome. Por exemplo:

nomecompleto = "Luiz Braga"

nome, sobrenome = map(str, nomecompleto.split(" "))

print(nome)
print(sobrenome)

-------------------------------------------------------------------- ###
METODOS ESTATICOS 
@staticmethod

São métodos que podem ser chamados sem haver uma referência para um objeto da classe, ou seja, não existe a obrigatoriedade da instanciação de um objeto da classe. O método pode ser chamado diretamente:

import math

class MetodoEstatico:

    @staticmethod
    def RaizQuadrada(x):
        return math.sqrt(x)

MetodoEstatico.RaizQuadrada(20)
>>> 4.47213595499958

No caso acima, o método sqrt da classe Math foi chamado sem que um objeto da classe Math fosse instanciado.

Atenção!
Os métodos estáticos não são uma boa prática na programação orientada a objetos. Eles devem ser utilizados apenas em casos especiais, como o de classes de log em sistemas.

---------------------------------------- %%%

Exemplo do video:

class NomeCompleto:
    def __init__(self, nome, sobrenome):
        self.nome = nome
        self.sobrenome = sobrenome

    @classmethod   #Padrão Factory
    def fromString(cls, texto):
        nome, sobrenome = map(str, texto.split(" "))
        objeto = cls(nome, sobrenome)
        return objeto

    @staticmethod   #Método estático
    def isValid(texto):
        nomes = texto.split(" ")
        return len(nomes) > 1

registro1 = NomeCompleto.fromString("Luiz Braga")

print(registro1.nome)  #será impresso = Luiz
print(registro1.sobrenome)   #será impresso = Braga

print(NomeCompleto.isValid("Luiz Braga"))    #será impresso = True
print(NomeCompleto.isValid("Carlos"))    #será impresso = False

----------------------------------------------------------- ###
@classmethod vs @staticmethod

O decorator @classmethod permite que os atributos de classe sejam alterados na área de memória.

O decorator @classmethod fica armazenado na mesma área de memória dos atributos de classe. Portanto, ele pode alterar os valores dos atributos de classe.

---------------------------------------------------------- ###
SELF

A palavra "self" deve ser fornecida como argumento em todos os métodos públicos de instâncias.

A palavra “self” necessita ser declarada como primeiro argumento em todos os métodos de instâncias de uma classe, pois indica uma referência a um objeto da classe. Quando um método da classe é chamado, a referência do objeto que o invocou é passada ao argumento self do método em questão e então o interpretador do Python é capaz de identificar exatamente qual dos objetos instanciados da classe está executando o método que foi chamado/invocado.

---------------------------------------------------------- ###
__INI__()

Diferentemente de outras linguagens de programação orientadas a objetos, o Python constrói os objetos em duas etapas. A primeira etapa é utilizada com a palavra reservada __new__, a qual, em seguida, executa o método __init__.

O __new__ cria a instância e é utilizado para alterar as classes dinamicamente nos casos de sistemas que envolvam metaclasses e frameworks. Após __new__ ser executado, esse método chama o __init__ para a inicialização da classe como seus valores iniciais (MENEZES, 2019).

Para efeitos de comparação com outras linguagens de programação (e por questões de simplificação), consideraremos o __init__ como o construtor da classe. Portanto, toda vez que instanciarmos objetos da classe conta, o método __init__ será chamado.

O construtor __init__() NÃO é um método obrigatorio na classe.


Em Python, não é obrigatório ter um método construtor na classe. Isso ocorrerá apenas se for necessária alguma ação na construção do objeto, como a inicialização e/ou a atribuição de valores.

Segue um exemplo de uma classe sem um método construtor:

class A():
    def função(self):
        print("texto de exemplo")

def main():
    obj_A = A() # Objeto sendo instanciado
    obj_A.função()

if __name__ == "__main__":
    main()


Outra forma (sem o if):

class A():
    def função(self):
        print("texto de exemplo")

def main():

    obj_A = A()
    obj_A.função()

main()


Outra forma (simplificada):

class A():

    def função(self):
        print("texto de exemplo")

obj_A = A()
obj_A.função()

-------------------------------------------------------------------------- ###
IMPORTAR CLASSES 

Para importar classes de outro arquivo .py para um novo arquivo:

from (nome do arquivo) import (nome da classe)

Exemplo 1:

#arquivo pessoa.py
class N:
    def __init__(self, nome):
        self.nome = nome

#arquivo imprimir.py
from pessoa import N

objeto = N("José")

print( objeto.nome )
>>> José

--------

Exemplo 2:

#arquivo vogais.py:
class Vog:
    def __init__(self, vogal):
        self.vogal = vogal

#arquivo numeros.py:
from vogais import Vog

class Num:
    def __init__(self, numero):
        self.numero = numero

objetoV = Vog("a")
objetoN = Num(3)

print( objetoV.vogal )
print( objetoN.numero )
>>> a
>>> 3

--------

Exemplo 3:

#arquivo cliente.py:
class Cliente:
    def __init__(self,cpf,nome,endereco):
        self.cpf = cpf
        self.nome = nome
        self.endereco = endereco


#arquivo terminal.py:
from cliente import Cliente

c1 = Cliente("123","Joao","Rua X")
print(c1.cpf)

>>> 123

---------------------------------------------------------------------- ###
CLASSES ABSTRATAS

Definir uma classe abstrata é uma característica bastante utilizada pela programação orientada a objetos. Esse é um tipo de classe que não pode ser instanciado durante a execução do programa orientado a objetos, ou seja, não pode haver objetos dessa classe executados na memória.

O termo “abstrato” remete a um conceito do mundo real, considerando a necessidade apenas de objetos concretos no programa. A classe abstrata se encaixa perfeitamente no problema do sistema de conta corrente do banco. Nesse sistema, o banco não quer tratar de clientes do tipo ContaCliente, e sim apenas dos objetos do tipo ContaComum e Conta VIP.

Houve apenas a adição de esteréotipo <> para indicar que ContaCliente é uma classe abstrata. O Python utiliza um módulo chamado abc para definir uma classe como abstrata, a qual será herdeira da superclasse ABC (Abstract Base Classes).
Toda classe abstrata é uma subclasse da classe ABC (CAELUM, 2020). Para tornar a classe Conta Cliente abstrata, muda-se sua definição para:

from abc import ABC
class ContaCliente(ABC):

Para uma classe ser considerada abstrata, ela precisa ter pelo menos um método abstrato. Esse método pode ter implementação, embora isso não faça sentido, pois ele deverá obrigatoriamente ser implementado pelas subclasses. Em nosso exemplo, como não teremos o ContaCliente, tal conta não terá Calculo do rendimento.

O decorator @abstractmethod indica para a linguagem que o método é abstrato (STANDARD LIBRARY, 2020), o que ocorre no código adiante:

from abc import ABC, abstractmethod

class ContaCliente(ABC):
    def __init__(self, numero, IOF, IR, valorinvestido, taxarendimento):
        self.numero = numero
        self.IOF =   IOF
        self.IR = IR
        self.valorinvestido = valorinvestido
        self.taxarendimento = taxarendimento

    @abstractmethod
    def CalculoRendimento(self):
        pass

Quando se tentar instanciar um objeto da classe, será obtido um erro indicando que essa classe não pode ser instanciada. Faça o teste! No emulador , insira a linha de código abaixo e clique em Executar.

cc1 = ContaCliente(1,0.1,0.25,0.1)

Será impresso:
TypeError: Can't instantiate abstract class ContaCliente with abstract method CalculoRendimento

Apenas as subclasses ContaComum e ContaVIP podem ser instanciadas.

Atenção!
As classes mencionadas devem obrigatoriamente implementar os métodos. Caso contrário, elas serão classes abstratas e delegarão para as suas subclasses a implementação concreta do método abstrato.
Fica como sugestão criar as classes concretas ContaComum e ContaVIP sem implementar o método abstrato do superclasse ContaCliente.

/////////////////////////////////////////////////////////////////////////////////// &&&
ISSUBCLASS

Para saber se uma classe é derivada ou filha de outra classe:

issubclass( f , p )

f = classe Filho
p = classe Pai

Caso seja verdadeiro, será impresso True.
Caso seja falso, será impresso False.

Exemplo de herança:

class Pai:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def somar(self):
        return self.a + self.b
    def multiplicar(self):
        return self.a * self.b

class Filho(Pai):
    def subtrair(self):
        return self.a - self.b
    def dividir(self):
        return self.a / self.b

print(issubclass(Filho, Pai)) #Para saber se a classe Filho é derivada da classe Pai

>>> True

----------------

class Pai:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    def somar(self):
        return self.a + self.b

class Mae:
    def __init__(self, c, d):
        self.c = c
        self.d = d
    def somar(self):
        return self.c + self.d

class Filho(Pai):
    def subtrair(self):
        return self.a - self.b
    def dividir(self):
        return self.a / self.b

print(issubclass(Filho, Mae)) #Para saber se a classe Filho é derivada da classe Mae

>>> False

//////////////////////////////////////////////////////////////////// &&&
SOBRECARGA

Exemplo:

def somar (x, y, z = 0):  # x = 0 , y = 0 e z = 0
    return x + y + z

print(somar(20, 30))   # x = 20 , y = 30 e z = 0
print(somar(20, 30, 40))   # x = 20 , y = 30 e z = 40

>>> 50
>>> 90

Se for passado o terceiro parâmetro (z), será feita a soma entre x e y e z (20 + 30 + 40).

Se não for passado o terceiro parâmetro (z), o sistema entenderá que z = 0 (valor que foi especificado dentro da função somar() ) e será feita a soma apenas entre x e y (20 + 30).

Outro exemplo:

def somar (x, y, z = 2):  # x = 2 , y = 2 e z = 2
    return x + y + z

print(somar(20, 30))   # x = 20 , y = 30 e z = 2
print(somar(20, 30, 40))   # x = 20 , y = 30 e z = 40

>>> 52
>>> 90


/////////////////////////////////////////////////////////////////////////// &&&
FUNÇÕES PURAS
Paradigma funcional

São aquelas que dependem apenas dos parâmetros de entrada para gerar uma saída. 

Elas sempre retornam um valor, um objeto ou outra função. Em qualquer ponto do programa, ao chamar uma função pura, com os mesmos parâmetros, devemos obter sempre o mesmo resultado.

Veja os dois scripts, funcao1.py e funcao2.py, nos dois emuladores a seguir:

# arquivo funcao1.py
valor = 20

def multiplica(fator):
    global valor
    valor = valor * fator
    print("Resultado", valor)

def main():
    numero = int(input())
    multiplica(numero)
    multiplica(numero)
  
if __name__ == "__main__":
    main()

Foi digitado o número 3 na tela de input.
>>> Resultado 60 
>>> Resultado 180

Quando um script python é executado, a variável reservada NAME referente a ele tem valor igual à "__main__".
Nesse caso, a condição do IF a seguir será TRUE, então o que está no corpo do IF será executado.
No caso, é um chamado ao método main do script.

# arquivo funcao2.py
valor = 20

def multiplica(valor, fator):
    valor = valor * fator
    return valor

def main():
    numero = int(input())
    print("Resultado", multiplica(valor, numero))
    print("Resultado", multiplica(valor, numero))

if __name__ == "__main__":
    main()

Foi digitado o número 3 na tela de input.
>>> Resultado 60 
>>> Resultado 60

Agora observe a seguir o que ocorreu em cada um dos scripts:

- funcao1.py
Definimos uma função chamada multiplica, que multiplica a variável global valor por um fator passado como parâmetro. O valor do resultado é atribuído à variável valor novamente (valor = valor * fator), que é impresso em seguida (print("Resultado", valor)).
Por exemplo, se chamarmos a função multiplica pela primeira vez, passando o valor 3 como parâmetro, obteremos a saída “Resultado 60”. Como modificamos a própria variável global valor no corpo da função, ao chamarmos novamente a função multiplica passando novamente o 3 como parâmetro, obtemos um resultado de saída diferente: “Resultado 180”.
Além de não depender apenas dos parâmetros, essa função não retorna valor algum. A função multiplica deste script não é pura.
Verifique por si mesmo! No código, delete a instrução pass (numero =int(input())) e dentro da função main chame duas vezes a função multiplica com um mesmo valor como parâmetro (exemplo: multiplica(3)). 

- funcao2.py
Utilizamos a variável valor e a função numero como parâmetros para a função multiplica. O valor da variável numero será recebido via teclado, por meio da função nativa input.
As duas vezes em que executamos essa função (print("Resultado", multiplica(valor, numero))), retornarão o mesmo valor. Por exemplo, se o valor de numero for 3, ambas as saídas do script serão: “Resultado 60”.
A função multiplica deste script é um exemplo de função pura, pois depende apenas de seus parâmetros para gerar o resultado, e não acessa ou modifica nenhuma variável externa à função e retorna um valor.
Verifique por si mesmo! Informe um número inteiro no campo Input do segundo código, como valor a ser atribuído à variável numero (por meio da função input: numero = int(input())).

///////////////////////////////////////////////////////////////////// &&&
DADOS IMUTÁVEIS
Paradigma funcional

São aqueles que não podem ser alterados após sua criação. Apesar do Python disponibilizar algumas estruturas de dados imutáveis, como as tuplas, a maioria é mutável. 

Na programação funcional, devemos tratar todos os dados como imutáveis!

As funções puras devem utilizar apenas os parâmetros de entrada para gerar as saídas. Além dessa característica, as funções puras não podem alterar nenhuma variável fora de seu escopo.

Observe os scripts funcao3.py e funcao4.py a seguir, em que passamos a lista valores como argumento para a função altera_lista. Lembre-se de que, no Python, ao passar uma lista como argumento, apenas passamos sua referência, ou seja, qualquer mudança feita no parâmetro dentro da função, também altera a lista original. 

Nos exemplos abaixo são informados no campo Input os números inteiros a serem atribuídos à lista valores. Os elementos devem ser separados por 1 espaço em branco, por exemplo: 10 20 30.

# arquivo funcao3.py

# captando os valores do campo Input
valores = input()

# separando os valores pelo espaço em branco e transformando-os em uma lista de inteiros
valores = [int(i) for i in valores.split()]

def altera_lista(lista):
    lista[2] = lista[2] + 10
    return lista

def main():
    print("Nova lista", altera_lista(valores))
    print("Nova lista", altera_lista(valores))

if __name__ == "__main__":
    main()

No input foi digitado:
>>> 2 3 4

Então foi impresso:
>>> Nova lista [2, 3, 14]
>>> Nova lista [2, 3, 24]

---------------

# arquivo funcao4.py

# captando os valores do campo Input
valores = input()

# separando os valores pelo espaço em branco e transformando-os em uma lista de inteiros
valores = [int(i) for i in valores.split()]

def altera_lista(lista):
    nova_lista = list(lista)
    nova_lista[2] = nova_lista[2] + 10
    return lista

def main():
    print("Nova lista", altera_lista(valores))
    print("Nova lista", altera_lista(valores))

if __name__ == "__main__":
    main()

No input foi digitado:
>>> 2 3 4

Então foi impresso:
>>> Nova lista [2, 3, 4]
>>> Nova lista [2, 3, 4]

Na programação funcional, devemos evitar alterar qualquer dado que já tenha sido criado. No exemplo anterior, no script funcao3.py, ao alterar o terceiro elemento do parâmetro lista (lista[2] = lista[2] + 10), alteramos também a variável global valores.

Com isso, ao chamar a mesma função duas vezes (print("Nova lista", altera_lista(valores))), com, teoricamente, o mesmo parâmetro, obtemos um efeito indesejável, resultando em saídas diferentes, como pode ser nos dois resultados diferentes que são impressos:
>>> Nova lista [2, 3, 14]
>>> Nova lista [2, 3, 24]

No exemplo do script funcao4.py, muito similar ao script funcao3.py, ao invés de alterarmos o valor do próprio parâmetro, criamos uma cópia dele (nova_lista = list(lista)), sendo assim, não alteramos a variável valores e obtemos o mesmo resultado para as duas chamadas da função (print("Nova lista", altera_lista(valores))), fato observado no resultado idêntico que é impresso nas duas linhas:
>>> Nova lista [2, 3, 4]
>>> Nova lista [2, 3, 4]

-------------------------------- %%%

As funções puras e dados imutáveis buscam evitar os efeitos indesejáveis, como por exemplo, dois ou mais resultados diferentes usando exatamente a mesma entrada. 

Na terminologia de programação funcional, chamamos isso de efeito colateral (side effect). 
Além de evitar o efeito colateral, a programação funcional evita a dependência do estado de um programa.

A dependência apenas dos parâmetros para gerar saídas garante que o resultado será sempre o mesmo, independentemente do estado da aplicação, por exemplo, valores de outras variáveis. Ou seja, não teremos diferentes comportamentos para uma função baseado no estado atual da aplicação.

Ao garantir que uma função utilizará apenas os dados de entrada para gerar um resultado e que nenhuma variável fora do escopo da função será alterada, temos a certeza de que não teremos um problema escondido, ou efeito colateral em nenhuma outra parte do código.

O objetivo principal da programação funcional não é utilizar funções puras e dados imutáveis, mas sim evitar o efeito colateral.

///////////////////////////////////////////////////////////////////////////// &&&
FUNÇÕES DE ORDEM SUPERIOR
Paradigma funcional

Na programação funcional, é muito comum utilizar funções que aceitem outras funções, como parâmetros ou que retornem outra função.

Essas funções são chamadas de funções de ordem superior (higher order function).

No exemplo a seguir, script funcao5.py, vamos criar uma função de ordem superior chamada multiplicar_por. Ela será utilizada para criar e retornar novas funções.

Essa função, ao ser chamada com um determinado multiplicador como argumento, retorna uma nova função multiplicadora por aquele multiplicador e que tem como parâmetro o número a ser multiplicado (multiplicando).Veja o seguinte código:

# arquivo funcao5.py
def multiplicar_por(multiplicador):
    def multi(multiplicando):
        return multiplicando * multiplicador
    return multi

def main():
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2))

    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

if __name__ == "__main__":
    main()

>>> 10
>>> 20
>>> 5
>>> 10

Dentro da função “pai” multiplicar_por, definimos a função multi (def multi(multiplicando):), que espera um parâmetro chamado multiplicando, que será multiplicado pelo multiplicador passado como parâmetro para a função “pai”.

Ao chamar a função multiplicar_por com o argumento 10 (multiplicar_por_10 = multiplicar_por(10)), definimos a função interna multi como:

def multi(multiplicando):
    return multiplicando * 10

Essa função é retornada e armazenada na variável multiplicar_por_10 (multiplicar_por_10 = multiplicar_por(10)), que nada mais é que uma referência para a função multi recém-criada.

Dessa forma, podemos chamar a função multiplicar_por_10, passando um número como argumento, o multiplicando, para ser multiplicado por 10 (print(multiplicar_por_10(1))  /  print(multiplicar_por_10(2))), produzindo os resultados 10 e 20.

Da mesma forma, criamos a função multiplicar_por_5, passando o número 5 como argumento para a função multiplicar_por (multiplicar_por_5 = multiplicar_por(5)), que recebe uma referência para a função:

def multi(multiplicando):
    return multiplicando * 5

Com isso, podemos utilizar a função multiplicar_por_5 para multiplicar um número por 5 (linhas 13 e 14):
print(multiplicar_por_5(1))
print(multiplicar_por_5(2))

-------------------------------------------

Esse código pode ser substituído com função lambda:

# arquivo funcao5.py  (alterada com lambda)
def multiplicar_por(multiplicador):
    return lambda multiplicando: multiplicador * multiplicando

def main():
    multiplicar_por_10 = multiplicar_por(10)
    print(multiplicar_por_10(1))
    print(multiplicar_por_10(2))
 
    multiplicar_por_5 = multiplicar_por(5)
    print(multiplicar_por_5(1))
    print(multiplicar_por_5(2))

if __name__ == "__main__":
    main()

----------------------------------------------------------------------

Versão simplificada de função de ordem superior:
(sem usar função lambda)

def Função1(x):
    def Função2(y):
        return x + y
    return Função2

variavel = Função1(10)
print(variavel(5))
>>> 15

------------

Versão simplificada de função de ordem superior com 1 variável anônima (y):
(usando função lambda)

def Função1(x):
    return lambda y : x + y

variavel = Função1(10)
print(variavel(5))
>>> 15

--------------

Versão simplificada de função de ordem superior com 2 variáveis anônimas (y e z):
(usando função lambda)

def Função1(x):
    return lambda y , z : x + y + z

variavel = Função1(10)
print(variavel(5, 3))
>>> 18

//////////////////////////////////////////////////////////////////// &&&
BOAS PRATICAS DA PROGRAMAÇÃO FUNCIONAL

- Não utilizar loops:
Outra regra, ou boa prática, da programação funcional é não utilizar laços (for e while), mas sim composição de funções ou recursividade. 
A função lambda exerce um papel fundamental nisso.

Para facilitar a composição de funções e evitar loops, o Python disponibiliza diversas funções e operadores.

As funções internas mais comuns são map e filter.

/////////////////////////////////////////////////////////////////// &&&
GIL (global interpreter lock)

No CPython (implementação principal da linguagem de programação Python, escrita em linguagem C), GIL existe para proteger o acesso aos objetos da linguagem.

Isso acontece objetivando a prevenção para que múltiplas threads não possam executar os bytecodes do Python de uma vez. Essa “trava” é necessária, pois visa garantir a integridade do interpretador, uma vez que o gerenciamento de memória no CPython não é thread-safe.

Na prática, para um mesmo processo, o GIL só permite executar uma thread de cada vez, ou seja, elas não executam de forma paralela, mas concorrente.
Sem a “trava” do GIL, uma operação simples de atribuição de variável poderia gerar um dado inconsistente caso duas threads atribuíssem um valor a uma mesma variável ao mesmo tempo.

Para os processos, por sua vez, o funcionamento é diferente. Para cada um, temos um GIL separado. Ou seja: podem ser executados paralelamente. Cabe ao programador garantir o acesso correto aos dados.

Múltiplos processos podem rodar em paralelo, enquanto múltiplas threads (de um mesmo processo) podem rodar concorrentemente.

Normalmente, utilizamos thread para interface gráfica, acesso ao banco de dados, acesso à rede etc., pois o programa não pode parar, ou a interface congelar, enquanto esperamos baixar um arquivo, por exemplo.

Quando temos, porém, um programa que necessita muito dos recursos do processador e temos como paralelizar nosso programa, devemos optar pela criação de múltiplos processos.

Criar novos processos pode ser lento e consumir muita memória, enquanto a criação de threads é mais rápida e consome menos memória.

///////////////////////////////////////////////////////////////////////////////// &&&
THREADS E PRECESSOS

Em Python, podemos criar tanto processos quanto threads em um programa.

A thread pertence a um determinado processo.
Múltiplas threads podem ser executadas dentro de um mesmo processo.
As de um mesmo processo compartilham a área de memória e podem acessar os mesmos dados de forma transparente.

Para criar threads e processos:

No script principal.py a seguir, vamos criar uma thread e um processo que executam a mesma função. Na linha 9, criamos uma thread para executar a função funcao_a utilizando a classe thread. O construtor tem como parâmetros a função que deverá ser executada (target) e quais parâmetros serão passados para essa função (args). O parâmetro args espera um iterável (lista, tupla etc.), onde cada elemento será mapeado para um parâmetro da função target.

Para criar threads e processos em Python, vamos utilizar a classe thread e process, dos módulos threading e multiprocessing, respectivamente. Para facilitar a transição entre processos e threads simples, o Python fez os construtores e métodos das duas classes muito parecidos.

Como a funcao_a espera apenas um parâmetro, definimos uma tupla de apenas um elemento (‘Minha Thread”). O primeiro elemento da tupla, a string Minha Thread, será passada para o parâmetro nome da funcao_a.
Na linha 10 (t.start()), enviamos o comando para a thread iniciar sua execução, chamando o método start() do objeto t do tipo thread, como pode ser observado a seguir:

# script principal.py
from threading import Thread
from multiprocessing import Process

def funcao_a(nome):
    print(nome)

def main():
    t = Thread(target=funcao_a, args=("Minha Thread",))
    t.start()

    p = Process(target=funcao_a, args=("Meu Processo",))
    p.start()

if __name__ == '__main__':
    main()

>>> Minha Thread
>>> 
>>> Meu Processo

A criação do processo é praticamente igual, porém utilizando a classe process, conforme a linha 12:
p = Process(target=funcao_a, args=("Meu Processo",))

Para iniciar o processo, chamamos o método start() na linha 13:
p.start()

--------------------------------------------------
THREAD
Exemplo 1 (forma simplificada):
Criação de uma thread com 1 string como argumento

from threading import Thread

def função(argumento):
    print(argumento)

variavel = Thread(target = função, args=( "Teste thread" ,))
variavel.start()
>>> Teste thread

---------------
THREAD
Exemplo 2 (forma simplificada):
Criação de uma thread com 1 número como argumento

from threading import Thread

def função(argumento):
    print(argumento + 5)

variavel = Thread(target = função, args=( 10 ,))
variavel.start()
>>> 15

---------------
THREAD
Exemplo 3 (forma simplificada):
Criação de uma thread sem argumentos

from threading import Thread

def função():
    print("Teste")

variavel = Thread(target = função)
variavel.start()
>>> Teste

--------------------------------------
PROCESSO
Exemplo 1 (forma simplificada):
Criação de um processo com 1 string como argumento

from multiprocessing import Process

def função(argumento):
    print(argumento)

variavel = Process(target = função, args=( "Teste processo" ,))
variavel.start()
>>> Teste processo

------------------
PROCESSO
Exemplo 2 (forma simplificada):
Criação de um processo com 1 número como argumento

from multiprocessing import Process

def função(argumento):
    print(argumento + 5)

variavel = Process(target = função, args=( 10 ,))
variavel.start()
>>> 15

---------------
PROCESSO
Exemplo 3 (forma simplificada):
Criação de um processo sem argumentos

from multiprocessing import Process

def função():
    print("Teste")

variavel = Process(target = função)
variavel.start()
>>> Teste

------------------------------------------------

Para mais criar uma thread com mais de 1 argumento:

from threading import Thread

def função(argumento1, argumento2):
    print(argumento1, argumento2)

variavel = Thread(target = função, args=("Multi" , "Thread"))
variavel.start()
>>> Multi Thread

-------------------

Para mais criar um processo com mais de 1 argumento:

from multiprocessing import Process

def função(argumento1, argumento2):
    print(argumento1, argumento2)

variavel = Process(target = função, args=("Multi" , "Processing"))
variavel.start()
>>> Multi Processing

---------------------------------------------

Usando funções como argumentos:

from threading import Thread

def função(argumentoA, argumentoB):
    print(argumentoA + argumentoB)

def A():
  a = 5 + 3
  return a

def B():
  b = 3 + 2
  return b

variavel = Thread(target = função, args=( A() , B() ))
variavel.start()
>>> 13

---------------------------------------------------------------------------------

Exemplo 1 do video:

import threading
import time

#exemplo de função sem parâmetro
def funcao():
    for x in range(3):
        print(x, "Executando a thread!")
        time.sleep(1)

print("Iniciando o programa!")
threading.Thread(target=funcao).start()
print("Finalizando o programa!")
>>> Iniciando o programa!
>>> (Finalizando o programa!
>>> 0, 'Executando a thread!')
>>> (1, 'Executando a thread!')
>>> (2, 'Executando a thread!')
>>>
>>> Process finished with exit code 0 

----------------

Exemplo 1 (simplificado):

from threading import Thread
import time

def função():
    for x in range(3):
        print(x, "Executando a thread!")
        time.sleep(1)

print("Iniciando o programa!")
variavel = Thread(target = função)
variavel.start()
print("Finalizando o programa!")

-----------------------------------------------------------

Exemplo 2 do video:

import threading
import time

#exemplo de função com parâmetro
def função(mensagem):
    for x in range(3):
        print(x, mensagem)
        time.sleep(1)

print("Iniciando o programa!")
variavel = threading.Thread(target=função, args=("Executando!" ,))
variavel.start()
print("Finalizando o programa!")
>>> Iniciando o programa!
>>> (Finalizando o programa!
>>> 0, 'Executando!')
>>> (1, 'Executando!')
>>> (2, 'Executando!')
>>>
>>> Process finished with exit code 0 

-----------------

Exemplo 2 (simplificado):

from threading import Thread
import time

def função(mensagem):
    for x in range(3):
        print(x, mensagem)
        time.sleep(1)

print("Iniciando o programa!")
variavel = Thread(target=função, args=("Executando!" ,))
variavel.start()
print("Finalizando o programa!")

------------------------------------------------------------- ###
MÚLTIPLAS THREADS E PROCESSOS
(programação paralela / concorrente)

No exemplo a seguir, scripts threads_var.py e processos_var.py, vamos criar múltiplas threads e processos para compararmos as saídas de cada um.

Vamos aproveitar para mostrar que todas as threads estão no mesmo contexto, com acesso às mesmas variáveis, enquanto o processo não. Vamos mostrar, também, como fazer o programa aguardar que todas as threads e processos terminem antes de seguir a execução.

Neste exemplo, a função que será paralelizada é a funcao_a (linha 8):
def funcao_a(indice):

Ela contém um laço que é executado cem mil vezes e para cada iteração adiciona o elemento 1 à lista minha_lista, definida globalmente na linha 6:
minha_lista = [ ]

Vamos criar 10 threads (e processos) para executar 10 instâncias dessa função, na qual, esperamos que o número de elementos na lista ao final da execução do programa seja de 1 milhão (10 threads X cem mil iterações).

Atenção!
Observe que os códigos dos scripts são praticamente idênticos, com exceção das classes construtoras thread e process na linha 16 dos dois scripts:
tarefa = Thread(target=funcao_a, args=(indice,)) #cria a thread
tarefa = Process(target=funcao_a, args=(indice,)) #cria o processo

Para criar essas 10 threads ou processos, temos um laço de 10 iterações (for indice in range(10):), em que criamos e iniciamos (tarefa.start()) cada thread ou processo. 

Veja os códigos a seguir:

#script threads_var.py
from threading import Thread
import time

minha_lista = [ ]
 
def funcao_a(indice):
    for i in range(100000):
        minha_lista.append(1)
        print("Termino thread ", indice)

def main():
    tarefas = [ ]
    for indice in range(10):
        tarefa = Thread(target=funcao_a, args=(indice,))
        tarefas.append(tarefa)
        tarefa.start()

    print("Antes de aguardar o termino!", len(minha_lista))

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", len(minha_lista))

if __name__ == "__main__":
    main()


#script processos_var.py
from multiprocessing import Process
import time

minha_lista = [ ]
 
def funcao_a(indice):
    for i in range(100000):
        minha_lista.append(1)
        print("Termino thread ", indice)

def main():
    tarefas = [ ]
    for indice in range(10):
        tarefa = Process(target=funcao_a, args=(indice,))
        tarefas.append(tarefa)
        tarefa.start()

    print("Antes de aguardar o termino!", len(minha_lista))

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", len(minha_lista))

if __name__ == "__main__":
    main()

É função do programador armazenar uma referência para as suas threads ou processos, de maneira que possamos verificar seu estado ou interrompê-las. Para isso, armazenamos cada thread ou processo criado em uma lista chamada tarefas (linha 17):
tarefas.append(tarefa)

Logo após a criação das threads ou processos, vamos imprimir o número de itens na variável minha_lista (linha 20):
print("Antes de aguardar o termino!", len(minha_lista))

Aguardar o término da execução das threads ou processos pela iteração da lista tarefas e utilizando o método join() (linhas 22 e 23):
for tarefa in tarefas:
    tarefa.join()

E, por fim, imprimimos o número de itens final da variável minha_ lista (linha 25).
print("Após aguardar o termino!", len(minha_lista))

Nos seguintes códigos, temos o resultado de cada script, que são:

#Saída do script threads_var.py
Termino thread Termino thread 0 1

Termino thread Termino thread 23Termino thread 4

Termino thread 5
Termino thread 6
Termino thread 7
9Termino thread Antes de guardar o termino! Termino thread 9
970012
8
Apos guardar o termino! 1000000

Process finished with exit code 0

#saída do script processos_var.py
Antes guardar o termino! 0
Termino thread 0
Termino thread 2
Termino thread 1
Termino thread 4
Termino thread 3
Termino thread 5
Termino thread 7
Termino thread 6
Termino thread 8
Termino thread 9
Apos guardar o termino! 0

Process finished with exit code 0

Apesar da saída do script thread.py ter ficado confusa, observe que o número de itens da variável minha_lista muda durante a execução do programa quando usamos thread e não muda quando usamos processos.
Isso acontece, pois a área de memória das threads é compartilhada, ou seja, elas têm acesso às mesmas variáveis globais. Em contrapartida, as áreas de memória dos processos não são compartilhadas. Cada processo acaba criando uma versão própria da variável minha_lista.

Travas (Lock):
No exemplo anterior, a função funcao_a incluía o elemento 1 à lista a cada iteração, utilizando o método append(). No exemplo a seguir, a funcao_a incrementará a variável global contador. Observe o código a seguir, script threads_inc.py e verifique o resultado impresso:

# script threads_inc.py
from threading import Thread
import time

contador = 0
 
def funcao_a(indice):
    global contador
    for i in range(1000000):
        contador += 1
    print("Termino thread ", indice)

def main():
    tarefas = [ ]
    for indice in range(10):
        tarefa = Thread(target=funcao_a, args=(indice,))
        tarefas.append(tarefa)
        tarefa.start()
 
    print("Antes de aguardar o termino!", contador)

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", contador)

if __name__ == "__main__":
    main()

Executando o exemplo acima será impresso:

Termino thread 1
Termino thread Termino thread 3 2

Termino thread 0 Termino thread
Antes de aguardar o termino! Termino thread 4
Termino thread 6
82235554

Termino thread Termino thread 9
Termino thread 7

Apos aguardar o termino! 3316688

Process finished with exit code 0

O valor impresso ao final do programa deveria ser 10.000.000 (10 threads X 1.000.000 de iterações), porém foi impresso 3.316.688. Você deve estar se perguntando por que aconteceu isso, se o GIL garante que apenas uma thread esteja em execução por vez.

Por que não aconteceu isso no exemplo anterior? O método utilizado para inserir um elemento na lista (append), na visão do GIL, é atômico, ou seja, ele é executado de forma segura e não pode ser interrompido no meio de sua execução.

O incremento de variável (+=1), que está sendo usado no exemplo atual (contador += 1), não é atômico. Ele é, na verdade, composto por duas operações, a leitura e a atribuição, e não temos como garantir que as duas operações serão realizadas atomicamente.

Veja a imagem a seguir, em que temos um contador inicialmente com o valor 0 e três threads incrementando esse contador. Para incrementar, a thread realiza duas operações: lê o valor do contador e depois atribui o valor lido incrementado de um ao contador:



Cada thread é executada em um determinado tempo t. Em t1, a thread1 lê e incrementa o contador, que passa a valer 1. Em t2, a thread2 lê o contador (valor 1). Em t3, a thread3 lê e incrementa o contador, que passa a valer 2. Em t4, a thread2 incrementa o contador, porém a partir do valor que ela leu, que era 1.

No final, o contador passa a valer 2, erroneamente. Esse resultado inesperado devido à sincronia na concorrência de threads (ou processos) se chama condição de corrida.

Para evitar a condição de corrida, utilizamos a primitiva lock (trava). Um objeto desse tipo tem somente dois estados: travado e destravado. Quando criado, ele fica no estado destravado. Esse objeto tem dois métodos: acquire e release.

Quando no estado destravado, o acquire muda o estado dele para travado e retorna imediatamente. Quando no estado travado, o acquire bloqueia a execução até que outra thread faça uma chamada ao método release e destrave o objeto. Veja como adaptamos o código anterior para utilizar o lock no script threads_inc_lock.py a seguir:

# script threads_inc_lock.py
from threading import Thread, Lock
import time

contador = 0
lock = Lock()
print_lock = Lock()

def funcao_a(indice):
    global contador
    for i in range(1000000):
        lock.acquire()
        contador += 1
        lock.release()
    print_lock.acquire()
    print("Termino thread ", indice)
    print_lock.release()

def main():
    tarefas = [ ]
    for indice in range(10):
        tarefa = Thread(target=funcao_a, args=(indice,))
        tarefas.append(tarefa)
        tarefa.start()

    print("Antes de aguardar o termino!", contador)

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", contador)

if __name__ == "__main__":
    main()

Primeiramente, definimos a variável global lock utilizando o construtor lock(), também do módulo threading (linha 7):
lock = Lock()

Depois, vamos utilizar essa trava para “envolver” a operação de incremento. Imediatamente antes de incrementar o contador, chamamos o método acquire() da variável lock (lock.acquire()), de forma a garantir exclusividade na operação de incremento (contador += 1).

Logo após o incremento, liberamos a trava utilizando o método release (linha 15):
lock.release()

Com apenas essa modificação, garantimos que o resultado estará correto. Podemos verificar o resultado impresso abaixo:

Antes de aguardar o termino! 73844
Termino thread 1
Termino thread 7
Termino thread 8
Termino thread 9
Termino thread 2
Termino thread 3
Termino thread 0
Termino thread 4
Termino thread 6
Termino thread 5
Após aguardar o termino! 10000000

Process finished with exit code 0

Aproveitamos este exemplo para corrigir o problema de impressão no console de forma desordenada. Esse problema ocorria, pois o print também não é uma operação atômica. Para resolver, envolvemos o print da linha 17 (print("Termino thread ", indice)) com outra trava, print_lock, criada na linha 8 (print_lock = Lock()).

--------------------------------------------------------------------- ###
CONDIÇÃO DE CORRIDA

O método utilizado para inserir um elemento em uma lista (usando append), na visão do GIL, é atômico, ou seja, ele é executado de forma segura e não pode ser interrompido no meio de sua execução.

O incremento de uma variável (por exemplo, contador += 1), não é atômico. Ele é, na verdade, composto por duas operações, a leitura e a atribuição, e não temos como garantir que as duas operações serão realizadas atomicamente.

Veja a imagem a seguir, em que temos um contador inicialmente com o valor 0 e três threads incrementando esse contador. Para incrementar, a thread realiza duas operações: lê o valor do contador e depois atribui o valor lido incrementado de um ao contador:



Cada thread é executada em um determinado tempo t. Em t1, a thread1 lê e incrementa o contador, que passa a valer 1. Em t2, a thread2 lê o contador (valor 1). Em t3, a thread3 lê e incrementa o contador, que passa a valer 2. Em t4, a thread2 incrementa o contador, porém a partir do valor que ela leu, que era 1.

No final, o contador passa a valer 2, erroneamente. Esse resultado inesperado devido à sincronia na concorrência de threads (ou processos) se chama condição de corrida.

Para evitar a condição de corrida, utilizamos a primitiva lock (trava). 

Um objeto desse tipo tem somente dois estados: travado e destravado. 
Quando criado, ele fica no estado destravado. 
Esse objeto tem dois métodos: acquire e release.

Quando no estado destravado, o acquire muda o estado dele para travado e retorna imediatamente. 
Quando no estado travado, o acquire bloqueia a execução até que outra thread faça uma chamada ao método release e destrave o objeto. 

Veja um código para utilizar o lock no script threads_inc_lock.py a seguir:

# script threads_inc_lock.py
from threading import Thread, Lock
import time

contador = 0
lock = Lock()
print_lock = Lock()

def funcao_a(indice):
    global contador
    for i in range(1000000):
        lock.acquire()
        contador += 1
        lock.release()
    print_lock.acquire()
    print("Termino thread ", indice)
    print_lock.release()

def main():
    tarefas = [ ]
    for indice in range(10):
        tarefa = Thread(target=funcao_a, args=(indice,))
        tarefas.append(tarefa)
        tarefa.start()

    print("Antes de aguardar o termino!", contador)

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", contador)

if __name__ == "__main__":
    main()

Primeiramente, definimos a variável global lock utilizando o construtor lock(), também do módulo threading (linha 7):
lock = Lock()

Depois, vamos utilizar essa trava para “envolver” a operação de incremento. Imediatamente antes de incrementar o contador, chamamos o método acquire() da variável lock (lock.acquire()), de forma a garantir exclusividade na operação de incremento (contador += 1).

Logo após o incremento, liberamos a trava utilizando o método release (linha 15):
lock.release()

Com apenas essa modificação, garantimos que o resultado estará correto. Podemos verificar o resultado impresso abaixo:

Antes de aguardar o termino! 73844
Termino thread 1
Termino thread 7
Termino thread 8
Termino thread 9
Termino thread 2
Termino thread 3
Termino thread 0
Termino thread 4
Termino thread 6
Termino thread 5
Após aguardar o termino! 10000000

Process finished with exit code 0

Aproveitamos este exemplo para corrigir o problema de impressão no console de forma desordenada. Esse problema ocorre, pois o print também não é uma operação atômica. 
Para resolver, envolvemos o print da linha 17 (print("Termino thread ", indice)) com outra trava, print_lock, criada na linha 8 (print_lock = Lock()).

------------------------------------------------------------ ###
COMPARTILHAMENTO DE VARIAVEIS ENTRE PROCESSOS
(programação paralela / concorrente)

Para criar uma área de memória compartilhada e permitir que diferentes processos acessem a mesma variável, podemos utilizar a classe value do módulo multiprocessing.

No exemplo a seguir, script processos.py, criaremos uma variável do tipo inteiro e a compartilharemos entre os processos. Essa variável fará o papel de um contador e a função paralelizada vai incrementá-la:

# script processos.py
from multiprocessing import Process, Value

def funcao_a(indice, cont):
    for i in range(100000):
        with cont.get_lock():
            cont.value += 1
    print("Termino processo ", indice)

def main():
    contador = Value('i', 0)
    tarefas = [ ]
    for indice in range(10):
        tarefa = Process(target=funcao_a, args=(indice, contador))
        tarefas.append(tarefa)
        tarefa.start()

    print("Antes de aguardar o termino!", contador.value)

    for tarefa in tarefas:
        tarefa.join()

    print("Após aguardar o termino!", contador.value)

if __name__ == "__main__":
    main()

O código acima imprimirá o seguinte resultado:

Antes de aguardar o termino! 0
Termino processo 2
Termino processo 1
Termino processo 0
Termino processo 3
Termino processo 4
Termino processo 5
Termino processo Termino processo 7
6
Termino processo 8
Termino processo 9
Após aguardar o termino! 1000000

Process finished with exit code 0

Para permitir que a variável seja compartilhada, declaramos uma variável chamada contador utilizando o construtor da classe value, onde passamos como primeiro argumento um caractere com o tipo da variável compartilhada (‘i’ 🡪 inteiro) e seu valor inicial (0) na linha 12:
contador = Value('i', 0)

Como não temos acesso a variáveis globais entre os processos, precisamos passar esta para o construtor process por meio do parâmetro args. Como a passagem de parâmetros é posicional, o parâmetro índice da funcao_a recebe o valor da variável índice e o parâmetro cont recebe uma referência para a variável contador na linha 15:
tarefa = Process(target=funcao_a, args=(indice, contador))

Isso já é o suficiente para termos acesso à variável contador por meio do parâmetro cont da função funcao_a. Porém, não resolve a condição de corrida.

Para evitar esse problema, vamos utilizar uma trava (lock) para realizar a operação de incremento, assim como ao utilizar threads.

O Python já disponibiliza essa trava nos objetos do tipo value, não sendo necessário criar uma variável específica para a trava (lock). Observe como foi realizada a trava utilizando o método get_lock() na linha 7:
with cont.get_lock():

Observe no resultado impresso que agora nossa variável está com o valor certo: um milhão!
Após aguardar o termino! 1000000

Para corrigir o problema da impressão desordenada, basta criar uma variável do tipo lock e passá-la como parâmetro, assim como é feito com thread e com a variável contador.

------------------------------------------------------------------- ###
SINCRONIZAÇÃO DE THREADS
(programação paralela / concorrente)

from threading import Thread
import time

lista = [ ]

def contador1(n):
    for x in range(1, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.4)

def contador2(n):
    for x in range(6, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.5)

variavel1 = Thread(target = contador1, args=( 5 ,))
variavel1.start()

variavel2 = Thread(target = contador2, args=( 10 ,))
variavel2.start()

print(lista)
>>> 1
>>>  6[
>>> 1, 6[   #já printou a lista antes de terminar todas as threads
>>> 2
>>> 7
>>> 3
>>> 8
>>> 4
>>> 9
>>> 5
>>> 10
>>>
>>> Process finished with exit code 0

Como pode perceber, a execução da thread não ocorreu na ordem desejada. Ele não imprimiu os resultados na sequência que se gostaria que fossem impressas.

Vamos fazer uma modificação no código adicionado o comando join(). Esse comando faz com que as duas threads executem, e só após a finalização das duas threads é que o comando print(lista) seja executado.

from threading import Thread
import time

lista = [ ]

def contador1(n):
    for x in range(1, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.4)

def contador2(n):
    for x in range(6, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.5)

variavel1 = Thread(target = contador1, args=( 5 ,))
variavel1.start()

variavel2 = Thread(target = contador2, args=( 10 ,))
variavel2.start()

variavel1.join()
variavel2.join()

print(lista)
>>> 1
>>> 6
>>> 2
>>> 7
>>> 3
>>> 8
>>> 4
>>> 9
>>> 5
>>> 10
>>> [1, 6, 2, 7, 3, 8, 4, 9, 5, 10]
>>>
>>> Process finished with exit code 0

Dessa forma, o comando print(lista) só foi executado após as duas thread finalizarem. 

Porém, e se quiséssemos que a primeira thread fosse realizada antes da segunda thread e não fosse executada alternadamente? 
Para isso teríamos que modificar o código adicionando um join() entre a primeira e a segunda thread:

from threading import Thread
import time

lista = [ ]

def contador1(n):
    for x in range(1, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.4)

def contador2(n):
    for x in range(6, n+1):
        print(x)
        lista.append(x)
        time.sleep(0.5)

variavel1 = Thread(target = contador1, args=( 5 ,))
variavel1.start()

variavel1.join()

variavel2 = Thread(target = contador2, args=( 10 ,))
variavel2.start()

variavel2.join()

print(lista)
>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9
>>> 10
>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

--------------------------------------------------

Exemplo do mundo real utilizando threads (do video):
(para saber o tempo de resposta de algumas urls)

import threading
import time
import urllib2

start = time.time()
urls = ["http://www.google.com" , "http://www.Apple.com" , "http://www.Microsoft.com" , "http://www.instagram.com"]

def chama_url(url):
    req = urllib2.Request(url)
    response = urllib2.urlopen(req)
    the_page = response.read()
    print ("'%s\' carregado em %ss" % (url, (time.time() - start)))
    #print(the_page)

threads = [threading.Thread(target = chama_url, args=(url,)) for url in urls]

for thread in threads:
    thread.start()
for thread in threads:
    thread.join()

print ("Elapsed Time: %s" % (time.time() - start))

>>> 'http://www.google.com' carregado em 0.172022104263s
>>> 'http://www.Apple.com' carregado em 0.286175012589s
>>> 'http://www.Microsoft.com' carregado em 0.138174057007s
>>> 'http://www.instagram.com' carregado em 0.671772003174s
>>> Elapsed Time: 0.671881198883
>>>
>>> Process finished with code 0

Obs: O código acima ao que parece está desatualizado pois não consegue importar o módulo urllib2. De acordo com a documentação desse módulo:
The urllib2 module has been split across several modules in Python 3 named urllib.request and urllib.error. The 2to3 tool will automatically adapt imports when converting your sources to Python 3. 

O novo código funcionando ficaria então:

import threading
import time
from urllib.request import urlopen, Request

start = time.time()
urls = ["http://www.google.com" , "http://www.Apple.com" , "http://www.Microsoft.com" , "http://www.instagram.com"]

def chama_url(url):
    req = Request(url) #para verificar a url
    response = urlopen(req) #para abrir ou acessar a url
    the_page = response.read() #para fazer a leitura da estrutura da página url
    print ("'%s\' carregado em %ss" % (url, (time.time() - start)))
    #print(the_page)

threads = [threading.Thread(target = chama_url, args=(url,)) for url in urls]

for thread in threads:
    thread.start()
for thread in threads:
    thread.join()

print("Elapsed Time: %s" % (time.time() - start))

>>> 'http://www.Microsoft.com' carregado em 0.02658867835998535s
>>> 'http://www.google.com' carregado em 0.042749643325805664s
>>> 'http://www.Apple.com' carregado em 0.0612645149230957s
>>> 'http://www.instagram.com' carregado em 1.1363439559936523s
>>> Elapsed Time: 1.1376574039459229

---------------------------------------------------- ###
Em Python, implementar uma solução, através do uso de Thread, que faça:

a. Inicie a execução de uma Thread
b. Coloque a thread para esperar 2 segundos
c. Informe o início e o final da execução da Thread

from threading import Thread
import time

def função(x):
  print(x)
  time.sleep(2)

variavel = Thread(target = função, args=("Começo" ,))
variavel.start()
variavel.join()

print("Fim")
>>> Começo
aguardou 2 segundos
>>> Fim
-----------------------------------------------
Adicionando mensagens durante a execução e ao concluir:

from threading import Thread
from time import sleep

def função(x , y):
  print(x)
  sleep(2)
  print(y)

variavel = Thread(target = função, args=("Começo" , "Concluído!"))
variavel.start()

print("\nAguardando")

variavel.join()

print("Fim")

>>> Começo
>>> Aguardando
aguardou 2 segundos
>>>Concluído!
>>> Fim

----------------------------------------------

Solução do professor:

from threading import Thread
from time import sleep

def tarefa(tempo_espera, mensagem):
    print(f"\nIniciando a tarefa {mensagem}")
    sleep(tempo_espera)
    print(f"Conclusão da tarefa {mensagem}")

thread = Thread(target = tarefa, args=( 2 , "Thread em execução"))
thread.start()

print("\nAguardando pela execução da Thread...")

thread.join()

print("A execução foi concluída!")

>>> Iniciando a tarefa Thread em execução
>>> Aguardando pela execução da Thread...
>>>
>>> Conclusão da tarefa Thread em execução
>>> A execução foi concluída!

--------------------------------------------------- ###
Em Python, implementar uma solução, através do uso de Thread, que faça:

a. Inicie a execução de duas Threads
b. Coloque a primeira e a segunda threads para esperar, respectivamente, 3 e 2 segundos
c. Informe a ordem da execução das Threads

Utilizando somente 1 função:

from threading import Thread
from time import sleep

def função(começo , conclusão , tempo):
  print(começo)
  sleep(tempo)
  print(conclusão)

variavel1 = Thread(target = função, args=("Começo Thread 1" , "Conclusão Thread 1" , 3))
variavel2 = Thread(target = função, args=("Começo Thread 2" , "Conclusão Thread 2" , 2))

variavel1.start()
variavel2.start()

variavel1.join()
variavel2.join()

print("Fim")
>>> Começo Thread 1 
>>> Começo Thread 2 
>>> Conclusão Thread 2
>>> Conclusão Thread 1
>>> Fim

-----------------------------------------------

Utilizando somente 1 função e aguardando a Thread 1 terminar antes da Thread 2:

from threading import Thread
from time import sleep

def função(começo , conclusão , tempo):
  print(começo)
  sleep(tempo)
  print(conclusão)

variavel1 = Thread(target = função, args=("Começo Thread 1" , "Conclusão Thread 1" , 3))
variavel2 = Thread(target = função, args=("Começo Thread 2" , "Conclusão Thread 2" , 2))

variavel1.start()
variavel1.join()

variavel2.start()
variavel2.join()

print("Fim")
>>> Começo Thread 1 
>>> Conclusão Thread 1
>>> Começo Thread 2 
>>> Conclusão Thread 2
>>> Fim

-----------------------------------------------

Utilizando 2 funções e aguardando a thread 1 terminar antes da thread 2:
(adicionada uma mensagem para aparacer em tempo de execução)

from threading import Thread
from time import sleep

def função1(começo , conclusão , tempo):
  print(começo)
  sleep(tempo)
  print(conclusão)

def função2(começo , conclusão , tempo):
  print(começo)
  sleep(tempo)
  print(conclusão)

variavel1 = Thread(target = função1, args=("Começo Thread 1" , "Conclusão Thread 1" , 3))
variavel1.start()

print("\nAguardando Thread 1")
variavel1.join()

variavel2 = Thread(target = função2, args=("Começo Thread 2" , "Conclusão Thread 2" , 2))
variavel2.start()

print("\nAguardando Thread 2")
variavel2.join()

print("Fim")
>>> Começo Thread 1 
>>> Aguardando Thread 1 
>>> aguardou 3 segundos
>>> Conclusão Thread 1!
>>> Começo Thread 2 
>>> Aguardando Thread 2 
>>> aguardou 2 segundos
>>> Conclusão Thread 2
>>> Fim

----------------------------------------------

Solução do professor:

from threading import Thread
from time import sleep

def tarefa(tempo_espera, nome_tarefa):
    print(f"Iniciando a tarefa {nome_tarefa}")
    sleep(tempo_espera)
    print(f"Conclusão da tarefa {nome_tarefa}")

t1 = Thread(target = tarefa, args=( 3 , "A"))
t2 = Thread(target = tarefa, args=( 2 , "B"))
t1.start()
t2.start()

t1.join() #esperar até completar a execução da thread 1
t2.join() #esperar até completar a execução da thread 2

print("A execução foi concluída!")

>>> Iniciando a tarefa A
>>> Iniciando a tarefa B
>>> Conclusão da tarefa B
>>> Conclusão da tarefa A
>>> A execução foi concluída!

-------------------------------------------------- ###
Em Python, implementar uma solução, através do uso de Thread, que faça:

a. Inicie a execução de duas Threads
b. A primeira Thread deve calcular o cubo de um número
c. A primeira Thread deve calcular o quadrado de um número
d. Coloque a primeira e a segunda threads para esperar, respectivamente, 3 e 2 segundos
e. Informe a ordem da execução das Threads

Utilizando somente 1 função e em ordem (Thread 2 aguarda a Thread 1 terminar):

from threading import Thread
from time import sleep

def função(começo , conclusão , tempo , base , expoente):
  print(começo)
  print(f"{base} elevado a {expoente} é igual a {base ** expoente}")
  sleep(tempo)
  print(conclusão)

variavel1 = Thread(target = função, args=("Começo Thread 1" , "Conclusão Thread 1\n" , 3 , 5 , 3))
variavel2 = Thread(target = função, args=("Começo Thread 2" , "Conclusão Thread 2\n" , 2 , 5 , 2))

variavel1.start()
variavel1.join()

variavel2.start()
variavel2.join()

print("Fim")

>>> Começo Thread 1 
>>> 5 elevado a 3 é igual a 125 
>>> Conclusão Thread 1 
>>> 
>>> Começo Thread 2 
>>> 5 elevado a 2 é igual a 25 
>>> Conclusão Thread 2 
>>> 
>>> Fim

-----------------------------------------

Solução do professor (usando 2 funções e sem estar em ordem):

from time import sleep
from threading import Thread

def calcular_cubo(num, tempo_espera):
    print(f"\nCubo: {num * num * num}")
    sleep(tempo_espera)
    print("Conclusão da função calcular_cubo")

def calcular_quadrado(num, tempo_espera):
    print(f"\nQuadrado: {num * num}")
    sleep(tempo_espera)
    print("Conclusão da função calcular_quadrado")

t1 = Thread(target = calcular_cubo , args = (5, 3))
t2 = Thread(target = calcular_quadrado , args = (5, 2))

t1.start()
t2.start()

t1.join() #esperar até completar a execução da Thread 1
t2.join() #esperar até completar a execução da Thread 2

print("A execução foi concluída!")

>>>
>>> Cubo: 125
>>> 
>>> Quadrado: 25 
>>> Conclusão da função calcular_quadrado 
>>> Conclusão da função calcular_cubo 
>>> A execução foi concluída!

----------------------------------------- ###
Qual o valor impresso pelo script a seguir?

# script processos.py
from threading import Thread
from multiprocessing import Process

minha_lista = [ ]

def adiciona():
    for i in range(100):
        minha_lista.append(1)

def main():
    tarefas = [ ]

    for indice in range(10):
        t = Thread(target=adiciona)
        tarefas.append(t)
        t.start()

    for indice in range(10):
        p = Process(target=adiciona)
        tarefas.append(t)
        p.start()

    for tarefa in tarefas:
        tarefa.join()

    print(len(minha_lista))

if __name__ == '__main__':
    main()

>>> 1000

Apenas a thread consegue acessar a variável global minha_lista. São executadas 10 threads X 100 iterações = 1000.

//////////////////////////////////////////////////////////////////// &&&
KDD / CIENCIA COMPUTACIONAL

Desde o século XVII, as ciências experimentais e teóricas são reconhecidas pelos cientistas como os paradigmas básicos de pesquisa para entender a natureza. De umas décadas para cá, a simulação computacional de fenômenos complexos evoluiu, criando o terceiro paradigma: 
a ciência computacional.

A ciência computacional fornece ferramentas necessárias para tornar possível a exploração de domínios inacessíveis à teoria ou experimento.

Com o aumento das simulações e experimentos, mais dados são gerados e um quarto paradigma emerge, que são as tecnologias e técnicas associadas à Ciência de Dados.

A Ciência de Dados é uma área de conhecimento que envolve a utilização de dados para gerar impactos em uma instituição, seja uma universidade, uma empresa, um órgão federal etc., de forma a resolver um problema real utilizando os dados.

------------------------------------- ###

Em 1996, Fayyad apresentou a definição clássica do processo de descoberta de conhecimento em bases de dados, conhecido por KDD (Knowledge Discovery in Databases)

“KDD é um processo, de várias etapas, não trivial, interativo e iterativo, para identificação de padrões compreensíveis, válidos, novos e potencialmente úteis a partir de grandes conjuntos de dados”.
(FAYYAD, 1996, p. )

As técnicas de KDD (FAYYAD, 1996), também conhecidas como mineração de dados, normalmente se referem à extração de informações implícitas, porém úteis, de uma base de dados.

Essas aplicações, tipicamente, envolvem o uso de mineração de dados para descobrir um novo modelo, e então os analistas utilizam esse modelo em suas aplicações.

O processo de KDD é basicamente composto por três grandes etapas:

- Pré-processamento
- Mineração de dados
- Pós-processamento

--------

A primeira etapa do processo de KDD, conhecida como pré-processamento, é responsável por selecionar, preparar e transformar os dados que serão utilizados pelos algoritmos de mineração.

Algumas atividades envolvidas no pré-processamento são:

- Coleta e integração:
Quando é necessário que dados provenientes de diversas fontes sejam consolidados em uma única base de dados. Essa atividade é bastante encontrada na construção de data warehouses.

- Codificação:
Significa transformar a natureza dos valores de um atributo. Isso pode acontecer de duas diferentes formas: uma transformação de dados numéricos em categóricos — codificação numérico-categórica –, ou o inverso — codificação categórico-numérica.
Portanto, em algumas situações, precisamos transformar um atributo ou característica de uma amostra de categoria para um número. Por exemplo, a codificação categórico-numérica transforma string em números.

- Construção de atributos:
Pode ser necessário criar colunas em uma tabela, por exemplo, refletindo alguma transformação dos dados existentes em outras colunas, após a coleta e integração dos dados.

- Limpeza de dados:
Pode ser subdividida em complementação de dados ausentes, detecção de ruídos e eliminação de dados inconsistentes.

- A partição dos dados:
Consiste em separar os dados em dois conjuntos disjuntos. Um para treinamento (abstração do modelo de conhecimento) e outro para testes (avaliação do modelo gerado).

--------

A segunda etapa do KDD, conhecida como mineração de dados, é a aplicação de um algoritmo específico para extrair padrões de dados.

Hand (2001), define a etapa de mineração de dados da seguinte forma:
"Mineração de dados é a análise de (quase sempre grandes) conjuntos de dados observados para descobrir relações escondidas e para consolidar os dados de uma forma tal que eles sejam inteligíveis e úteis aos seus donos."

Esta etapa, normalmente, é a que atrai maior atenção, por ser ela que revela os padrões ocultos nos dados.

--------

Os algoritmos de mineração podem ser classificados como:
supervisionados e não supervisionados.

Nos supervisionados, os algoritmos “aprendem” baseados nos valores que cada dado já possui.
Os algoritmos são treinados (ajustados), aplicando uma função e comparando o resultado com os valores existentes.

Já nos não supervisionados, os dados não foram classificados previamente e os algoritmos tentam extrair algum padrão por si só.
Eles podem ser realizados durante a etapa de mineração de dados.

-----------------------

- NÃO SUPERVISIONADOS:

• Regras de associação = Uma das técnicas de mineração de dados mais utilizada para comércio eletrônico, cujo objetivo é encontrar regras para produtos comprados em uma mesma transação.
Ou seja, a presença de um produto em um conjunto implica a presença de outros produtos de outro conjunto; com isso, sites de compras nos enviam sugestões de compras adicionais, baseado no que estamos comprando.

• Agrupamento = Reúne, em um mesmo grupo, objetos de uma coleção que mantenham algum grau de afinidade.
É utilizada uma função para maximizar a similaridade de objetos do mesmo grupo e minimizar entre elementos de outros grupos.

-----------------------

- SUPERVISIONADOS:

• Classificação = Tem como objetivo descobrir uma função capaz de mapear (classificar) um item em uma das várias classes predefinidas.
Se conseguirmos obter a função que realiza esse mapeamento, qualquer nova ocorrência pode ser também mapeada, sem a necessidade de conhecimento prévio da sua classe.

• Regressão linear = É uma técnica para se estimar uma variável a partir de uma função.
A regressão, normalmente, tem o objetivo de encontrar um valor que não foi computado inicialmente.

---------------------------------------------------- ###

"A última etapa do KDD, o pós-processamento, tem como objetivo transformar os padrões dos dados obtidos na etapa anterior, de forma a torná-los inteligíveis, tanto ao analista de dados quanto ao especialista do domínio da aplicação."
(SOARES, 2007)

----------------------------------------------------- ###
Como seria um exemplo de algoritmo supervisionado usando regressão linear?
(para predizer casos futuros de dengue)

Neste exemplo, utilizaremos uma série histórica fictícia de casos de dengue de uma determinada cidade e, com o auxílio do algoritmo supervisionado de regressão linear, predizeremos casos futuros.

A série está em uma planilha (arquivo CSV) com duas colunas, ano e casos (número de casos). Na planilha, temos o número de casos de 2001 a 2017. Utilizaremos essa série histórica e aplicaremos o algoritmo de regressão linear para estimar os casos de dengue para o ano de 2018.

A seguir, temos o código do script regressao.py, o arquivo CSV (dados_dengue.csv) e a saída do console.

#script regressao.py
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
import pandas

============= Pré-processamento =================
# Coleta e Integração
arquivo = pandas.read_csv('dados_dengue.csv')

anos = arquivo[['ano']]
casos = arquivo[['casos']]

================ Mineração ======================
regr = LinearRegression()
regr.fit(X=anos, y=casos)

ano_futuro = [[2018]]
casos_2018 = regr.predict(ano_futuro)

print('Casos previstos para 2018 ->', int(casos_2018))

============ Pós-processamento =================
plt.scatter(anos, casos, color='black')
plt.scatter(ano_futuro, casos_2018, color='red')
plt.plot(anos, regr.predict(anos), color='blue')

plt.xlabel('Anos')
plt.ylabel('Casos de dengue')
plt.xticks([2018])
plt.yticks([int(casos_2018)])

plt.show()

#arquivo dados_dengue.csv
ano,casos
2017,450
2016,538
2015,269
2014,56
2013,165
2012,27
2011,156
2010,102
2009,86
2008,42
2007,79
2006,65
2005,58
2004,39
2003,23
2002,15
2001,28

Com este código será impresso:
>>> Casos previstos para 2018 -> 330

Após importar os módulos necessários, vamos passar para a primeira etapa do KDD, o pré-processamento. Neste caso simples, vamos realizar apenas a coleta e integração que, na prática, é carregar a planilha dentro do programa.

Para isso, utilizamos a função read_csv da biblioteca Pandas, passando como parâmetro o nome do arquivo (linha 7):
arquivo = pandas.read_csv('dados_dengue.csv')

A classe da biblioteca Scikit-Learn utilizada para realizar a regressão linear se chama LinearRegression. Para realizar a regressão, ela precisa dos dados de treinamento (parâmetro X) e seus respectivos resultados (parâmetro y).

No nosso exemplo, como desejamos estimar o número de casos, utilizaremos os anos como dado de treinamento e o número de casos como resultado. Ou seja, teremos os anos no parâmetro X e os casos no parâmetro y.

Como estamos usando apenas uma variável para o parâmetro X, o ano, temos uma regressão linear simples e o resultado esperado é uma reta, onde temos os anos no eixo x e os casos no eixo y.

Após carregar o arquivo, vamos separar os dados das colunas nas respectivas variáveis. Observe a sintaxe para obter os anos (linha 9) e casos (linha 10):
anos = arquivo[['ano']]
casos = arquivo[['casos']]

O Pandas detecta, automaticamente, o nome das colunas e permite extrair os elementos das colunas utilizando o nome.

Atenção!
O próximo passo é criar o objeto do tipo LinearRegression e atribuí-lo a uma variável (linha 13):
regr = LinearRegression()

Esse objeto será utilizado para treinar (ajustar) a equação da reta que será gerada pela regressão. Para realizar o treinamento (fit), precisamos passar os parâmetros X e y (linha 14):
regr.fit(X=anos, y=casos)

Após a execução do método fit, o objeto regr está pronto para ser utilizado para predizer os casos para os anos futuros, utilizando o método predict (linha 17):
casos_2018 = regr.predict(ano_futuro)

Ao chamar o método predict passando o ano 2018 como argumento, recebemos como retorno o número de casos previsto para 2018, conforme impresso no console da figura Saída do script regressão.py (330).

A partir da linha 21, temos a etapa de pós-processamento, na qual utilizamos a biblioteca Matplotlib para exibir um gráfico com os dados da série (pontos em preto), a reta obtida pela regressão, em azul, e o valor predito para o ano de 2018, em vermelho, como na imagem a seguir:

----------------------------------------------- ###
Como seria um exemplo de algoritmo supervisionado usando Classificação?
(para classificar classes de Flor de Íris)

Os algoritmos de classificação são do tipo supervisionado, nos quais passamos um conjunto de características sobre um determinado item de uma classe de forma que o algoritmo consiga compreender, utilizando apenas as características, qual a classe de um item não mapeado.

Para este exemplo, utilizaremos um conjunto de dados (dataset) criado em 1938 e utilizado até hoje: o dataset da Flor de Íris (Iris Dataset). Ele contém informações de cinquenta amostras de três diferentes classes de Flor de Íris (Iris setosa, Iris virginica e Iris versicolor).

No total, são quatro características para cada amostra, sendo elas o comprimento e a largura, em centímetros, das sépalas e pétalas de rosas.

Por ser um dataset muito utilizado e pequeno, o Scikit-Learn já o disponibiliza internamente.

Vamos treinar dois algoritmos de classificação, árvore de decisão e máquina de vetor suporte (support vector machine – SVM) para montar dois classificadores de flores de Íris. A forma como são implementados esses algoritmos está fora do escopo deste módulo.

Confira o script a seguir, classificação.py, em que utilizamos esses dois algoritmos:

from sklearn.datasets import load_iris, fetch_kddcup99
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, export_text, plot_tree
from sklearn.svm import SVC

===================== Pré-processamento ========================
# Coleta e Integração
iris = load_iris()

caracteristicas = iris.data
rotulos = iris.target

print("Caracteristicas:\n", caracteristicas[:2])
print("Rótulos:\n", rotulos[:2])
print('=========================================================')

# Partição dos dados
carac_treino, carac_teste, rot_treino, rot_teste = train_test_split(caracteristicas, rotulos)

======================== Mineração ==============================

---------------------- Arvore de Decisão ------------------------
arvore = DecisionTreeClassifier(max_depth=2)
arvore.fit(X=carac_treino, y=rot_treino)

rot_preditos = arvore.predict(carac_teste)
acuracia_arvore = accuracy_score(rot_teste, rot_preditos)

--------------------- Máquina de Vetor Suporte ------------------
clf = SVC()
clf.fit(X=carac_treino, y=rot_treino)

rot_preditos_svm = clf.predict(carac_teste)
acuracia_svm = accuracy_score(rot_teste, rot_preditos_svm)

================== Pós-processamento ==============================
print("Acurácia Árvore de Decisão:", round(acuracia_arvore, 5))
print("Acurácia SVM:", round(acuracia_svm, 5))
print('========================================================')

r = export_text(arvore, feature_names=iris['feature_names'])
print("Estrutura da árvore")
print(r)


Com este código será impresso o seguinte:
Caracteristicas:
    [[5.1 3.5 1.4 0.2]
    [4.9 3.  1.4 0.2]]
Rótulos:
    [0 0]
===============================================
Acurácia Árvore de Decisão: 0.92105
Acurácia SVM: 0.97368
    ===========================================
    Estrutura da árvore
    |--- petal width (cm) <= 0.80
    |   |--- class: 0
    |--- petal width (cm) > 0.80
    |   |--- petal width (cm) <= 1.75
    |   |   |--- class: 1
    |--- petal width (cm) > 1.75
    |   |   |--- class: 2
    Process finished with exit code 0

Veja a seguir cada etapa do pré-processamento:

- Na etapa de pré-processamento, vamos começar pela coleta e integração, que é a obtenção do dataset de flores utilizando a função load_iris() (linha 9):
iris = load_iris()
Essa função retorna um objeto onde podemos acessar as características das flores pelo atributo data e os rótulos, ou classes das flores, pelo atributo target.

- Na linha 11 (caracteristicas = iris.data), separamos as características das flores na variável características. Ela contém uma lista com 150 itens, onde cada item contém outra lista com quatro elementos. Observe o conteúdo dos dois primeiros itens dessa lista. Cada um dos quatro elementos corresponde ao comprimento da sépala, largura da sépala, comprimento da pétala e largura da pétala, respectivamente.

- Na linha 12 (rotulos = iris.target), separamos os rótulos (ou classes) na variável rótulo. Ela contém uma lista com 150 itens que variam entre 0, 1 ou 2. Cada número corresponde a uma classe de flor (0: Iris-Setosa; 1:Iris-Versicolor; 2:Iris-Virginica). Como dito na introdução deste módulo, esse mapeamento entre categorias e números se chama codificação categórico-numérica. Essa etapa de pré-processamento já foi realizada e disponibilizada pela função load_iris().

- Outra etapa de pré-processamento que precisaremos realizar é a partição dos dados. Ela nos permitirá verificar a qualidade do algoritmo de classificação. Para isso, precisamos particionar nossos dados em treino e teste.

Os dados de treino são, como o próprio nome diz, utilizados para treinar (ajustar) o algoritmo, enquanto os dados de testes são utilizados para verificar a acurácia dele, comparando o valor calculado para os testes com os valores reais.

Para separar as amostras em treino e teste, o Scikit-Learn disponibiliza uma função chamada train_test_split, que recebe como primeiro parâmetro uma lista com as características e segundo parâmetro uma lista com os rótulos.

Essa função retorna quatro novas listas:
De treino;
De teste das características;
De treino;
De teste dos rótulos.
Observe a linha 19, onde utilizamos essa função para gerar quatro novas variáveis: características para treino (carac_treino); características para teste (carac_teste); rótulos para treino (rot_treino); e rótulos para teste (rot_teste). O código ficou assim:
carac_treino, carac_teste, rot_treino, rot_teste = train_test_split(caracteristicas, rotulos)

Com a etapa de pré-processamento concluída, o próximo passo é treinar um algoritmo de classificação com os dados de treino. Para isso, criamos uma instância do classificador DecisionTree passando como parâmetro a profundidade máxima da árvore, ou seja, o número máximo de níveis, ou camadas, a partir do nó raiz, que a árvore encontrada poderá ter (linha 24):
arvore = DecisionTreeClassifier(max_depth=2)

Veremos como a árvore ficou ao término do script. Esse objeto será utilizado para treinar (ajustar) a árvore de decisão. Para realizar o treinamento (fit), precisamos passar os parâmetros X e y, que conterão as características de treino e rótulos de treino respectivamente (linha 25):
arvore.fit(X=carac_treino, y=rot_treino)

Após treinado o algoritmo, vamos utilizar o método predict do objeto árvore, passando como argumento as características para teste. Como resultado, receberemos uma lista com os rótulos preditos (linha 27):
rot_preditos = arvore.predict(carac_teste)

Esse resultado será utilizado como parâmetro para a função accuracy_score, que calcula a acurácia do classificador, comparando os resultados preditos com os resultados reais (linha 28):
acuracia_arvore = accuracy_score(rot_teste, rot_preditos)

Analogamente, faremos o treinamento de um algoritmo de classificação utilizando o SVM, por meio da classe SVC (support vector classification) em que utilizaremos os valores padrão do construtor para o classificador (linhas 30 a 34):
clf = SVC()
clf.fit(X=carac_treino, y=rot_treino)
rot_preditos_svm = clf.predict(carac_teste)
acuracia_svm = accuracy_score(rot_teste, rot_preditos_svm)

No pós-processamento, vamos imprimir a acurácia de cada classificador (linhas 37 e 38):
print("Acurácia Árvore de Decisão:", round(acuracia_arvore, 5))
print("Acurácia SVM:", round(acuracia_svm, 5))

E imprimir também uma representação textual da árvore, utilizando a função export_text (linha 41):
r = export_text(arvore, feature_names=iris['feature_names'])

Observe que a acurácia do classificador SVC foi ligeiramente melhor que da árvore de decisão, 0,97 contra 0,92 da árvore.

Uma representação gráfica da árvore de decisão gerada pode ser vista na seguinte imagem:

Representação da árvore de decisão com profundidade 2.

Alterando a profundidade da árvore para 3 e executando novamente o programa, encontramos uma acurácia de 0,97 e a seguinte árvore é exibida na imagem a seguir:

Representação da árvore de decisão com profundidade 3.

Durante o treinamento de algoritmos, devemos experimentar diferentes parâmetros, a fim de encontrar o melhor resultado.

-------------------------------------------- ###
Como seria um exemplo de algoritmo não supervisionado usando Agrupamento?

Exemplos de algoritmo de agrupamento são k-means (k-medias) e mean-shift.

O objetivo de um algoritmo de agrupamento é reunir objetos de uma coleção que mantenham algum grau de afinidade. É utilizada uma função para maximizar a similaridade de objetos do mesmo grupo e minimizar entre elementos de outros grupos.

No próximo exemplo (script agrupamento.py), utilizaremos o algoritmo k-medias para gerar grupos a partir do dataset de Flor de Íris. Porém, como o agrupamento é um algoritmo não supervisionado, não utilizaremos os rótulos para treiná-lo. O algoritmo vai automaticamente separar as amostras em grupos, que serão visualizados em um gráfico.

Na etapa de pré-processamento, começaremos pela coleta e integração que é a obtenção do dataset de flores utilizando a função load_iris() (linha 8):
iris = load_iris()

Na linha 10 (caracteristicas = iris.data), separamos as características das flores na variável características. Lembrando que as características das flores são: comprimento da sépala (índice 0), largura da sépala (índice 1), comprimento da pétala (índice 2) e largura da pétala (índice 3).

Na etapa de mineração de dados, treinaremos o algoritmo de agrupamento K-medias com as características das flores. Para isso, criamos uma instância da classe KMeans passando como parâmetro o número de grupos (ou classes) que desejamos que o algoritmo identifique (n_clusters) (linha 13):
grupos = KMeans(n_clusters=3)

Passamos o número 3, pois sabemos que são 3 classes de flor, mas poderíamos alterar esse valor. O objeto grupos criado será utilizado para treinar (ajustar) o algoritmo. Para realizar o treinamento (fit), precisamos passar apenas parâmetros X, que conterão as características das flores (linha 14):
grupos.fit(X=caracteristicas)

Após o treino, podemos utilizar o atributo labels_ do objeto grupos para retornar uma lista com o índice do grupo ao qual cada amostra pertence. Como o número de grupos (n_clusters) é 3, o índice varia entre: 0, 1 e 2. Veja o código a seguir:

#script agrupamento.py
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.cluster import KMeans
from sklearn.datasets import load_iris

================== Pré-processamento ==================
# Coleta e Integração
iris = load_iris()

caracteristicas = iris.data

===================== Mineração =========================
grupos = KMeans(n_clusters=3)
grupos.fit(X=caracteristicas)
labels = grupos.labels_ # indice do grupo ao qual cada amostra pertence

================== Pós-processamento ======================
fig = plt.figure(1)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento Sépala')
ax.set_ylabel('Largura Sépala')
ax.set_zlabel('Comprimento Pétala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=grupos.labels_, edgecolor='k')

target = iris.target
fig = plt.figure(2)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento Sépala')
ax.set_ylabel('Largura Sépala')
ax.set_zlabel('Comprimento Pétala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=target, edgecolor='k')

plt.show()

A partir da linha 18, temos a etapa de pós-processamento, em que utilizamos a biblioteca Matplotlib para exibir dois gráficos, onde objetos do mesmo grupo apresentam a mesma cor:
fig = plt.figure(1)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento Sépala')
ax.set_ylabel('Largura Sépala')
ax.set_zlabel('Comprimento Pétala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=grupos.labels_, edgecolor='k')
target = iris.target
fig = plt.figure(2)
ax = Axes3D(fig)
ax.set_xlabel('Comprimento Sépala')
ax.set_ylabel('Largura Sépala')
ax.set_zlabel('Comprimento Pétala')
ax.scatter(caracteristicas[:, 0], caracteristicas[:, 1], caracteristicas[:, 2], c=target, edgecolor='k')

Observe os gráficos a seguir. O gráfico A contém os resultados do agrupamento e o gráfico B contém os resultados reais da amostra:

Gráfico: Resultado do agrupamento e Resultados reais da amostra.

------------------------------------------------------ ###
Como seria um exemplo de algoritmo supervisionado usando Classificação?
(para classificar frutas)

No exemplo abaixo é criado um código para classificar e saber se a fruta é uma pera ou uma laranja:

#treinamento supervisionado - classificação
from sklearn.tree import DecisionTreeClassifier, tree

lisa = 1
irregular = 0
pera = 1
laranja = 0

pomar = [[120,lisa],[140,lisa],[180,irregular],[200,irregular]]

resultado = [pera, pera, laranja, laranja]

#gerar uma árvore de decisão
clf = clf.fit(pomar, resultado)

peso = 220
# 1 para lisa e 0 para irregular
superfície = 0

resultadousu = clf.predict([[peso,superficie]])

if resultadousu == 1:
    print('Pera')
else:
    print('Laranja')

>>> Laranja


Caso tivesse alterado o peso para 140 e a superfície para 1 (lisa):
...
peso = 140
superfície = 1
...

O resultado impresso seria "Pera".

--------------------------------------------------------------- ###
Implementar uma solução em Python para estudar o comportamento de uma série temporal com Regressão Linear:

import numpy as np
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

x = np.array([5, 10, 15, 20, 25, 30]).reshape((-1, 1))
y = np.array([6, 12, 14, 23, 27, 32])

model = LinearRegression().fit(x, y)

#Predict a Response and Print it
y_pred = model.predict(x)
print('Dados do teste: ', y, sep='\n')
print('Dados da predição: ', y_pred, sep='\n')

plt.scatter(x, y, c= "blue")
plt.plot(x, y_pred, c="red")
plt.legend(['Predição', 'Real'])
plt.show()

Será impresso:
Dados do teste: [ 6 12 14 23 27 32]
Dados da predição: [ 5.85714286 11.11428571 16.37142857 21.62857143 26.88571429 32.14285714]

---------------------------------------------------------------- ###
Carregar dados da base load_digits, informar a quantidade de dados e visualizar os dados que foram carregados:

Para carregar dados da base load_digits e informar a quantidade de dados:

from sklearn.datasets import load_digits

digitos = load_digits()

#Existem 1797 imagens, sendo que cada uma tem uma dimensão de 8 x 8 = 64
print(f"Shape dos dados de imagens:{digitos.data.shape}")

#Apresentar o total de dados rotulados com inteiros de 0 a 9
print(f"Shape dos dados rotulados:{digitos.target.shape}")

>>> Shape dos dados de imagens:(1797, 64)
>>> Shape dos dados rotulados:(1797,)

---------------------

Para visualizar os dados que foram carregados:

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(14,4))
for index, (imagem, rotulo) in enumerate(zip(digitos.data[0:5], digitos.target[0:5])):

plt.subplot(1, 5, index + 1)
plt.imshow(np.reshape(imagem, (8,8)), cmap=plt.com.gray)
plt.title('Treinamento: { }\n'.format(rotulo, fontsize = 15))


Com isso o código todo ficaria assim:

import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import load_digits

digitos = load_digits()

#Existem 1797 imagens, sendo que cada uma tem uma dimensão de 8 x 8 = 64
print(f"Shape dos dados de imagens:{digitos.data.shape}")

#Apresentar o total de dados rotulados com inteiros de 0 a 9
print(f"Shape dos dados rotulados:{digitos.target.shape}")

plt.figure(figsize=(14,4))
for index, (imagem, rotulo) in enumerate(zip(digitos.data[0:5], digitos.target[0:5])):
    plt.subplot(1, 5, index + 1)
    plt.imshow(np.reshape(imagem, (8,8)), cmap=plt.cm.gray)
    plt.title("Treinamento: {}\n".format(rotulo , fontsize = 15))


Será impresso:

Shape dos dados de imagens:(1797, 64) 
Shape dos dados rotulados:(1797,)

---------------------------------------------------------- ###
Carregar dados da base load_digits, utilizar um modelo Regressão logística e utilizar o modelo Regressão logística treinado para fazer classificação.

Para carregar dados da base load_digits e utilizar um modelo Regressão logística:

from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler

digitos = load_digits()

#Treinamento
x_treino, x_teste, y_treino, y_teste = train_test_split(digitos.data, digitos.target, test_size=0.25, random_state=0)

pipe = make_pipeline(StandardScaler(), LogisticRegression())
pipe.fit(x_treino, y_treino)

Com isso foi impresso:



------------------

Para utilizar o modelo Regressão logística treinado para fazer classificação:

from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler

digitos = load_digits()

#Treinamento
x_treino, x_teste, y_treino, y_teste = train_test_split(digitos.data, digitos.target, test_size=0.25, random_state=0)

pipe = make_pipeline(StandardScaler(), LogisticRegression())
pipe.fit(x_treino, y_treino)

#Predição (Classificação)
previsto=pipe.predict(x_teste[0].reshape(1, -1))
real = y_teste[0]
print('previsto:{}; real:{}'.format(previsto[0], real))

Com isso foi impresso:
>>> previsto:2; real:2

Neste exemplo foi utilizado o valor de posição 0 em x_teste[0] e y_teste[0].
O load_digits possui 1796 elementos.

/////////////////////////////////////////////////////////////////////////////// &&&
ADICIONAR Depois

strip() remove espaços do texto no começo e fim (não remove o espaços entre as palavras)
O método strip() é usado para remover espaços em branco, incluindo novas linhas e tabulações, do início e do fim de uma string

split() ou split(',')
é usado para quebrar uma string em partes menores, retornando uma lista com essas partes

join()
retorna uma única string com todos os elementos da lista concatenados, utilizando determinado conector.

append() = para adicionar elementos em uma lista []

open / close / read = manipulação de arquivos
remove
rename


modulo os = fornece funções para interagir com o sistema operacional
os.mkdir(path)
os.rmdir(path) = remove um diretório vazio
os.scandir(path)
os.listdir(path) = Lista os arquivos e diretórios no caminho especificado
os.path.join(path, *paths) = junta componentes de caminhos de forma inteligente

shutil.move
os.makedirs()

função principal main:
def main():
    ...
if __name__ == "__main__":
    main()

PIL
Image.open

img.show() = Mostrar imagem

np.array(imagem) = converte uma imagem em array binário

np.fliplr(imagem) = inverte a imagem espelhadamente

img_data.tobytes() = converte os dados do array NumPy em uma sequência binária

-Os dados binários modificados são carregados de volta em um array NumPy com o mesmo formato e tipo de dados da imagem original usando np.frombuffer(data, dtype=np.uint8).reshape(img_data.shape)

datetime

f-strings

replace(old, new) = substituição

.title(frase) = Primeira letra de cada palavra em maiúscula

try/exception
tipos de exception

banco de dados








***
/////////////////////////////////////////////////////////////////// &&&
DESAFIOS DE LÓGICA

------------------------------ ###
Em Python, implementar uma solução que verifique se um número é par ou impar, considerando que:
numero = 43

if (numero%2==0):
  situacao = "par"
else:
  situacao = "ímpar"

print(f'O número é {situacao}')

>>> O número é ímpar

------------------------------ ###
Em Python, implementar uma solução que verifique se um número é par ou impar usando campo de preenchimento de texto:

numero = eval(input("Digite o número: "))

if (numero%2==0):
    situacao = "par"
else:
    situacao = "ímpar"

print(f'O número é {situacao}')

>>>Digite o Número: [   75   ]
>>>O número é ímpar

------------------------------- ###
Em Python, implementar uma solução que resolva:
(usando elif)

-Se a nota for maior ou igual a 7, o estudante está aprovado;

-Se a nota for menor que 7 e maior ou igual a 5, o estudante está em recuperação;

-Se a nota for menor que 5, o estudante está reprovado.

nota = eval(input("Nota do aluno: "))

if (nota >= 7):
    resultado = "Aprovado"
elif (nota >= 5):
    resultado = "em Recuperação"
else:  
    resultado = "Reprovado"

print(f"O aluno está {resultado}")

------------------------------------ ###
Em Python, implementar uma solução que resolva:
(sem usar elif)

-Se a nota for maior ou igual a 7, o estudante está aprovado;

-Se a nota for menor que 7 e maior ou igual a 5, o estudante está em recuperação;

-Se a nota for menor que 5, o estudante está reprovado.

nota = eval(input("Nota do aluno: "))

if (nota < 5):
    resultado = "Reprovado"
elif (nota < 7):
    resultado = "em Recuperação"
else:  
    resultado = "Aprovado"

print(f"O aluno está {resultado}")


Outra solução:

nota = eval(input("Nota do aluno: "))

if (nota >= 7):
    resultado = "Aprovado"
if (nota < 5):
    resultado = "Reprovado"
if (7 > nota >= 5 ):  
    resultado = "em Recuperação"

print(f"O aluno está {resultado}")

----------------------------------------- ###
Em Python, implementar uma solução que resolva:

-Calcular o valor de uma compra, sendo que o preço unitário é R$ 10,00

-Se for feita uma compra de até 10 unidades, não há desconto;

-Para compras entre 11 e 20 unidades é dado um desconto de 10%.

- Acima de 20 unidades, é dado um desconto de 20%.

#Alternativa 1:

preco = 10.00
desc10 = 0.1
desc20 = 0.2

quant = eval(input("Quantidade = "))

if (quant <= 10):
  textdesc = "0%"
  valorfinal = preco * quant

elif (quant <= 20 ):
  textdesc = "10%"
  desc = preco * quant * 0.1
  valorfinal = preco * quant * (1 - desc10)
#ou valorfinal = preco * quant * 0.9

else:
  textdesc = "20%"
  valorfinal = preco * quant * (1 - desc20)
#ou valorfinal = preco * quant * 0.8

print(f"O total sem desconto foi de R$ {preco * quant}")
print(f"O total aplicado foi de {textdesc}")
print(f"O total de desconto em reais foi de R$ {desc}")
print(f"O total gasto com desconto foi de R$ {valorfinal}")

-----------------------------------

#Alternativa 2:

preco = 10.00

quant = eval(input("quantidade = "))

total = quant * preco

if (quant >= 20):
  textdesc = "20%"
  desc = total * 20 / 100

elif (quant >= 15 ):
  textdesc = "10%"
  desc = total * 10 / 100

elif (quant > 10 ):
  textdesc = "5%"
  desc = total * 5 / 100

else:
  textdesc = "0%"
  desc = total * 0 / 100

totaldesc = total - desc

print(f"O total sem desconto foi de R$ {total}")
print(f"O desconto aplicado foi de {textdesc}")
print(f"O total de desconto em reais foi de R$ {desc}")
print(f"O total gasto com desconto foi = R$ {totaldesc}")

-----------------------------------

#Alternativa 3:

preco = 10.00

quant = eval(input("quantidade = "))

if (quant >= 20):
  textdesc = "20%"
  desc = (quant * preco) * 20 / 100

elif (quant >= 15 ):
  textdesc = "10%"
  desc = (quant * preco) * 10 / 100

elif (quant > 10 ):
  textdesc = "5%"
  desc = (quant * preco) * 5 / 100

else:
  textdesc = "0%"
  desc = (quant * preco) * 0 / 100

print(f"O total sem desconto foi de R$ {quant * preco}")
print(f"O desconto aplicado foi de {textdesc}")
print(f"O total de desconto em reais foi de R$ {desc}")
print(f"O total gasto com desconto foi de R$ {(quant * preco) - desc}")

----------------------------------------------------- ###
Em Python, implementar uma solução que some todos os pares de uma lista:

Por exemplo, se a lista for [10, 2, 5, 7, 6, 3], o resultado deve ser igual a 18.

Estratégia 1:

lista = [10, 2, 5, 7, 6, 3]

soma = 0
for num in lista:
     if (num%2==0):
         soma = soma + num

print(f"O somatório dos elementos pares da lista é: {soma}")
>>> O somatório dos elementos pares da lista é: 18

------------------------------------

Estratégia 2:

lista = [10, 2, 5, 7, 6, 3]
n = len(lista)
soma = 0
for i in range(n):
     if (lista[ i ]%2==0):
         soma = soma + lista[ i ]

print(f"O somatório dos elementos pares da lista é: {soma}")
>>> O somatório dos elementos pares da lista é: 18

------------------------------------------------------------ ###
Em Python, implementar uma solução que verifique se um número é par ou impar, considerando que:
numero = 43

if (numero%2==0):
  situacao = "par"
else:
  situacao = "ímpar"

print(f'O número é {situacao}')

>>> O número é ímpar

------------------------------------------------------------ ###
Em Python, implementar uma solução que verifique se um número é par ou impar usando campo de preenchimento de texto:

numero = eval(input("Digite o número: "))

if (numero%2==0):
    situacao = "par"
else:
    situacao = "ímpar"

print(f'O número é {situacao}')

>>>Digite o Número: [   75   ]
>>>O número é ímpar

------------------------------------------------------------ ###
Em Python, implementar uma solução que resolva:
(usando elif)

-Se a nota for maior ou igual a 7, o estudante está aprovado;

-Se a nota for menor que 7 e maior ou igual a 5, o estudante está em recuperação;

-Se a nota for menor que 5, o estudante está reprovado.

------------------------------------------------------------- ###
FATORIAL
A função matemática fatorial de um inteiro não negativo n é calculada por:

n!

Exemplo: 
3! = 3 x 2 x 1 = 6

ou seja:
n * (n - 1) * (n - 2) * (n - 3)...

Dependendo do valor de n, os resultados serão:
n = 0    => 1
n = 1    => 1 
n = 2    => 2 x 1 = 2
n = 3    => 3 x 2 x 1 = 6
n = 4    => 4 x 3 x 2 x 1 = 24
etc...

--------------------------------------------------------------- ###
FATORIAL + RECURSIVA
A função matemática fatorial de um inteiro não negativo n pode ser definida recursivamente por:

Se n = 0 ou 1       =>   1

Se n é maior ou igual a 2:
n * [(n-1)!]

Essa equação vem de:
n * (n - 1) * (n - 2) ......

---------------------------------------------------------------- ###
FATORIAL
Em Python, como seria um código para demonstrar fatorial?


def fatorial(n):
    if n == 0 or n == 1:
         return 1
    else:
         return n*fatorial(n-1)
print(fatorial(3))       #ou apenas fatorial(3)
>>> 6       

def fatorial(n):
    if n == 0 or n == 1:
         return 1
    else:
         return n*fatorial(n-1)
print(fatorial(1))       #ou apenas fatorial(1)
>>> 1

Para n maior ou igual 2, considere que:
n! = n * (n - 1) * (n - 2) * (n - 3) ......

Então é a mesma coisa que:
n! = n * [(n - 1)!]

Se n for 0 ou 1, então o resultado será 1.

Vale ressaltar que a função fatorial também poderia ter sido implementada de forma não recursiva, como é mostrado a seguir:

def fatorial(n):
    fat = 1
    if n == 0 or n == 1:
        return fat
    else:
        for x in range(2, n + 1):
               fat = fat*x
        return fat
fatorial(3)
>>> 6

------------------------------------------------------------ ###
RECURSIVA
Em Python, como seria uma possível implementação recursiva de função que determina o n-ésimo termo da sequência de Fibonacci?

A sequência de Fibonacci é: 1, 1, 2, 3, 5, 8, 13, 21...
Os dois primeiros termos são 1; a partir do 3º termo, cada termo é a soma dos dois anteriores. Então:

def fibo(n):
    if n == 1 or n == 2:
        return 1
    else:
        return fibo(n - 1) + fibo(n - 2)
fibo(6)
>>> 8       (o sexto número da sequência de fibonacci é o 8)

A linha 2 traz as condições de parada. A linha 5 traz as chamadas recursivas para calcular os dois termos anteriores da sequência.


#estratégia 02:  (está correto?????)
def fatorial_iterativo(n):
    f = 1
    for x in range(1, n+1):
        f = f * x
    return f

numero = 5
print(f"O fatorial de {numero} é {fatorial_iterativo(numero)}")

---------------------------------------------------------- ###
Em Python, usando função, implementar uma solução que retorne o menor elemento de uma lista, considerando:

lista_teste = [2, 10, 3, 1, 4, 5]

def encontrar_minimo (lista):
    minimo = lista[0]
    for elem in lista:
       if (elem < minimo):
           minimo = elem
    return minimo

lista_teste = [2, 10, 3, 1, 4, 5]
menor = encontrar_minimo(lista_teste)
print(f"O menor elemento da lista é {menor}")

>>> O menor elemento da lista é [ 1 ]

---------------------------------------------------------- ###
Em Python, usando função, implementar uma solução que some todos os elementos pares de uma lista. considerando:

lista = [10, 2, 5, 7, 6, 3]

def ehpar(n):
    r = (n%2==0)
    return r

def somar_par(lst):
     soma = 0 
     for num in lst:
         if (ehpar(num)):
              soma = soma + num
     return soma

lista = [10, 2, 5, 7, 6, 3]
soma = somar_par(lista)
print(f"O somatório dos elementos pares da lista é {soma}")

>>> O somatório dos elementos pares da lista é 18

----------------------------------------------------------- ###
Em Python, usando função, implementar uma solução que determine se um número é primo ou não.

Primo é divisível por ele mesmo ou por 1.

def eh_primo(n):
    if(n<2):
        return False
    x = n//2
    while (x > 1):
        if (n%x==0):
            return False
        x = x - 1
    return True

def imprimir_resultado(numero, resultado):
    mensagem = f"O número {numero} NÃO é primo"
    if (resultado):
        mensagem = f"O número {numero} é primo"
    return mensagem

numero = 7
resultado = eh_primo(numero)
msg = imprimir_resultado(numero, resultado)
print(msg)

>>> O número 7 é primo

---------------------------------------------------------- ###
Em Python, implementar uma solução que calcule as raízes de uma equação do segundo grau.
(Este arquivo não permite colocar os números sobreescritos, então está sem exponenciação)

Exemplo:
A equação x2 + 5x + 6 = 0 tem as raízes {-3, -2}

import math

a = int(input("Digite A: "))
b = int(input("Digite B: "))
c = int(input("Digite C: "))

delta = (b**2) - (4 * a * c)

if (delta < 0):
    print("A equação não possui raízes nos números reais")
elif (delta == 0):
    x = -b / (2 * a)
    print(f"A equação possui apenas a raiz: {x}")
else:
    x1 = ( -b - math.sqrt(delta)) / (2 * a)
    x2 = ( -b + math.sqrt(delta)) / (2 * a)
    print(f"A equação possui as raízes: {x1}, {x2}")


Explicando:

Equação do segundo grau:
ax2 + bx + c = 0      

As raizes de uma equação do 2o grau significam que o valor de x fará que o total seja 0.

A formula de báskara aponta que as raízes de uma equação do 2º grau do tipo ax2 + bx + c = 0 é dada pela seguinte relação:

Fórmula de Báskara:
x = ( -b +- √Δ ) / 2a  

Sendo:
Δ = b2 - 4ac

A função sqrt(x) do módulo math acha a raiz quadrada de x.

Exemplo:
import math
x = math.sqrt(4)
print(x)
>>> 2.0

Porém se Δ:
(Δ > 0): duas soluções para a equação 
(Δ = 0): as soluções da equação são repetidas;
(Δ < 0): não admite solução real.

----------------------------

Explicação do Professor:

def entrada_dados( ):
    coeficiente = quantidade = eval(input("Digite o valor do coeficiente: "))
    return coeficiente

def calc_delta(a,b,c):
    delta=b*b-4*a*c
    return delta

import numpy as np
def calcular_raizes(a,b,c,delta):
    if (delta < 0):
        resultado = "A equação não possui raízes nos números reais"
    elif (delta == 0):
        x = -b / (2 * a)
        resultado = f"A equação possui apenas a raiz: {x}"
    else:
        x1 = ( -b - math.sqrt(delta)) / (2 * a)
        x2 = ( -b + math.sqrt(delta)) / (2 * a)
        resultado = f"A equação possui as raízes: {x1}, {x2}"
    return resultado

# f(x) = ax**2 + b * x + c
a = entrada_dados( )
b = entrada_dados( )
c = entrada_dados( )

delta = calc_delta(a,b,c)

resultado = calcular_raizes(a,b,c,delta)
print(resultado)

>>> Digite o valor do coeficiente: [  1  ]
>>> Digite o valor do coeficiente: [  5  ]
>>> Digite o valor do coeficiente: [  6  ]
>>> a equação possui as raízes: -3.0, -2.0

---------------------------------------------------------- ###
Implementar um programa em Python para criar uma classe Veiculo com atributos de instância "velocidade máxima" e "quilômetros percorridos por litro" em que seja impresso:

Nome = Fusca
Velocidade Máxima = 180
Quilômetros percorridos por litro = 10

class Veiculo:
    def __init__(self, nome, velocidade_max, quilometro_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.quilometro_litro = quilometro_litro

    def Imprimir(self):
        print(f"Nome = {self.nome}")
        print(f"Velocidade Máxima = {self.velocidade_max}")
        print(f"Quilômetros percorridos por litro = {self.quilometro_litro}")

modelo_carro = Veiculo("Fusca", 180, 10)
modelo_carro.Imprimir()

>>> Nome = fusca
>>> Velocidade Máxima = 180
>>> Quilômetros percorridos por litro = 10

---------------------------------------------------------- ###
Em Python, crie uma classe filha "Ônibus" que herdará as variáveis e métodos da classe "Veículo" (que possui nome, velocidade máxima e quilometro por litro).

class Veiculo:
    def __init__(self, nome, velocidade_max, quilometro_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.quilometro_litro = quilometro_litro

    def Imprimir(self):
        print(f"Nome = {self.nome}")
        print(f"Velocidade Máxima = {self.velocidade_max}")
        print(f"Quilômetros percorridos por litro = {self.quilometro_litro}")

class Onibus(Veiculo):
    pass   #Não foi passado nenhum atributo novo. Apenas herdou os atributos e métodos de Veiculo

modelo_veiculo = Onibus("Scania", 120, 8)
modelo_veiculo.Imprimir()

>>> Nome = Scania 
>>> Velocidade Máxima = 120 
>>> Quilômetros percorridos por litro = 8


No exemplo acima a classe Onibus não adicionou nenhum novo atributo, apenas herdou os atributos e métodos da classe Veiculo. 
Com isso foi utilizada a instrução pass

Caso queira adicionar um ou mais atributos, é preciso incrementar o código. Por exemplo, caso queira adicionar o atributo "número de assentos":

class Veiculo:
    def __init__(self, nome, velocidade_max, quilometro_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.quilometro_litro = quilometro_litro

class Onibus(Veiculo):
    def __init__(self, nome, velocidade_max, quilometro_litro, assentos):
        Veiculo.__init__(self, nome, velocidade_max, quilometro_litro)
        self.assentos = assentos

    def Imprimir(self):
        print(f"Nome = {self.nome}")
        print(f"Velocidade Máxima = {self.velocidade_max}")
        print(f"Quilômetros percorridos por litro = {self.quilometro_litro}")
        print(f"Número de assentos = {self.assentos}")

modelo_veiculo = Onibus("Scania", 120, 8, 70)
modelo_veiculo.Imprimir()

>>> Nome = Scania 
>>> Velocidade Máxima = 120 
>>> Quilômetros percorridos por litro = 8 
>>> Número de assentos = 70


Exemplo do video:

class Veiculo:
    def __init__(self, nome, velocidade_max, quilometro_litro):
        self.nome = nome
        self.velocidade_max = velocidade_max
        self.quilometro_litro = quilometro_litro

    def capacidade_assentos(self, capacidade):
        print(f"A capacidade máxima de assentos do veículo {self.nome} é {capacidade}.")

    def Imprimir(self):
        print(f"Nome = {self.nome}")
        print(f"Velocidade Máxima = {self.velocidade_max}")
        print(f"Quilômetros percorridos por litro = {self.quilometro_litro}")

class Onibus(Veiculo):
    def capacidade_assentos(self, capacidade = 70):
        return super().capacidade_assentos(capacidade = 70)

onibus_escolar = Onibus("Scania", 120, 8)
onibus_escolar.Imprimir()
onibus_escolar.capacidade_assentos()


