CURSO linguagem C

-----------------------------------------------------&&&

INICIALIZAÇÃO

#include <stdio.h>

int main() {                  
  ....
  return 0;
}


OU TAMBÉM PODE SER:

#include <stdio.h>

int main(void) {                  
  ....
  return 0;
}


OBS: Só é necessário o ponto-virgula nas instruções dentro de funções, if, classes, etc...

OBS 2: Os arquivos na linguagem C possuem a extensão .c
Exemplo: nomedoprograma.c

OBS: 3: Na função main() o valor do return seria considerado como o valor de saída para a aplicação. E o valor 0 significado algo bem sucedido, enquanto outros valores seriam de erro.
return 0;     //inicialização bem sucedida
return 1;     //encerra a aplicação

OBS 4: A biblioteca <stdio.h> é uma biblioteca de arquivos de cabeçalho (header file library) que nos permite trabalhar com funções de entrada e saída, como exibir dados na tela ou ler valores digitados pelo usuário. Bibliotecas adicionam funcionalidade a programas C.

-----------------------------&&&

int main() e int main (void):

Ambas as definições funcionam em C também, mas a segunda definição com void é considerada tecnicamente melhor, pois especifica claramente que main só pode ser chamada sem nenhum parâmetro. Em C, se uma assinatura de função não especifica nenhum argumento, significa que a função pode ser chamada com qualquer número de parâmetros ou sem nenhum parâmetro.

Na linguagem C++ ter uma função foo(void) e foo() é a mesma coisa. No entanto, em C é diferente: foo(void) é uma função que não tem argumentos, enquanto foo() é uma função com argumentos não especificados.

Em um protótipo em C, uma lista de argumentos vazia significa que a função pode receber qualquer argumento (na definição de uma função, significa nenhum argumento).

-----------------------------------------------------&&&

PARA IMPRIMIR

#include <stdio.h>

int main() {
  printf("Texto de exemplo.");
  return 0;
}

OBS: Ao trabalhar com texto (strings) é necessário colocar entre aspas duplas:

printf("Esta instrução funciona!");
printf(Esta instrução dará um erro.);

-----------------------------------------------------&&&

QUEBRA DE LINHA

Para inserir uma nova linha, você pode usar o caractere \n:

#include <stdio.h>

int main() {
  printf("Texto de exemplo 1.\n");
  printf("Texto de exemplo 2.");
  return 0;
}

OBS: Dois \n criam uma linha em branco:
Exemplo: printf("Texto de exemplo 1.\n\n");

OUTRO EXEMPLO:

#include <stdio.h>

int main() {
  printf("Texto de exemplo 1.\nTexto de exemplo 2.\nTexto de exemplo 3.");
  return 0;
}

-----------------------------------------------------&&&

ESCAPE SEQUENCES:

\n = quebra de linha (vai pra linha de baixo)
\t = similar a tecla tab (dá um espaço grande horizontalmente)
\\ = insere o caractere de barra invertida = \
\ = insere o caractere de aspas duplas = "

SPECIAL CHARACTERS (DENTRO DE STRINGS DE TEXTO):
\' = aspas simples = '
\" = aspas duplas = "
\\ = backlash = \

\0 = NULL

-----------------------------------------------------&&&

COMENTÁRIOS

// = para comentários de 1 linha
Exemplo:
// Este é um comentário

/*  ....  */  = para comentários com mais de 1 linha
Exemplo:
/* 
Linha de comentário 1
Linha de comentário 2
Linha de comentário 3
*/


-----------------------------------------------------&&&

VARIAVEIS

Os nomes podem conter letras, numeros e sublinhados (underline = _ )
Os nomes devem começar com uma letra ou um sublinhado (_)
Os nomes diferenciam maiúsculas de minúsculas (myVar e myvar são variáveis ​​diferentes)
Os nomes não podem conter espaços em branco ou caracteres especiais como !, #, %, etc.
Palavras reservadas (como int, float, char, etc.) não podem ser usadas como nomes

Sintaxe 1:

tipo nomedavariavel;
nomedavariavel = valor;


Sintaxe2:

tipo nomedavariavel = valor;

-----------------------------------------------------&&&

PARA CRIAR VARIAVEIS DE NUMEROS INTEIROS
(numeros inteiros positivos e negativos, sem decimais)

#include <stdio.h>

int main() {
    int numero; 
    numero = 10;
    return 0;
}

----

#include <stdio.h>

int main() {
    int numero = 10; 
    return 0;
}

----

Para imprimir o numero inteiro, utiliza-se %d :

#include <stdio.h>

int main() {
    int numero = 10; 
    printf("%d", numero);
    return 0;
}

>>> 10

-----

Caso queira que o número possua 2 ou mais dígitos, utiliza-se %.xd (sendo x a quantidade de dígitos):

#include <stdio.h>

int main() {
    int numero = 7; 
    printf("%.2d", numero);          //especificou que quer que o número tenha 2 dígitos (antes da vírgula)
    return 0;
}

>>> 07

-----------------------------------------------------&&&

PARA CRIAR VARIAVEIS DE NUMEROS REAIS / DECIMAIS / PONTO FLUTUANTE
(numeros inteiros positivos e negativos, com decimais)

#include <stdio.h>

int main() {
    float numero; 
    numero = 10.37;
    return 0;
}

OBS: Utiliza-se o ponto (.) e não a virgula (,)

----

#include <stdio.h>

int main() {
    float numero = 10.37; 
    return 0;
}

----

Para imprimir o numero float, utiliza-se %f :

#include <stdio.h>

int main() {
    float numero = 10.37; 
    printf("%f", numero);
    return 0;
}

>>> 10.370000

----

#include <stdio.h>

int main() {
    float numero = 10.12345678901234567890; 
    printf("%f", numero);
    return 0;
}

>>> 10.123457

OBS: O tipo float consegue guardar apenas 6 ou 7 casas decimais. Para guardar mais, é preciso usar o tipo double.

----

Caso queira um numero especifico de casas decimais, utiliza-se %.xf (sendo x o numero de casas decimais):

printf("%.2f", numero);     // 2 casas decimais
printf("%.3f", numero);     // 3 casas decimais
printf("%.5f", numero);     // 5 casas decimais

caso queira especificar o numero de digitos e de casas decimais:

printf("%3.2f", numero);     // 3 digitos e 2 casas decimais
printf("%1.3f", numero);     // 1 digito e 3 casas decimais
printf("%8.5f", numero);     // 8 digitos e 5 casas decimais

----

Pode-se utilizar o tipo double para numeros decimais com até 15 casas decimais:
Para imprimir o numero double, utiliza-se %lf :

#include <stdio.h>

int main() {
    double numero = 45.12345678901234567890; 
    printf("%.15lf", numero);
    return 0;
}

>>> 45.123456789012344

OBS: O tipo double é mais preciso para fazer contas pois possui até 15 casas decimais, mas ocupa o dobro do espaço da memória (8 bytes vs. 4 bytes)

-----------------------------------------------------&&&

PARA CRIAR VARIAVEIS DE COM APENAS 1 CARACTERE (1 LETRA OU 1 NUMERO)

#include <stdio.h>

int main() {
    char letra; 
    letra = 'A';
    return 0;
}

OBS: Utiliza-se o caractere entre aspas simples

----

#include <stdio.h>

int main() {
    char letra = 'A';
    return 0;
}

----

Para imprimir um caractere, utiliza-se %c :

#include <stdio.h>

int main() {
    char letra = 'A';
    printf("%c", letra);
    return 0;
}

--------

ATENÇÃO!!!

Se tentar imprimir mais de 1 caractere, apenas o último caractere será impresso:

#include <stdio.h>

int main() {
    char texto = 'Texto de Exemplo';
    printf("%c", texto);
    return 0;
}

>>> o


-----------------------------------------------------&&&

PARA CRIAR VARIAVEIS DE TEXTO (STRING) COM MAIS DE 1 CARACTERE

#include <stdio.h>

int main() {
    char texto[];
    texto = "Texto de Exemplo";
    return 0;
}

OBS: Utiliza-se a string entre aspas duplas

----

#include <stdio.h>

int main() {
    char texto[] = "Texto de Exemplo";
    return 0;
}

----

Para imprimir uma string de texto, utiliza-se %s :

#include <stdio.h>

int main() {
    char texto[] = "Texto de Exemplo";
    printf("%s", texto);
    return 0;
}

>>> Texto de Exemplo


OBS: Ao utilizar os colchetes vazios, será impresso toda a string. Caso queira imprimir apenas parte do texto, é necessário especificar o numero de caracteres:

#include <stdio.h>

int main() {
    char texto[3] = "Texto de Exemplo";
    printf("%s", texto);
    return 0;
}

>>> Tex

OUTRA VERSÃO

#include <stdio.h>

int main() {
    char texto[] = "Texto de Exemplo";
    printf("%s", texto[3]);
    return 0;
}

>>> Tex


OBS: Caso fosse apenas 1 caractere, seria usado %c ao invés de %s :

#include <stdio.h>

int main() {
    char texto[] = "Texto de Exemplo";
    printf("%c", texto[0]);
    return 0;
}

>>> T

-----------------------------------------------------&&&

PARA COPIAR, MODIFICAR E ATRIBUIR VALORES PARA STRINGS DE TEXTO USANDO A BIBLIOTECA <string.h> E A FUNÇÃO strcpy()

Para copiar o valor de uma variavel:

Sintaxe:

#include <stdio.h>
#include <string.h>

int main() {
    char variavel1[] = "Texto";
    char variavel2[10];

    strcpy(variavel2, variavel1);      //variavel2 copiou o valor da variavel1
    printf("%s", variavel2);           //Para imprimir o valor copiado pela variavel2
    return 0;
};

>>> Texto

------

Para atribuir um valor a uma string:

Sintaxe:

#include <stdio.h>
#include <string.h>

int main() {
    char variavel[quantidade de caracteres];
    strcpy(variavel, "Texto");
    printf("%s", variavel);
    return 0;
};

OBS: É necessário especificar a quantidade máxima de caracteres que a string terá. Portanto não é possível deixar os colchetes vazios.

-----

#include <stdio.h>
#include <string.h>

int main() {
    char texto[30];
    strcpy(texto, "Texto de Exemplo");
    printf("%s", texto);
    return 0;
};

>>> Texto de exemplo

-----

#include <stdio.h>
#include <string.h>

int main() {
    char texto1[30] = "Texto de Exemplo";
    char texto2[30];
    strcpy(texto2, texto1);         //A variavel texto2 copiou os valores de texto1 
    printf("%s", texto2);
    return 0;
};

>>> Texto de exemplo

-----------------------------------------------------&&&

PARA COPIAR ELEMENTOS DE UMA STRING EM OUTRA VARIAVEL USANDO memcpy()

#include <stdio.h>
#include <string.h>

int main() {
    char txt1[10] = "Texto 1";
    char txt2[] = "Texto 2";

    memcpy(txt1, txt2, sizeof(txt2));      //Copiou o conteudo de txt2 em txt1

    printf("%s", txt1);

    return 0;
}

>>> Texto 2


-----------------------------------------------------&&&

PARA SABER A QUANTIDADE DE CARACTERES DE UMA STRING USANDO strlen()

#include <stdio.h>
#include <string.h>

int main() {
    char texto[] = "Texto de Exemplo";
    printf("%lu", strlen(texto));
    return 0;
};

>>> 16

OBS: Foi utilizado %lu ao invés de %d para evitar erros.

-----------------------------------------------------&&&

PARA CONCATENAR (JUNTAR) CARACTERES DE UMA STRING USANDO strcat()

#include <stdio.h>
#include <string.h>

int main() {
    char texto1[30] = "Texto ";
    char texto2[] = "de Exemplo";
    strcat(texto1, texto2);             //conteudo do texto2 foi adicionado ao texto1 
    printf("%s", texto1);
    return 0;
};

>>> Texto de Exemplo

-----------------------------------------------------&&&

PARA COMPARAR STRING DE TEXTO USANDO strcmp() 

#include <stdio.h>
#include <string.h>

int main() {
    char texto1[] = "Texto";
    char texto2[] = "Texto";
    char texto3[] = "de Exemplo";

    printf("%d", strcmp(texto1, texto2));       //Compara texto1 e texto2. Se forem iguais, imprimirá 0 (zero)

    printf("%d", strcmp(texto1, texto3));       //Compara texto1 e texto3. Se forem diferentes, imprimirá um valor diferente de zero

    return 0;
};

------

Versão alternativa usando ponteiro:

#include <stdio.h>
#include <string.h>

int main() {
    char *texto1 = "Texto";                     //usando um ponteiro ao invés da variável
    char *texto2 = "Texto";                     //usando um ponteiro ao invés da variável

    printf("%d", strcmp(texto1, texto2));       //Compara texto1 e texto2. Se forem iguais, imprimirá 0 (zero)

    return 0;
};

>>> 0

------------

#include <stdio.h>
#include <string.h>

int main() {
    char texto1[] = "Texto";
    char texto2[] = "de Exemplo";

    if (strcmp(texto1, texto2) == 0) {
        printf("As strings sao iguais.\n");
    } else {
        printf("As strings são diferentes.\n");
    }

    return 0;
};

>>> As strings são diferentes.

------------

#include <stdio.h>
#include <string.h>

int main() {
    char texto1[] = "texto";              //minúscula
    char texto2[] = "TEXTO";              //maiúscula

    if (strcmp(texto1, texto2) == 0) {
        printf("As strings sao iguais.\n");
    } else {
        printf("As strings são diferentes.\n");
    }

    return 0;
};

>>> As strings são diferentes.

Atenção!!!
Essa função leva em consideração maiúsculas e minúscula. Portanto A (maiúscula) é diferente de a (minúscula).

OBS: Caso a primeira letra da string venha depois, retornará um valor positivo. Caso venha antes, retornará um valor negativo.
Maiúsculas vem depois de minúsculas.

char texto1[] = "C";    
char texto2[] = "A";
printf("%d \n", strcmp(texto1, texto2));     //retorna 2 pois a letra C vem 2 letras depois da letra A

char texto1[] = "C";    
char texto2[] = "E";
printf("%d \n", strcmp(texto1, texto2));     //retorna -2 pois a letra C vem 2 letras antes da letra E

------------

Outro exemplo:


#include <stdio.h> 
#include <string.h>

int main() {
    // Declarando strings 
    char nome1[50] = "Alana"; 
    char nome2[] = " Silva";

    // Concatenando strings
    strcat (nome1, nome2);
    printf("Nome completo: %s\n", nome1);

    // Medindo o comprimento da string concatenada
    int comprimento = strlen(nome1);
    printf("Comprimento do nome completo: %d\n", comprimento);

    // Comparando strings
    if (strcmp(nome1, "Alana Silva") == 0) {
        printf("As strings sao iguais.\n");
    } else {
        printf("As strings são diferentes.\n");
    }

    //Copiando uma string para outra
    char copia[50];
    strcpy(copia, nome1);
    printf("Copia do nome: %s\n", copia);

    return 0;
}

>>> Nome completo: Alana Silva
>>> Comprimento do nome completo: 11
>>> As strings sao iguais.
>>> Copia do nome: Alana Silva

-----------------------------------------------------&&&

PARA COMPARAR STRING DE TEXTO SEM DISTINÇÃO ENTRE MAIUSCULA E MINUSCULA USANDO strcasecmp() 

A função strcasecmp() compara string1 e string2 sem distinção entre maiúsculas e minúsculas. Todos os caracteres alfabéticos em string1 e string2 são convertidos em minúsculas antes da comparação.

Valores de retorno de strcasecmp():

- Menos de 0 se a string1 for menor que string2
- 0	se a string1 for equivalente a string2
- Maior que 0	se a string1 for maior que string2


#include <stdio.h>
#include <strings.h>

int main() {
  char str1[] = "ana";
  char str2[] = "ANA";

  int resultado;

  resultado = strcasecmp(str1, str2);

  if (resultado == 0) {
    printf("As strings são iguais.");
  }  
  else {
    printf("As strings são diferentes.");
  }
   
  return 0;
}

>>> As strings são iguais.                      //strcasecmp() não diferencia maiuscula de minuscula


-----------------------------------------------------&&&

MODIFICANDO UM CARACTERE DE UMA STRING ATRAVÉS DE SEU INDICE

#include <stdio.h>

int main() {
    char texto[] = "Pato";
    texto[0] = 'R';               //Aspas simples pois estou alterando um único caractere
    printf("%s", texto);
    return 0;
};

>>> Rato

Alterou o primeiro caractere (indice 0) da palavra Pato.

----

#include <stdio.h>

int main() {
    char texto[] = "Pato";
    texto[3] = 'a';               
    printf("%s", texto);
    return 0;
};

>>> Pata

Alterou o quarto caractere (indice 3) da palavra Pato.



-----------------------------------------------------&&&

PARA USAR ASCII PARA IMPRIMIR CARACTERES

#include <stdio.h>

int main() {
    char a = 65, b = 66, c = 67;
    printf("%c", a);
    printf("%c", b);
    printf("%c", c);
    return 0;
}

>>> ABC

OBS: 
A = 65 na linguagem ASCII
B = 66 na linguagem ASCII
C = 67 na linguagem ASCII

-----------------------------------------------------&&&

FORMAT SPECIFIERS (PLACEHOLDERS)

%d = para numeros inteiros do tipo int (formato mais usado)
%i = para numeros inteiros do tipo int

%f = para numero decimais do tipo float com até 6 ou 7 digitos (formato mais usado)
%F = para numero decimais do tipo float com até 6 ou 7 digitos

%lf = para numero decimais do tipo double com até 15 digitos

%c = para 1 caractere, numero ou letra do tipo char

%s = para strings de texto com mais de 1 caractere do tipo char


-----------------------------------------------------&&&

PARA IMPRIMIR TEXTO JUNTO COM VARIAVEIS

#include <stdio.h>

int main() {
    int num = 15;
    printf("Numero: %d", num);
    return 0;
}

--------

#include <stdio.h>

int main() {
    char nome = 'Carlos';
    int idade = 15;
    printf("%c tem %d anos de idade", nome , idade);
    return 0;
}

>>> Carlos tem 15 anos de idade


-----------------------------------------------------&&&

MUDAR VALOR DE UMA VARIAVEL

...
int numero = 15;  
numero = 10;  
...


-----------------------------------------------------&&&

VARIAVEL RECEBER O VALOR DE OUTRA VARIAVEL

...
int numero1 = 15;  
int numero2 = 30 
int numero2 = numero1       //numero2 passa a ter o valor 15
...


-----------------------------------------------------&&&

CALCULO USANDO VARIAVEIS

...
int x = 5;
int y = 6;
int soma = x + y;
printf("%d", soma);
...

-------------------------

...
int x = 5, y = 6, z = 50;
printf("%d", x + y + z);
...

-------------------------

...
int x, y, z;
x = y = z = 50;
printf("%d", x + y + z);
...

-----------------------------------------------------&&&

TIPOS DE OPERAÇÃO MATEMATICA

Soma / Adição:
int total = x + y;

Subtração:
int total = x - y;

Multiplicação:
int total = x * y;

Divisão:
int total = x / y;

Módulo / Modulus (Retorna o resto de uma divisão de numeros inteiros):
int total = x % y;

Incremento (aumenta o valor de uma variavel em 1):
int total = ++x;    é igual a    int total = x + 1;

Decremento (diminui o valor de uma variavel em 1):
int total = --x;    é igual a    int total = x - 1;

Assignment Operators:
x += 5;      é igual a        x = x + 5;
x -= 5;      é igual a        x = x - 5;
x *= 5;      é igual a        x = x * 5;
x /= 5;      é igual a        x = x / 5;
x %= 5;      é igual a        x = x % 5;

x &= 3   igual	 x = x & 3
x |= 3	 igual   x = x | 3
x ^= 3	 igual   x = x ^ 3
x >>= 3	 igual   x = x >> 3
x <<= 3	 igual   x = x << 3

-----------------------------------------------------&&&

POTENCIA DE 10 EM NUMEROS FLOAT E DOUBLE
(quantos zeros serão adicionados à direita do numero = numero * 10)

#include <stdio.h>

int main() {
    float numero = 3e2;              //ou    float num = 3E2;
    printf("%f", numero);
    return 0;
}

>>> 300.000000

Foram adicionados 2 zeros a direita do numero 
(3 x 10 x 10)

----

#include <stdio.h>

int main() {
    double numero = 2e4;              //ou    double numero = 2E4;
    printf("%lf", numero);
    return 0;
}

>>> 20000.000000

Foram adicionados 4 zeros a direita do numero 
(2 x 10 x 10 x 10 x 10)


-----------------------------------------------------&&&

BASIC DATA TYPES:
(Tipos básicos de dados)

int (ocupa 2 ou 4 bytes) = numeros inteiros, sem decimais
float (ocupa 4 bytes) = numeros decimais com até 6 ou 7 digitos
double (ocupa 8 bytes) = numeros decimais com até 15 digitos
char (ocupa 1 byte) = apenas 1 caractere, letra ou numero


OBS: se uma string de texto (que usa o tipo char) tiver mais de 1 caractere, o tamanho irá variar. Por exemplo:

char texto = "ABCD";     

Ocupará 5 bytes pois:
char (\0) = ocupa 1 byte       *sizeof também inclui o caractere \0 quando conta
A = ocupa 1 byte
B = ocupa 1 byte
C = ocupa 1 byte
D = ocupa 1 byte
Totalizando 5 bytes

-----------------------------------------------------&&&

PARA SABER O TAMANHO DE BYTES OCUPADO NA MEMORIA

Sintaxe:
printf("%lu", sizeof(variavel));

OBS: Note que foi usado %lu para imprimir o resultado, em vez de %d. Isso ocorre porque o compilador espera que o operador sizeof retorne um long unsigned int (%lu), em vez de int (%d). Em alguns computadores, pode funcionar com %d, mas é mais seguro usar %lu.

--------------------

#include <stdio.h>

int main() {
    int numero = 1;
    printf("%lu", sizeof(numero));
    return 0;
}

>>> 4

OBS: O valor ocupado será 4 bytes, não importando a quantidade de digitos que o numero tenha ou se foi declarado o valor ou não.

--------------------

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};

    printf("%lu", sizeof(numeros));

    return 0;
}

>>> 16

OBS: O valor ocupado será de 16 bytes pois cada um dos 4 numeros int ocupa 4 bytes (4 + 4 + 4 + 4 = 16).

-------------------

#include <stdio.h>

int main() {
    float numero = 1.123456789;
    printf("%lu", sizeof(numero));
    return 0;
}

>>> 4

OBS: O valor ocupado será 4 bytes, não importando a quantidade de digitos que o numero tenha ou se foi declarado o valor ou não.

-------------------

#include <stdio.h>

int main() {
    double numero = 1.123456789;
    printf("%lu", sizeof(numero));
    return 0;
}

>>> 8

OBS: O valor ocupado será 8 bytes, não importando a quantidade de digitos que o numero tenha ou se foi declarado o valor ou não.

------------------

#include <stdio.h>

int main() {
    char letra = 'A';
    printf("%lu", sizeof(letra));
    return 0;
}

>>> 1

OBS: O valor ocupado será 1 byte, não importando se foi declarado o valor ou não.

------------------

#include <stdio.h>

int main() {
    char texto[] = "TEXTO";
    printf("%lu", sizeof(texto));
    return 0;
}

>>> 6

OBS: Ocupará 6 bytes pois:
char (\0) = 1 byte        *sizeof também inclui o caractere \0 quando conta
T = 1 byte
E = 1 byte
X = 1 byte
T = 1 byte
O = 1 byte

-----------------------------------------------------&&&

CONVERTER TIPOS DE VARIAVEIS

-Conversão Implícita:

int numero = 9.99;

printf("%d", numero); 

>>> 9

--------

float numero = 9;

printf("%f", numero); 

>>> 9.000000

--------

float total = 5 / 2;

printf("%f", total); 

>>> 2.000000        

OBS: Por que o resultado é 2,00000 e não 2,5? 
Bem, é porque 5 e 2 ainda são inteiros (int) na divisão. 
Neste caso, você precisa converter manualmente os valores inteiros para valores de ponto flutuante.

--------

- Conversão Explícita:

float total = (float) 5 / 2;

printf("%f", total);  

>>> 2.500000

--------

int num1 = 5;
int num2 = 2;
float total = (float) num1 / num2;

printf("%f", total);  

>>> 2.500000

-------

int num1 = 5;
int num2 = 2;
float total = (float) num1 / num2;

printf("%.2f", total);  

>>> 2.50

-----------------------------------------------------&&&

VARIAVEIS CONSTANTES (QUE NÃO MUDAM)

Sintaxe:
const tipo variavel = valor;

------

const int NUMERO = 60;

printf("%d", NUMERO);

>>> 60

OBS: é considerado uma boa prática declará-los com letras maiúsculas.
Não é obrigatório, mas é útil para legibilidade de código e comum para programadores C

------

const int NUMERO = 60;
numero = 20;

printf("%d", NUMERO);

>>> ERRO

-----------------------------------------------------&&&

PARA DEFINIR UMA VARIAVEL CONSTANTE USANDO #define
(parecido com uma variável global)

Sintaxe: 

#define VARIAVEL VALOR

OBS: Não há ponto-virgula (;) após a instrução!!!

---------

#include <stdio.h>

#define NUMERO 10

int main() { 

  printf("%d", NUMERO);

  return 0;
}

>>> 10

----------

#include <stdio.h>

#define NUMERO 10

int main() {

  int num = NUMERO;  

  printf("%d", num);

  return 0;
}

>>> 10

-----------

#include <stdio.h>

#define X 10
#define Y 5

int main() {

  int soma = X + Y;  

  printf("%d", soma);

  return 0;
}

>>> 15

------------

Criando 1 variavel constante de string de texto

#include <stdio.h>

#define TXT "Texto"

int main() {

  printf("%s", TXT);

  return 0;
}

>>> Texto

-----------

Criando mais de uma 1 variavel constante de string de texto

#include <stdio.h>

#define TXT1 "Texto "
#define TXT2 "de exemplo"

int main() {
  
  char txt[20] = TXT1;
  
  strcat(txt, TXT2);

  printf("%s", txt);

  return 0;
}

>>> Texto de exemplo


Versão alternativa:

#include <stdio.h>
#include <string.h>

#define TXT1 "Texto "
#define TXT2 "de exemplo"

int main() {
  
  char txt[20];
  
  strcpy(txt, TXT1);
  strcat(txt, TXT2);

  printf("%s", txt);

  return 0;
}

>>> Texto de exemplo

-----------

#include <stdio.h>

#define TAMANHO 20

int main() {
  
  char nome[TAMANHO] = "Ana Silva";

  printf("%s", nome);

  return 0;
}

>>> Ana Silva


-----------------------------------------------------&&&

OPERADORES BOOLEANOS (COMPARAÇÃO)

int x = 5;
int y = 3;
printf("%d", x > y);

Retornará 1 pois é verdade (5 é maior que 3).
Caso fosse falso, retornaria 0 (zero)

----

printf("%d", 10 > 2);

Retornará 1 pois é verdade (10 é maior que 2).
Caso fosse falso, retornaria 0 (zero)

----

x == y    Igual
x != y    Não é igual / Diferente
x > y     Maior que
x < y     Menor que
x >= y    Maior ou igual
x <= y    Menor ou igual

-----------------------------------------------------&&&

OPERADORES LÓGICOS

int x = 4;
printf("%d", 10 > x && x > 2);

Retornará 1 pois é verdade (4 é maior que 2 e menor que 10).
Caso fosse falso, retornaria 0 (zero)

--------

x < 5 && x < 10      E = Se as condições forem verdadeiras
x < 5 || x < 10      OU = Se pelo menos uma das condições for verdadeira


!(x > 5)             NÃO = inverte o valor de falso e verdadeiro
!(x < 5 && x < 10)

-----------------------------------------------------&&&

VARIAVEIS BOOLEANAS (VERDADEIRO E FALSO) USANDO <stdbool.h>

#include <stdio.h>
#include <stdbool.h>

int main() {

    bool verdadeiro = true;
    bool falso = false;

    printf("%d", verdadeiro);   // Returna 1 (true)
    printf("%d", falso);        // Returna 0 (false)

    return 0;
};

---------

#include <stdio.h>
#include <stdbool.h>

int main() {

    bool animal1 = true;
    bool animal2 = true;

    printf("%d", animal1 == animal2);   // Returna 1 (true)

    return 0;
};

-----------------------------------------------------&&&

CONDICIONAL IF / ELSE / ELSE IF

Sintaxe:

if (condição) {
    instrução se a condição for verdadeira;
} else {
    instrução se a condição for falsa;
};

-----

if (20 > 18) {
  printf("20 é maior que 18");
};

------

int x = 20;
int y = 18;
if (x > y) {
  printf("x é maior que y");
};

------

if (20 > 18) {
  printf("20 é maior que 18");
} else {
  printf("20 é menor que 18");
};

------

int idade = 25;
int podevotar = 16;

if (idade >= podevotar) {
  printf("Tem idade para poder votar.");
} else {
  printf("Não pode votar ainda.");
};

------

int numero = 5;

if (numero % 2 == 0) {
  printf("O numero é par.");
} else {
  printf("O numero é impar.");
}

------

Sintaxe:

if (condição) {
    instrução se a condição for verdadeira;
} else {
    instrução se a condição for falsa;
};

if (condição1) {
    instrução se a condição1 for verdadeira;
} else if (condição2) {
    instrução se a condição1 for falsa e a condição2 for verdadeira;
} else {
    instrução se condição1 e condição2 forem falsas;
}

------

int hora = 22;

if (hora < 12) {
  printf("Bom dia.");
} else if (hora < 18) {
  printf("Boa tarde.");
} else {
  printf("Boa noite.");
}

-------

int numero = 10; 

if (numero > 0) {
  printf("O numero é positivo.");
} else if (numero < 0) {
  printf("O numero é negativo.");
} else {
  printf("O numero é 0.");
}

-----------------------------------------------------&&&

IF / ELSE / ELSE IF COM STRINGS DE TEXTO

#include <stdio.h>
#include <string.h>

int main() {
    char fruta[] = "banana";
    
    if (strcmp(fruta, "morango") == 0) {
        printf("A fruta é o morango.");
    } 
    else if (strcmp(fruta, "banana") == 0) {
        printf("A fruta é a banana.");
    } 
    else {
        printf("A fruta não é morango e nem banana.");
    }
    
    return 0;
}

-----------------------------------------------------&&&

OPERADOR TERNARIO (CONDICIONAL) 

Sintaxe:

variavel = (condição) ? verdadeiro : falso;

-------

int numero = 20;
(numero < 10) ? printf("Menor que 10.") : printf("Maior que 10.");

>>> Maior que 10.


Isso é o mesmo que:

int numero = 20;

if (numero < 10) {
    printf("Menor que 10.");
} else {
    printf("Maior que 10.");
};

-----------------------------------------------------&&&

SWITCH (CONDICIONAL)

Sintaxe:

tipo variavel = valor;

switch (variavel) {
  case x:
    instrução se a variavel for igual a x.
    break;
  case y:
    instrução se a variavel for igual a y.
    break;
  default:
    instrução se a variavel for diferente de x ou y.
}

OBS: O default é opcional.

------

char letra = 'B';

switch (letra) {
  case ('A'):
    printf("A letra é o A.");
    break;
  case ('B'):
    printf("A letra é o B.");
    break;
  default:
    printf("A letra não é A e nem B.");
}

------

int dia = 4;

switch (dia) {
  case 1:
    printf("Segunda");
    break;
  case 2:
    printf("Terça");
    break;
  case 3:
    printf("Quarta");
    break;
  case 4:
    printf("Quinta");
    break;
  case 5:
    printf("Sexta");
    break;
  case 6:
    printf("Sábado");
    break;
  case 7:
    printf("Domingo");
    break;
}

-------

A função switch não funciona com strings de texto. Então é preciso usar o if/else com strcmp():

#include <stdio.h>
#include <string.h>

int main() {
    char fruta[] = "banana";
    
    if (strcmp(fruta, "morango") == 0) {
        printf("A fruta é o morango.");
    } 
    else if (strcmp(fruta, "banana") == 0) {
        printf("A fruta é a banana.");
    } 
    else {
        printf("A fruta não é morango e nem banana.");
    }
    
    return 0;
}

-----------------------------------------------------&&&

LOOP USANDO A FUNÇÃO WHILE() E DO/WHILE()

Sintaxe:

while (condição) {
    instrução caso a condição seja verdadeira;
}

--------

int i = 0;

while (i < 5) {
  printf("%d\n", i);
  i++;
}

>>> 0
>>> 1
>>> 2
>>> 3
>>> 4

--------

Sintaxe:

do {
  instrução;
}
while (condição);


OBS: O loop sempre será executado pelo menos uma vez, mesmo que a condição seja falsa, porque o bloco de código é executado antes que a condição seja testada:

---------

int i = 0;

do {
  printf("%d\n", i);
  i++;
}
while (i < 5);

>>> 0
>>> 1
>>> 2
>>> 3
>>> 4

----------

“do/while”
A condição é testada no final.

int i = 0;

do {
    printf("%d", i);
    i++;
} 

while (i < 0);

>>> 0

“while”
A condição é testada no início.

int i = 0;

while (i < 0) {
    printf("%d", i);
    i++;
}

>>> Não é impresso nada

----------

int countdown = 3;

while (countdown > 0) {
  printf("%d\n", countdown);
  countdown--;
}

printf("Happy New Year!!\n");

-----------

int i = 0;

while (i <= 10) {
  printf("%d\n", i);
  i += 2;
}

----------

// A variable with some specific numbers
int numbers = 12345;

// A variable to store the reversed number
int revNumbers = 0;

// Reverse and reorder the numbers
while (numbers) {
  revNumbers = revNumbers * 10 + numbers % 10;          // Get the last number of 'numbers' and add it to 'revNumber'
  numbers /= 10;        // Remove the last number of 'numbers'
}

-----------------------------------------------------&&&

LOOP USANDO A FUNÇÃO FOR()

Sintaxe:

for (variavel = valor ; condição ; instrução) {
    intrução 1;
    intrução 2;
    intrução 3;
    ...
}


---------

#include <stdio.h>

int main() {

    char numeros[] = {1, 2, 3, 4, 5};
    int i;

    for (i = 0; i < 5; ++i) {
        printf("%d\n", numeros[i]);
    }

    return 0;
}

>>> 1
>>> 2
>>> 3
>>> 4
>>> 5


OBS: O tipo de i pode ser declarado dentro dos parenteses:

...
    for (int i = 0; i < 5; ++i) {
        ....
    }
...

--------

#include <stdio.h>

int main() {

    char numeros[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int i;

    for (i = 0; i <= 10; i = i + 2) {
        printf("%d\n", numeros[i]);
    }

    return 0;
};

>>> 0
>>> 2
>>> 4
>>> 6
>>> 8

--------

Tabela de multiplicação:

#include <stdio.h>

int main() {
    int numero = 2;
    int i;

    for (i = 1; i <= 10; i++) {
    printf("%d x %d = %d\n", numero, i, numero * i);
    }

    return 0;
}

--------

#include <stdio.h>

int main() {

    char carro[] = "Volvo";
    int i;

    for (i = 0; i < 5; ++i) {
        printf("%c\n", carro[i]);
    }

    return 0;
}

>>> V
>>> O
>>> L
>>> V
>>> O

--------

#include <stdio.h>

int main() {

    char pessoas[] = {"Ana", "Bruno", "Carlos"};
    int i;

    for (i = 0; i < 3; ++i) {
        printf("%s\n", pessoas[i]);
    }

    return 0;
}

>>> V
>>> O
>>> L


-----------------------------------------------------&&&

BREAK / CONTINUE

int i;

for (i = 0; i < 10; i++) {
  if (i == 4) {
    break;
  }
  printf("%d\n", i);
}

>>> 0
>>> 1
>>> 2
>>> 3

---------

int i = 0;

while (i < 10) {
  if (i == 4) {
    break;
  }
  printf("%d\n", i);
  i++;
}

>>> 0
>>> 1
>>> 2
>>> 3

---------

int i;

for (i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  printf("%d\n", i);
}

>>> 0
>>> 1
>>> 2
>>> 3
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9

--------

int i = 0;

while (i < 10) {
  if (i == 4) {
    i++;
    continue;
  }
  printf("%d\n", i);
  i++;
}

>>> 0
>>> 1
>>> 2
>>> 3
>>> 5
>>> 6
>>> 7
>>> 8
>>> 9

-----------------------------------------------------&&&

ARRAYS / VETORES / MATRIZ UNIDIMENSIONAL

Sintaxe:
tipo array[] = {item0, item1, item2, item3};

-------

int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

OBS: Só é possível colocar o itens do mesmo tipo dentro do array.

-------

Especificando a quantidade de itens que o array terá:

int lista[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

-------

int numeros[] = {2, 5, 7, 10};

printf("%d", numeros[0]);         //Imprime o primeiro item do array (posição 0)
printf("%d", numeros[1]);         //Imprime o segundo item do array (posição 1)
printf("%d", numeros[2]);         //Imprime o terceiro item do array (posição 2)
printf("%d", numeros[3]);         //Imprime o quarto item do array (posição 3)

--------

float numeros[] = {2.123 , 1.76878 , 7.23451 , 10.987};
    
printf("%f", numeros[1]);         //Imprime o segundo item do array (posição 1)

--------

char letras[] = {'A', 'B', 'C', 'D'};
    
printf("%c", letras[2]);         //Imprime o terceiro item do array (posição 2)

--------

char *pessoas[] = {"Ana", "Bruno", "Carlos", "Daniel"};
    
printf("%s", pessoas[3]);         //Imprime o quarto item do array (posição 3)

OBS: Note que foi utilizado o ponteiro *pessoas e não a variavel pessoas.
Em C, você precisa usar um array de ponteiros de caracteres (char *pessoas[]) para armazenar várias strings.
Quando você usa char pessoas[] com chaves contendo strings literais, o compilador trata isso como uma tentativa de inicializar um único array de caracteres com vários valores, o que causa um erro.

-----------------------------------------------------&&&

Especificando o tamanho de um array:

#include <stdio.h>

int main(){

  int lista[4] = {1, 2, 3, 4};              //O array poderá ter no máximo 4 itens

  printf("%d \n", lista[0]);
  printf("%d \n", lista[1]);
  printf("%d \n", lista[2]);
  printf("%d \n", lista[3]);

  return 0;
}

>>> 1
>>> 2
>>> 3
>>> 4

-----

Agora observe o que ocorre se colocarmos um tamanho menor comparado à quantidade de itens dentro do array:

#include <stdio.h>

int main(){

  int lista[2] = {1, 2, 3, 4};            //O array poderá ter no máximo 2 itens

  printf("%d \n", lista[0]);
  printf("%d \n", lista[1]);
  printf("%d \n", lista[2]);
  printf("%d \n", lista[3]);

  return 0;
}

>>> 1
>>> 2
>>> 0
>>> 0

É o mesmo que aconteceria se fizesse:

#include <stdio.h>

int main(){

  int lista[2] = {1, 2};                //O array poderá ter no máximo 2 itens

  printf("%d \n", lista[0]);
  printf("%d \n", lista[1]);
  printf("%d \n", lista[2]);            //Este item não existe
  printf("%d \n", lista[3]);            //Este item não existe

  return 0;
}

>>> 1
>>> 2
>>> 0
>>> 0

-----

#include <stdio.h>

int main(){

    char txt[5] = "Texto";            //A string terá 5 caracteres
    
    printf("%s", txt);

  return 0;
}

>>> Texto

----

#include <stdio.h>

int main(){

    char txt[3] = "Texto";            //A string terá 3 caracteres
    
    printf("%s", txt);

  return 0;
}

>>> Tex                               //Apenas os 3 primeiros caracteres são impressos


-----------------------------------------------------&&&

PARA UTILIZAR UM LOOP PARA IMPRIMIR ITENS DE UM ARRAY

#include <stdio.h>

int main() {

  int numeros[] = {25, 50, 75, 100};

  for (int i = 0; i < 4; i++) {
    printf("%d\n", numeros[i]);
  }
  
  return 0;
}

>>> 25
>>> 50
>>> 75
>>> 100

ATENÇÃO!!!
Esta forma não é a ideal, pois só funcionará para arrays de um tamanho especificado.
No entanto, usando a fórmula sizeof(), podemos fazer loops que funcionam para arrays de qualquer tamanho, o que é mais sustentável.

#include <stdio.h>

int main() {

  int numeros[] = {25, 50, 75, 100};
  int tamanho = sizeof(numeros) / sizeof(numeros[0]);

  for (int i = 0; i < tamanho; i++) {
    printf("%d\n", numeros[i]);
  }
  
  return 0;
}

>>> 25
>>> 50
>>> 75
>>> 100

------

#include <stdio.h>

int main() {
  
  char txt[] = "texto de exemplo";
  
  for (int i = 0; i < sizeof(txt); i++) {
    printf("%c", txt[i]);
  }
  
  return 0;
}

>>> texto de exemplo

------

#include <stdio.h>

int main() {

  char *nomes[] = {"Ana", "Bruno", "Carlos"};
  int tamanho = sizeof(nomes) / sizeof(nomes[0]);

  for (int i = 0; i < tamanho; i++) {
    printf("%s\n", nomes[i]);
  }
  
  return 0;
}

>>> Ana
>>> Bruno
>>> Carlos

------

USANDO WHILE AO INVÉS DE FOR

#include <stdio.h>

int main() {

  int numeros[] = {10, 20, 30, 40, 50};
  int tamanho = sizeof(numeros) / sizeof(numeros[0]);
  int i;

  while (i < tamanho) {
    printf("%d\n", numeros[i]);
    i++;
  }
  
  return 0;
}

>>> 10
>>> 20
>>> 30
>>> 40
>>> 50

-----------------------------------------------------&&&

PARA MUDAR O VALOR DE UM ITEM DE UM ARRAY

int lista[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

lista[5] = 17;     //Alterou o item na posição 5 para o valor 17
  
for (int i = 0; i < 9; i++) {
    printf("%d\n", lista[i]);
}

>>> 1
>>> 2
>>> 3
>>> 4
>>> 5
>>> 17
>>> 7
>>> 8
>>> 9

-----------

int numeros[4];     // Criou um array com 4 posições

numeros[0] = 25;    // Atribuiu valor para o item na posição 0
numeros[1] = 50;    // Atribuiu valor para o item na posição 1
numeros[2] = 75;    // Atribuiu valor para o item na posição 2
numeros[3] = 100;   // Atribuiu valor para o item na posição 3

-----------------------------------------------------&&&

PARA SABER O TAMANHO (EM BYTES) DE UM ARRAY

int numeros[] = {10, 25, 50, 75, 100};

printf("%lu", sizeof(numeros));  

>>> 20

Cada um dos 5 elementos int do array ocupa 4 bytes
(5 x 4 = 20)

-----------------------------------------------------&&&

PARA SABER A QUANTIDADE DE ELEMENTOS EM UM ARRAY

int lista[] = {10, 25, 50, 75, 100};
int quantidade = sizeof(lista) / sizeof(lista[0]);

printf("%d", quantidade);

>>> 5

Há 5 elementos dentro do array

----------

char lista[] = {'A', 'B', 'C', 'D'};
int quantidade = sizeof(lista) / sizeof(lista[0]);
    
printf("%d", quantidade);

>>> 4

----------

char *lista[] = {"Ana", "Bruno", "Carlos"};
int quantidade = sizeof(lista) / sizeof(lista[0]);
    
printf("%d", quantidade);

>>> 3

-----------------------------------------------------&&&

PARA INSERIR 1 ELEMENTO NOVO NO FINAL DE UM ARRAY

$$$

#include <stdio.h>

void Adicionar(int lista[], int *tamanho, int elemento) {

    lista[*tamanho] = elemento;

    (*tamanho)++;
}

int main() {    
    
    int lista[7] = {10, 20, 30, 40, 50};
    
    int tamanho = 5;
    
    int elemento = 25;

    Adicionar(lista, &tamanho, elemento);

    for (int i = 0; i < tamanho; i++)
        printf("%d ", lista[i]);
    return 0;
}

>>> 10 20 30 40 50 25 

OBS: É obrigatório informar o tamanho do array!


-----------------------------------------------------&&&

PARA ADICIONAR 1 ELEMENTO EM UMA POSIÇÃO ESPECIFICA DE UM ARRAY

#include <stdio.h>

void Adicionar(int lista[], int *tamanho, int posicao, int elemento) {
  
    for (int i = *tamanho; i > posicao; i--)
        lista[i] = lista[i - 1];

    lista[posicao] = elemento;

    (*tamanho)++;
}

int main() {
    int lista[7] = {10, 20, 30, 40, 50};
    int tamanho = 5;
    int posicao = 3;
    int elemento = 25;

    Adicionar(lista, &tamanho, posicao, elemento);

    for (int i = 0; i < tamanho; i++) {
        printf("%d ", lista[i]);
    }
    
    return 0;
}

>>> 10 20 30 25 40 50 


-----------------------------------------------------&&&

PARA ADICIONAR VÁRIOS ELEMENTOS EM UM ARRAY USANDO memcpy()

Sintaxe:
memcpy( target, source, sizeof(source));


#include <stdio.h>
#include <string.h>

int main() {    
    
    int lista[10] = {1, 2, 3, 4, 5};
    int elementos[] = {6, 7, 8, 9, 10};

    memcpy(lista + 5, elementos, 5 * sizeof(int));        // indique o tamanho do array lista (5) e do array elementos (5)

    for (int i = 0; i < 10; i++) {                        // tamanho total de elementos do array
        printf("%d ", lista[i]);
    }

    return 0;
}

>>> 1 2 3 4 5 6 7 8 9 10



Versão alternativa:

#include <stdio.h>
#include <string.h>

int main() {    
    
    int lista[10] = {1, 2, 3, 4, 5};
    int elementos[] = {6, 7, 8, 9, 10};

    memcpy(lista + 5, elementos, sizeof(elementos));      

    for (int i = 0; i < 10; i++) {                        
        printf("%d ", lista[i]);
    }

    return 0;
}

>>> 1 2 3 4 5 6 7 8 9 10

------

#include <stdio.h>
#include <string.h>

int main() {    
    
    int lista[7] = {1, 2, 3};
    int elementos[] = {7, 8, 9, 10};

    memcpy(lista + 3, elementos, 4 * sizeof(int));

    for (int i = 0; i < 7; i++) {
        printf("%d ", lista[i]);
    }

    return 0;
}

>>> 1 2 3 7 8 9 10 

-------

#include <stdio.h>
#include <string.h>

int main() {    
    
    int lista[10] = {1, 2, 3, 4, 5, 6};
    int elementos[] = {7, 8, 9, 10};

    memcpy(lista + 6, elementos, 4 * sizeof(int));

    for (int i = 0; i < 10; i++) { 
        printf("%d ", lista[i]);
    }

    return 0;
}

>>> 1 2 3 4 5 6 7 8 9 10 

----------------

Para trabalhar com strings, é necessário usar ponteiros:

#include <stdio.h>
#include <string.h>

int main() {    

    char *lista[5] = {"Ana", "Maria"};                       //Array de ponteiro contendo strings
    char *elementos[] = {"Carlos", "Naira", "Felipe"};       //Array de ponteiro contendo strings
    
    memcpy(lista + 2, elementos, 3 * sizeof(char*));
    
    for (int i = 0; i < 5; i++) {
        printf("%s ", lista[i]);
    }
    
    return 0;
}

Ana Maria Carlos Naira Felipe 

-----------------------------------------------------&&&

PARA ADICIONAR VÁRIAS STRINGS EM UM ARRAY USANDO UM STRUCT

#include <stdio.h>
#include <string.h>

struct Pessoa {
    char nome[50];
};

int main() {

    struct Pessoa pessoas[10] = {"Ana", "Maria", "Carlos"};
    
    int total_pessoas = 4;
    
    strcpy(pessoas[3].nome, "Bruno");
    
    for (int i = 0; i < total_pessoas; i++) {
        printf("%s ", pessoas[i].nome);
    }
    
    return 0;
}

>>> Ana Maria Carlos Bruno 


Versão alternativa usando typedef:

#include <stdio.h>
#include <string.h>

typedef struct {
    char nome[50];
} Pessoa;

int main() {

    Pessoa pessoas[10] = {"Ana", "Maria", "Carlos"};
    
    int total_pessoas = 4;
    
    strcpy(pessoas[3].nome, "Bruno");
    
    for (int i = 0; i < total_pessoas; i++) {
        printf("%s ", pessoas[i].nome);
    }
    
    return 0;
}

>>> Ana Maria Carlos Bruno 

-----------------------------------------------------&&&

EXEMPLOS PRATICOS DE ARRAY UNIDIMENSIONAL

int idades[] = {20, 22, 18, 35, 48, 26, 87, 70};

float media, total = 0;

int tamanho = sizeof(idades) / sizeof(idades[0]);

for (int i = 0; i < tamanho; i++) {
  total += idades[i];
}

media = total / tamanho;

printf("A média das idades é: %.2f", media);

>>> A média das idades é: 40.75

---------

int idades[] = {20, 22, 18, 35, 48, 16, 87, 70};

int tamanho = sizeof(idades) / sizeof(idades[0]);
  
int menorIdade = idades[0];

for (int i = 0; i < tamanho; i++) {
    if (menorIdade > idades[i]) {
        menorIdade = idades[i];
    }
}

printf("A menor idade é: %d", menorIdade);

>>> A menor idade é: 16
  

-----------------------------------------------------&&&

MATRIZ DE 2 DIMENSÕES (BIDIMENSIONAL)

int matriz[2][3] = { {7, 4, 3}, {3, 6, 8} };

A matriz terá 2 fileiras e 3 colunas

{7, 4, 3} = fileira 1 (posição 0)
7 = coluna 1 (posição 0)
4 = coluna 2 (posição 1)
3 = coluna 3 (posição 2)

{3, 6, 8} = fileira 2 (posição 1)
3 = coluna 1 (posição 0)
6 = coluna 2 (posição 1)
8 = coluna 3 (posição 2)

----------

Para imprimir algum elemento

int matriz[3][4] = { {0, 4, 3, 7}, {1, 6, 8, 3}, {2, 8, 4, 1} };

printf("%d", matriz[2][1]);

>>> 8

8 é o elemento na terceira fileira (posição 2) e na segunda coluna (posição 1):

{0, 4, 3, 7} = fileira 1 (posição 0)
{1, 6, 8, 3} = fileira 2 (posição 1)
{2, 8, 4, 1} = fileira 3 (posição 2)

-----------

Para alterar um elemento de uma matriz bidimensional

char letras[2][5] = { {'A', 'B', 'C', 'D', 'E'} , {'F', 'G', 'H', 'I', 'J'} };

letras[1][3] = 'X';       //Substituiu a letra I pela letra X

for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 5; j++) {
        printf("%c ", letras[i][j]);
    }
}

>>> A B C D E F G H I J

---------

Usando um tamanho não especificado:


char letras[2][5] = { {'A', 'B', 'C', 'D', 'E'} , {'F', 'G', 'H', 'I', 'J'} };
  
int rowsize = sizeof(letras) / sizeof(letras[0]);
int columnsize = sizeof(letras[0]) / sizeof(letras[0][0]);
  
for (int i = 0; i < rowsize; i++) {
    for (int j = 0; j < columnsize; j++) {
        printf("%c ", letras[i][j]);
    }
}
  
>>> A B C D E F G H I J

---------

char *nomes[3][2] = { {"Ana", "Bruno"} , {"Carlos", "Daniel"} , {"Elena", "Felipe"} };

int rowsize = sizeof(nomes) / sizeof(nomes[0]);
int columnsize = sizeof(nomes[0]) / sizeof(nomes[0][0]);
  
for (int i = 0; i < rowsize; i++) {
    for (int j = 0; j < columnsize; j++) {
        printf("%s ", nomes[i][j]);
    }
}

>>> Ana Bruno Carlos Daniel Elena Felipe 

-----------------------------------------------------&&&

PARA PEGAR O INPUT DO USUARIO USANDO scanf() 

Sintaxe:

scanf("%d", &variavel)

OBS: É necessário trocar a IDE do modo Output para o modo Terminal
Tutorial: https://www.youtube.com/embed/Ws-mVAJDFAw?autoplay=1

-------

#include <stdio.h>

int main() {

    int numero;                                                  // Declara uma variável para armazenar o número 

    printf("Digite um numero inteiro e aperte enter: \n");       // Pede ao usuário para digitar um número 

    scanf("%d", &numero);                                        // Lê o número digitado pelo usuário

    printf("Seu número é: %d", numero);                          // Exibe o número digitado

    return 0;
}

OBS: A função scanf() pega o que foi digitado e armazenado no endereço de memoria da variavel.
Sua função é ser responsável pela entrada formatada dos dados. Ela lê os dados do dispositivo de entrada padrão (teclado do computador), que são formatados de acordo com os códigos de formatação conforme a tabela a seguir. Pertence ao grupo de funções de entrada formatada, e atua de forma análoga à saída formatada (printf), mas no sentido inverso.

Caractere = Dados de entrada - Tipo de Argumento

d = Número inteiro decimal - int *
i = Inteiro - int *
o = Octal inteiro - int *
u = Inteiro decimal sem sinal - unsigned int*
x = Número inteiro hexadecimal - int *
c = Caracteres - char *
s = Cadeia de caracteres (string) - char *
e, f, g	= Número de ponto flutuante com o ponto decimal opcional e expoente opcional - float *
% = % Literal	 

--------

#include <stdio.h>

int main() {

    int numero;
    char letra;

    printf("Digite um numero e uma letra e aperte enter: \n");

    scanf("%d %c", &numero, &letra);

    printf("O número digitado foi: %d\n", numero);

    printf("A letra digitada foi: %c\n", letra);

    return 0;
}

---------

#include <stdio.h>

int main() {

    char nome[30];

    printf("Escreva o seu nome: \n");

    scanf("%s", nome);

    printf("Olá %s", nome);

    return 0;
}

OBS: Com strings é necessário especificar o tamanho da string (quantidade de caracteres). 

Portanto fica    scanf("%s", variavel);   e não     scanf("%s", &variavel);


---------

ATENÇÃO!!!
Strings consideram os espaços.

#include <stdio.h>

int main() {

    char nome[30];

    printf("Escreva o seu nome: \n");

    scanf("%s", nome);

    printf("Olá %s", nome);

    return 0;
}

>>> Escreva o seu nome: Maria de Nazaré
>>> Olá Maria

---------

Para limpar a sujeira do buffer

   printf(" Digite o código do aluno: ");
   scanf("%d%*c", &aluno.codigo);

O que o comando %*c faz é ler um caractere e descartá-lo.

Por exemplo, se você fizer isso:

printf("Digite um caractere: ");
scanf("%c", &caractere);
O que vai acontecer é q o caractere q o usuário digitar vai ser lido pelo scanf e armazenado na variável caractere (segundo esse exemplo). Porém, se você fizer isso:

printf("Digite um caractere: ");
scanf("%*c", &caractere);
O que vai acontecer é q o scanf vai ler o caractere digitado pelo usuário e descartá-lo.

função para limpar a sujeira no buffer:
void limpa_linha() {
    scanf("%*[^\n]");   // aqui vai ler lido qualquer lixo do buffer q houver exceto o '\n'
    scanf("%*c");    // aqui vai ser lido o '\n' que é gerado ao se dar um ENTER e vai descatá-lo
}

Só que não esse comando %*c não é usado apenas para isso. Veja esse exemplo:

printf("Digite a data atual no formato dd/mm/aaaa: ");
scanf("%d%*c%d%*c%d", &dia, &mes, &ano);

Aqui é colocado o %*c propositalmente para ler um caractere também e descartá-lo. Logo, se o usuário digitar 26/08/2018 vai se lido o dia = 26 e armazenado na variável dia, depois o caractere ' / ' e vai ser descartado, depois o mes = 08 e armazenado na variável mes, novamente o caractere ' / ' e descartar e em seguida o ano = 2018.

---------

scanf("%24[^\n]", variavel);

Significa:
-Ignorar todos os caracteres com espaços em branco (se houver algum)
-Escanear um máximo de 24 caracteres (+1 para o Nul-terminator '\0') ou até um \n e armazená-lo na variavel.

---------- &&&

Para ler a linha inteira de uma string, desconsiderando os espaços, é necessário usar a função fgets()

Sintaxe:

char variavel = "String de texto";

fgets(variavel, sizeof(variavel), stdin);

------------

#include <stdio.h>

int main() {

    char nome[30];

    printf("Escreva o seu nome: \n");

    fgets(nome, sizeof(nome), stdin);

    printf("Olá %s", nome);

    return 0;
}

>>> Escreva o seu nome: Maria de Nazaré
>>> Olá Maria de Nazaré

-----------

fgets(aluno.nome, 40, stdin);     // Tem o objetivo de ler strings, no caso, o nome do aluno.

fgets(variavel, tamanho da string, entrada)

Nesse caso, a entrada é stdin (entrada padrão), pois estamos lendo do teclado, mas, em outro caso, a entrada também poderia ser um arquivo.

-----------------------------------------------------&&&

PARA FORMATAR UMA STRING, CRIANDO UM TEXTO PRÉ-FORMATADO USANDO sprintf()

#include <stdio.h>

int main() {

    char buffer[100];

    int idade = 25;

    sprintf(buffer, "A idade do João é %d anos.", idade);    //A mensagem foi armazenada na variavel buffer

    printf("%s\n", buffer); 

    return 0;
}

>>> A idade do João é 25 anos.

---------

#include <stdio.h>

int main() {

    char soma[50];
    int a = 10; 
    int b = 20;
    int c;
    
    c = a + b;
    
    sprintf(soma, "A soma de %d e %d é %d", a, b, c);

    printf("%s", soma);

    return 0;
}

>>> A soma de 10 e 20 é 30

-----------------------------------------------------&&&

PARA LER E EXTRAIR DADOS FORMATADOS DE UMA STRING E COLOCAR EM OUTRA VARIÁVEL USANDO sscanf()

#include <stdio.h>

int main() {

    char buffer[] = "João tem 25 anos.";

    char nome[20];

    int idade;

    sscanf(buffer, "%s tem %d anos.", nome, &idade);       //a variavel nome recebe %s (João) e a variavel idade recebe %d (25)

    printf("%s tem %d anos.\n", nome, idade);

    return 0;
}

>>> 

No exemplo acima, a função sscanf() extraiu a palavra João em %s e o numero 25 em %d. Elas foram então armazenadas nas variaveis nome e idade.

OBS: A função sscanf() é o contrário da função sprintf().

ATENÇÃO!!!!
scanf()  é diferente de  sscanf()

-------------

#include <stdio.h>

int main() {

    char soma[] = "A soma de 10 e 20 é 30";
    int a; 
    int b;
    int c;
    
    c = a + b;
    
    sscanf(soma, "A soma de %d e %d é %d", &a, &b, &c);      // primeiro %d = 10  | segundo %d = 20  | terceiro %d = 30

    printf("A soma de %d e %d é %d", a, b, c);

    return 0;
}

>>> A soma de 10 e 20 é 30

-----------------------------------------------------&&&

BIBLIOTECAS PADRÃO

As funções predefinidas na linguagem C estão estipuladas nas bibliotecas da linguagem, nos arquivos header com extensão “.h”. Para usá-las nos programas, é necessário incluir no início do mesmo, através da diretiva #include, a biblioteca que possui a função que será usada.

Dessa maneira, existem diversos header padrão na linguagem C, entre eles:

stdio.h  (Standard Input Output)
Funções de E/S padrão nos dispositivos stdin, stdout e files.
(funções relacionadas a entrada e saída)

stdlib.h
Funções de E/S padrão nos dispositivos stdin, stdout e files. Funções para conversão de números em cadeias de caracteres.

ctype.h
Funções para tratamento de caractere.

time.h
Funções para manipulação de horários e datas.

dos.h
Funções de acesso as INT's da BIOS e DOS do MS-DOS.

string.h
Funções de manipulação de strings (TC).

math.h
Funções matemáticas em geral.

------------------------------------&&&

BIBLIOTECAS DE ENTRADA (INPUT) E SAÍDA (OUTPUT) - <stdio.h>

As funções de entrada e saída (E/S) padrão em C são fundamentais para a interação entre o programa e o usuário, permitindo a leitura de dados do teclado e a exibição de informações na tela.

As funções de E/S padrão são responsáveis pelas operações de entrada e saída de dados. Quando um programa na linguagem C é executado, o sistema operacional é responsável por abrir três arquivos:

stdin
Arquivo de entrada padrão.

stdout
Arquivo de saída padrão.

stderr
Erro padrão.


Os arquivos stdout e stderr são direcionados para a saída do vídeo, e o arquivo stdin é direcionado para o teclado.

Para ter acesso a essas funções, deve-se fazer a seguinte declaração no início do programa:

#include <stdio.h>


Vamos conhecer algumas funções para entrada e saída de dados:

printf() = impressão formatada dos dados. Ela imprime os dados no dispositivo de saída padrão, tela do computador.

scanf() = responsável pela entrada formatada dos dados. Ela lê os dados do dispositivo de entrada padrão (teclado do computador), que são formatados

putchar()
Essa função envia um único caractere pela saída padrão (escreve apenas um caractere). Equivale ao comando: printf("%c",carac). Sintaxe: putchar();

puts()
Essa função envia uma string na saída padrão. A string será adicionada com um caractere '\n'. Equivale a: printf("%s\n", string). Sintaxe: puts(string);

getchar()
Essa função é responsável por ler um caractere da entrada padrão. Equivale à função putchar, mas em sentido inverso. Sintaxe: [variável] = getchar();
Para que nenhum lixo do buffer de teclado atrapalhe o uso da função getchar, coloque fflush(stdin), no Windows, ou _fpurrge(stdin), no Linux, antes da leitura do caractere.

gets()
Essa função é responsável por ler uma string da entrada padrão. Análoga à função puts, mas em sentido inverso. Sintaxe: [variável] = gets();


-----------------------------------------&&&

BIBLIOTECA <stdin.h>

printf
A sua função é ser responsável pela impressão formatada dos dados. Ela imprime os dados no dispositivo de saída padrão, tela do computador. Os mesmos são formatados de acordo com os códigos de formatação, conforme a tabela a seguir:

Caractere = Impresso Como - Tipo de Argumento

d, i = Número decimal - int
o = Número octal sem sinal (sem zero à esquerda) - int
x,X = Número hexadecimal sem sinal (sem um 0x ou 0X à esquerda), usando abcdef ou ABCDEF para 10,…, 15 - int
U = Número decimal sem sinal - int
C = Único caractere - int
S = Imprime caracteres da string até um ‘\ o’ ou o número de caracteres dado pela precisão - char
F = [-] m.dddddd, onde o número de d's é dado pela precisão (padrão 6)- double
e, g = [-] m.dddddde+/-xx or [-] m.ddddddE+/-xx, onde o número de d's é dado pela precisão (padrão 6) = double
g, G = Use % e ou % E se o expoente for menor que = 4 ou maior ou igual à precisão; caso contrário, use %f. - double
P = Ponteiro - void *
% = Nenhum argumento impresso, imprima um %

----------

format_string é formado por caracteres ordinários e especificações de formato. Os caracteres ordinários são copiados diretamente na saída padrão. A especificação de formato é composta pelos seguintes elementos:

° %
° [flags]
° [width]
° [.precision]
° [size]
° type


[flags]
Composto pelos seguintes caracteres:
"-" → Posicione o valor à esquerda.
"+" → O valor deve ser precedido do sinal ("+* ou "-").
"" → Implica na impressão com sinal negativo apenas.
"0" → Preenche o valor com zeros.

[width]
Composto pelos seguintes valores:
⟨n⟩ → Ao menos <n> caracteres são impressos. Caso o comprimento seja menor que <n>, será completado com brancos.
O⟨n⟩ → Caso o comprimento seja menor que <n>, completa com zeros.

[.precision]
Composto pelos seguintes valores:
.0 → Impressão de float sem ponto decimal.
.<n> → Limita o número de casas decimais a <n>.

[size]
Composto pelos seguintes caracteres: 
I → Implica na definição de um modificador LONG.
h → Implica na definição de um modificador SHORT.

[type]
Composto pelos seguintes caracteres: 
d → O argumento é dado na forma inteiro decimal.
0 → O argumento é apresentado em octal (inteiro).
x → O argumento é dado na forma inteiro hexadecimal.
u → O argumento é considerado decimal inteiro sem sinal.
c → O argumento é um caractere único.
s → O argumento é uma cadeia de caracteres (string).
e → O argumento é dado como float ou double em notação cientifica (com expoente).
f → O argumento é dado como float ou double em notação decimal comum (sem expoente).
g → Usar "E" ou "F", conforme a necessidade.
p → O  argumento é um pointer (TC).
% → Reproduz o próprio símbolo % ".


No comando a seguir, as variáveis a, b e c serão impressas como números decimais, alinhadas à esquerda e com 5 dígitos:

printf ("a: %-5D b: %-5D c: %-5D", a, b, c);

-----------------------------------------------------&&&

PARA RECEBER INFORMAÇÕES RELACIONADAS AO TEMPO (DATA, HORA, MINUTO, SEGUNDO) USANDO A BIBLIOTECA <time.h> e time()

A função time() determina o horário atual do calendário, em segundos...
Nota: o tempo de calendário é o número de segundos decorridos desde EPOCH, que é 00:00:00, 1º de janeiro de 1970, Hora Universal Coordenada (UTC).
O valor de retorno também é armazenado no local fornecido por timeptr. Se timeptr for NULL, o valor de retorno não será armazenado. Se o horário do calendário não estiver disponível, o valor (time_t) (-1) será retornado.

Mais informações = https://petbcc.ufscar.br/timefuncoes/

---------

Para saber a data e horario usando ctime()

#include <stdio.h>
#include <time.h>

int main() {
  time_t tempo = time(NULL);
  
  printf(ctime(&tempo));

  return 0;
}

>>> Thu Mar 27 15:01:45 2025

ATENÇÃO!!!
A função ctime() retorna o valor sem o fuso horário. Portanto virá com 3 horas adiantado pois o fuso horário do Brasil é -3.


Versão alternativa:

#include <stdio.h>
#include <time.h>

int main() {
  time_t tempo;
  time(&tempo);

  printf(ctime(&tempo));

  return 0;
}	

>>> Thu Mar 27 15:01:45 2025


OBS: O resultado da sequência que é produzido pelo ctime() contém exatamente 26 caracteres e tem o formato:

 "%.3s %.3s%3d %.2d:%.2d:%.2d %d"

-----------------------

Para saber a data usando localtime()

#include <stdio.h>
#include <time.h>

int main() {
  time_t tempo;
  time(&tempo);
  
  struct tm *tempo0 = localtime(&tempo);
 
  printf("Dia da semana: %d \n", tempo0->tm_wday);      //Retorna um número de 0 a 6, sendo Domingo 0
  printf("Dia do mês: %d \n", tempo0->tm_mday);         
  printf("Mês: %d \n", tempo0->tm_mon + 1);             //Retorna um número de 0 a 11, sendo Janeiro 0
  printf("Ano: %d \n", tempo0->tm_year + 1900);

  return 0;
}	

-----------

Para especificar o dia da semana, é preciso usar uma condição switch:

#include <stdio.h>
#include <time.h>

int main() {
  time_t tempo;
  time(&tempo);
  
  struct tm *tempo0 = localtime(&tempo);
  
  int diasemana = tempo0->tm_wday;

  switch (diasemana) {
      case (0):     
          printf("Dia da semana: Domingo \n");
          break;
      case (1):     
          printf("Dia da semana: Segunda-feira \n");
          break;
      case (2):     
          printf("Dia da semana: Terça-feira \n");
          break;
      case (3):     
          printf("Dia da semana: Quarta-feira \n");
          break;
      case (4):     
          printf("Dia da semana: Quinta-feira \n");
          break;
      case (5):     
          printf("Dia da semana: Sexta-feira \n");
          break;
      case (6):     
          printf("Dia da semana: Sábado \n");
          break;
   }
   return 0;
}	


Versão alternativa: 

#include <stdio.h>
#include <time.h>
#include <string.h>

int main() {
  time_t tempo;
  time(&tempo);
  
  struct tm *tempo0 = localtime(&tempo);
  
  int semana = tempo0->tm_wday;
  char diasemana[20];

  switch (semana) {
      case (0):     
          strcpy(diasemana, "Domingo");
          break;
      case (1):     
          strcpy(diasemana, "Segunda-feira");
          break;
      case (2):     
          strcpy(diasemana, "Terça-feira");
          break;
      case (3):     
          strcpy(diasemana, "Quarta-feira");
          break;
      case (4):     
          strcpy(diasemana, "Quinta-feira");
          break;
      case (5):     
          strcpy(diasemana, "Sexta-feira");
          break;
      case (6):     
          strcpy(diasemana, "Sábado");
          break;
   }
   
   printf("Dia da semana: %s", diasemana);
   
   return 0;
}	

------------------------

Para saber o horario local usando localtime()


#include <stdio.h>
#include <time.h>

#define BRT -3                       //fuso horario do Brasil

int main() {
  time_t tempo;
  time(&tempo);

  struct tm *tempo0 = localtime(&tempo);

  printf("Hora: %02d \n", tempo0->tm_hour + BRT);
  printf("Minuto: %02d \n", tempo0->tm_min);
  printf("Segundo: %02d \n", tempo0->tm_sec);

  return 0;
}

----------

Com tudo junto:

#include <stdio.h>
#include <time.h>

#define BRT -3                       //fuso horario do Brasil

int main() {
  time_t tempo;
  time(&tempo);
  struct tm *tempo0 = localtime(&tempo);

  printf("Horário atual: %02d:%02d:%02d\n",
          tempo0->tm_hour + BRT, tempo0->tm_min, tempo0->tm_sec);

  return 0;
}

>>> Horário atual: 12:18:29


--------------------------

Para saber o horario de um país específico usando gmtime()

#include <stdio.h>
#include <time.h>

/* definindo o UTC/GMT do Brasil e do Japão */
#define BRT -3
#define JST 9

int main() {
  time_t tempo;
  time(&tempo);

  struct tm *tempo0 = gmtime(&tempo);

  printf("Horário no Japão: %02d:%02d:%02d\n"
          "Horário no Brasil: %02d:%02d:%02d\n",
          tempo0->tm_hour + JST, tempo0->tm_min,
          tempo0->tm_sec, tempo0->tm_hour + BRT,
          tempo0->tm_min, tempo0->tm_sec);

  return 0;
}

>>> Horário no Japão: 24:14:01
>>> Horário no Brasil: 12:14:01


-----------------------------------------------------&&&

PARA SORTEAR UM ELEMENTO ALEATÓRIO DE UM ARRAY USANDO srand()

Sintaxe:

srand(seed);

rand() % quantidade;

-------

#include <stdio.h>
#include <stdlib.h>

int main() {

    srand(1);                              //Utilizou a seed 1

    int sorteio = rand() % 5;              //Gera um numero de 0 a 4
    
    printf("O número sorteado foi: %d", sorteio);
    
    return 0;
}

Porém, utilizando um numero especifico com seed gerará sempre o mesmo número aleatório. Por exemplo:
srand(1) = gera sempre o número 4
srand(2) = gera sempre o número 1
etc.

Portanto a função srand() é normalmente utilizada com a biblioteca <time.h> para usar a data e horário atual (timestamp) como seed, fazendo com que o valor sempre mude pois estará vinculado ao horário atual que sempre muda com o passar dos milisegundos.

srand(time(NULL)); 

-------

Por exemplo:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL));                 // Comece o ramdomizador usando a timestamp atual como seed (semente)

    int sorteio = rand() % 5;          // Gera 1 numero aleatorio entre 0 e 4

    printf("O número sorteado foi: %d\n", sorteio);

    return 0;
}

OBS: Caso queira excluir o número 0 e que o numero máximo escolhido também seja incluído, é necessário incluir +1:

int sorteio = rand() % 5;              // Gera 1 numero aleatorio entre 0 e 4
int sorteio = rand() % 5 + 1;          // Gera 1 numero aleatorio entre 1 e 5

-----------

Para gerar mais de 1 numero aleatório:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL));    
    
    for (int i = 0; i < 3; i++) {             //Gera 3 numeros no total
    	int sorteio = rand() % 5 + 1;           //Gera 1 numero aleatorio entre 1 e 5
      printf("%.2d\n", sorteio);
    }
    
    return 0;
}

-------

Para armazenar a quantidade de números sorteados e o intervalo em uma variavel:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
     
    int tamanho = 5;                            // gera 5 números aleatórios
    int intervalo = 10;                         // intervalo entre 10 números (começando do 0)
    
    srand(time(NULL)); 
    
    for (int i = 0; i < tamanho; i++) {           
    	int sorteio = rand() % intervalo;         // gera números entre 0 e 9
      printf("%.2d\n", sorteio);
    }
    
    return 0;
}

Caso queira excluir o número 0 e adicionar o último número:

int sorteio = rand() % intervalo + 1; 

-------

Para gerar números aleatórios sem repetir:


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>                    //necessário para trabalhar com valores booleanos (true e false)

int main() {
        
    int tamanho = 10;                                 // gera 10 números aleatórios
    int intervalo = 20;                               // intervalo entre 20 números (começando do 1)
    int numeros[tamanho];
    srand(time(NULL));

    for (int i = 0; i < tamanho; ++i) {
    
        int sorteio = rand() % intervalo + 1;         // gera números entre 1 e 20
        
        bool existe = false;
        
        for (int j = 0; j < i; ++j) {
            if (numeros[j] == sorteio) {
                existe = true;
                break;
            }
        }
        if (!existe) {
            numeros[i] = sorteio;
            printf("%.2d ", numeros[i]);
        }
        else {
            --i;                                     // força o loop a voltar
        }
    }
  
    return 0;
}


Versão alternativa sem usar a tipos booleanos:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>                  

int main() {
        
    int tamanho = 10;                                 // gera 10 números aleatórios
    int intervalo = 20;                               // intervalo entre 20 números
    int numeros[tamanho];
    srand(time(NULL));

    for (int i = 0; i < tamanho; ++i) {
    
        int sorteio = rand() % intervalo + 1;         // gera números entre 1 e 20
        
        int existe = 0;
        
        for (int j = 0; j < i; ++j) {
            if (numeros[j] == sorteio) {
                existe = 1;
                break;
            }
        }
        if (!existe) {
            numeros[i] = sorteio;
            printf("%.2d ", numeros[i]);
        }
        else {
            --i;                                     // força o loop a voltar
        }
    }
  
    return 0;
}

--------

Caso queira que seja impresso os mesmos números sorteados anteriormente, é só utilizar o mesmo seed:

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

    srand(27);

    for (int i = 0; i < 5; i++) {
      int num = rand() % 10 + 1;
      printf("%d ", num);
    }
    printf("\n");

    srand(27);               //Utilize o mesmo seed usado anteriormente

    for (int i = 0; i < 5; i++) {
      int num = rand() % 10 + 1;
      printf("%d ", num);
    }
    
    return 0;
}

>>> 8 1 3 3 5 
>>> 8 1 3 3 5 


-----------------------------------------------------&&&

PARA ORDENAR ELEMENTOS DE UM ARRAY USANDO qsort()

Utiliza-se uma função para comparar 2 elementos do array, sendo que a função:
-Retorna um número positivo se a é maior que b
-Retorna um número negativo se a é menor que b
-Retorna 0 se a é igual a b

-------

Para colocar numeros inteiros em ordem crescente:

#include <stdio.h>
#include <stdlib.h>

int comparar(const void *a, const void *b) {             //Função para comparar o primeiro elemento com o próximo
   return (*(int*)a - *(int*)b);                   
}

int main() {
   int numeros[] = {10, 5, 4, 6, 9};
   int tamanho = sizeof(numeros) / sizeof(numeros[0]);

   qsort(numeros, tamanho, sizeof(int), comparar);        //colocando em ordem crescente
   
   for (int i = 0; i < tamanho; ++i) {
      printf("%d ", numeros[i]);
   }
   
   return 0;
}

>>> 4 5 6 9 10 

-----

Para colocar numeros inteiros em ordem decrescente:

#include <stdio.h>
#include <stdlib.h>

int comparar(const void *a, const void *b) {        
   return (*(int*)b - *(int*)a);                          //inverta os parâmetros a e b
}

int main() {
   int numeros[] = {10, 5, 4, 6, 9};
   int tamanho = sizeof(numeros) / sizeof(numeros[0]);

   qsort(numeros, tamanho, sizeof(int), comparar);        //colocando em ordem decrescente
   
   for (int i = 0; i < n; ++i) {
      printf("%d ", numeros[i]);
   }
   
   return 0;
}

>>> 10 9 6 5 4 

-----------

Para colocar strings em ordem crescente:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int comparar(const void *a, const void *b){
   return strcasecmp(*(const char **)a, *(const char **)b);
}

int main(){
   char *nomes[] = {"Bruno", "Daniel", "Ana", "Maria", "Jorge"};

   int tamanho = sizeof(nomes) / sizeof(nomes[0]);

   qsort(nomes, tamanho, sizeof(char *), comparar);

   for (int i = 0; i < tamanho; ++i) {
      printf("%s ", nomes[i]);
   }
   return 0;
}

>>> Ana Bruno Daniel Jorge Maria 

------

Para colocar strings em ordem decrescente:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int comparar(const void *a, const void *b){
   return strcasecmp(*(const char **)b, *(const char **)a);      //inverta os parâmetros a e b
}

int main(){
   char *nomes[] = {"Bruno", "Daniel", "Ana", "Maria", "Jorge"};

   int tamanho = sizeof(nomes) / sizeof(nomes[0]);

   qsort(nomes, tamanho, sizeof(char *), comparar);

   for (int i = 0; i < tamanho; ++i) {
      printf("%s ", nomes[i]);
   }
   return 0;
}

>>> Maria Jorge Daniel Bruno Ana 

-----------

Outro exemplo:

#include <stdlib.h>

int comparar(const void *a, const void *b) {           
  int *valA = a;
  int *valB = b;
  return *valA - *valB;
}

int main() {

  int numeros[] = {20, 32, 5, 2, 24, 15};
  int tamanho = sizeof(numeros) / sizeof(numeros[0]);

  qsort (numeros, tamanho, sizeof(numeros[0]), comparar);

  for(int i = 0; i < size; i++) {
    printf("%d ", numeros[i]);
  }

  return 0;
}

-----------------------------------------------------&&&

COLOCANDO EM ORDEM USANDO ALGORITMOS DE ORDENAÇÃO 

FORMA 1: INSERÇÃO (INSERT SORT):
Compara o 1o elemento com o seguinte e coloca os 2 elementos comparados em um vetor separado em ordem. Após isso, pega o elemento seguinte e compara com os elementos separados no outro vetor até o final.
O vetor ordenado criado passa a ser o vetor final. 

#include <stdio.h>

#define TAMANHO 10

void insercao (int *v) {
    int i, j, aux;
    for (i = 0; i < TAMANHO-1; i++) {
        j = i + 1;
        while (v[j - 1] > v[j] && j > 0) {
            aux = v[j - 1];
            v[j - 1] = v[j];
            v[j] = aux;
            j--;
        }
    }
}

int main() {

  int numeros[TAMANHO] = {75, 3, 65, 97, 18, 54, 22, 86, 35, 42};  
  
  insercao(numeros);
  
  for (int i = 0; i < TAMANHO - 1; i++){
      printf("%d ", numeros[i]);
  }

  return 0;
}

>>> 3 18 22 35 42 54 65 75 86 

---------

FORMA 2: SELEÇÃO (SELECTION SORT) 
Compara o 1o elemento com o menor elemento do vetor e faz a troca caso necessário até o final.
Depois continua fazendo iterações até não haver mais trocas.

#include <stdio.h>

#define TAMANHO 10

void selecao (int *v) {
    int i,j,aux, minimo, pos_minimo;
    
    for (i=0; i < TAMANHO-1; i++) {
        minimo = v[i];
        pos_minimo = i;
        for (j=i+1; j < TAMANHO; j++) {
            if (minimo > v[j])
            {
                minimo = v[j];
                pos_minimo = j;
            }
        }
        if (pos_minimo != i) {
            aux = v[pos_minimo];
            v[pos_minimo] = v[i];
            v[i] = aux;
        }
    }
}

int main() {

  int numeros[TAMANHO] = {75, 3, 65, 97, 18, 54, 22, 86, 35, 42};  
  
  selecao(numeros);
  
  for (int i = 0; i < TAMANHO - 1; i++){
      printf("%d ", numeros[i]);
  }
  
  return 0;
}

>>> 3 18 22 35 42 54 65 75 86 

---------

FORMA 3: BOLHA (BUBBLE SORT) 
Compara o 1o elemento com o seguinte e faz a troca caso necessário até o final. 
Depois continua fazendo iterações até não haver mais trocas.

#include <stdio.h>

#define TAMANHO 10

void bolha (int *v) {
    int troca=1;
    int i=0;
    int aux;
    while (troca) {
        troca = 0;
        while (i < TAMANHO - 1) {
            if (v[i] > v[i+1]) {
                aux = v[i];
                v[i] = v[i+1];
                v[i+1] = aux;
                troca = 1;
            }
            i++;
        }
        i = 0;
    }
}

int main() {

  int numeros[TAMANHO] = {75, 3, 65, 97, 18, 54, 22, 86, 35, 42};  
  
  bolha(numeros);
  
  for (int i = 0; i < TAMANHO - 1; i++){
      printf("%d ", numeros[i]);
  }
  
  return 0;
}

>>> 3 18 22 35 42 54 65 75 86 

---------

COMPARAÇÃO ENTRE OS 3 MÉTODOS:

teste 1 com 1000 elementos:
O método bolha precisou de 13ms para realizar a tarefa
O método seleção precisou de 5ms para realizar a tarefa
O método inserção precisou de 4ms para realizar a tarefa

teste 2 com 10000 elementos:
O método bolha precisou de 1537ms para realizar a tarefa
O método seleção precisou de 456ms para realizar a tarefa
O método inserção precisou de 442ms para realizar a tarefa


-----------------------------------------------------&&&

ENDEREÇO DE MEMORIA (&)

#include <stdio.h>

int main() {

    int numero = 10;

    printf("%p", &numero);

    return 0;
};

>>> 0x7ffeb7a8903c           

Esse foi o local da memoria do computador em que foi armazenado o valor da variavel. Este é um numero hexadecimal.

&variavel é também chamado de ponteiro (pointer), que armazena o endereço da memoria onde o valor da variavel foi aramzenado.

Para imprimir valores de um ponteiro, utiliza-se o format specifier %p


-----------------------------------------------------&&&

PONTEIROS / POINTERS (*) e (->)

Um ponteiro é uma variável que armazena o endereço de memória de outra variável como seu valor.

Sintaxe: 

tipo variavel = valor;
tipo * ponteiro = &variavel

OBS: você pode nomear o ponteiro de qualquer forma. Normalmente chamam de:
ptr    ou    ptrVariavel    ou    ptrVariavel

Por exemplo:

char usuario = "Maria";
char *pUsuario = &usuario;

-------

O asterisco fica entre o tipo e o nome do ponteiro, portanto as 3 formas abaixo são aceitas:

tipo * ponteiro = &variavel
tipo* ponteiro = &variavel
tipo *ponteiro = &variavel    

------

OBS: O tipo do ponteiro tem que ser exatamente o mesmo da variavel:

int variavel = valor;
int *ponteiro = &variavel;

ou

float variavel = valor;
float *ponteiro = &variavel;

ou

char variavel = valor;
char *ponteiro = &variavel;


------

Exemplo:

#include <stdio.h>

int main() {

    int idade = 43;     
    int* ponteiro = &idade;        //O ponteiro foi criado e armazenou o endereço da variavel idade

    printf("%p", ponteiro);

    return 0;
};

>>> 0x7fff271118cc


Note que o valor impresso é o mesmo endereço da variavel idade:

int idade = 43;     
int * ponteiro = &idade;

printf("Endereço da variavel: %p \n", &idade);
printf("Endereço do ponteiro: %p \n", ponteiro);

>>> 0x7fff271118cc
>>> 0x7fff271118cc

OBS: Este endereço mudará sempre que o programa for executado. Ele permanecerá o mesmo apenas enquanto a aplicação estiver sendo executada e o valor da variavel estiver sendo armazenado em algum lugar da memoria.

--------

Caso queira imprimir o valor do ponteiro armazenado no endereço e não o endereço:

#include <stdio.h>

int main() {

    int idade = 43;     
    int *ponteiro = &idade;        //O ponteiro foi criado e armazenou o endereço da variavel idade

    printf("%d", *ponteiro);

    return 0;
};

>>> 43

--------

REFERENCE OPERATOR (imprime o endereço copiado pelo ponteiro):
printf("%p", ponteiro);   

DEREFERENCE OPERATOR (imprime o valor armazenado no endereço copiado pelo ponteiro):
printf("%d", *ponteiro);  

--------

OBS: O ponteiro ocupa mais espaço no armazenamento da memoria:

int idade = 43;                //variavel
int *ponteiro = &idade;        //ponteiro

printf("Tamanho ocupado pela variavel: %d bytes \n", sizeof(idade));
printf("Tamanho ocupado pelo ponteiro: %d bytes \n", sizeof(ponteiro));

>>> Tamanho ocupado pela variavel: 4 bytes 
>>> Tamanho ocupado pelo ponteiro: 8 bytes 

Uma variavel int ocupa 4 bytes. O ponteiro recebe o endereço da variavel (que ocupa 4 bytes), e o próprio ponteiro que é do tipo int também ocupa 4 bytes.
Portanto 4 + 4 = 8 

---------&&&

É uma boa prática declarar o valor de um ponteiro como NULL antes de atribuir um valor para ele.

int idade = 43;     
int *ponteiro = NULL;        //declarou o valor do ponteiro como NULL           
ponteiro = &idade;           //atribuiu o endereço da variavel como valor do ponteiro 

-----------------------------------------------------&&&

INDIREÇÃO MÚLTIPLA DE PONTEIROS

Um ponteiro pode armazenar o endereço de outro ponteiro, ocasionando uma indireção múltipla.

int x = 10;

int *pt1;          //ponteiro para o tipo inteiro 
int **pt2;         //ponteiro para ponteiro do tipo inteiro

pt1 = &x;           //ponteiro pt1 recebe o valor e endereço da variavel x  (valor 10)
  
printf("Valor de x e pt1: %d \n", *pt1);

pt2 = &pt1;         //ponteiro pt2 recebe o valor do ponteiro pt1  (valor 10)
  
printf("Valor de x, pt1 e pt2: %d \n\n", **pt2);

*pt1 = 30;          //Alterou o valor de x, pt1 e pt2 (valor 30)
  
printf("Valor de x, pt1 e pt2: %d \n\n", *pt1);
  
**pt2 = 50;         //Alterou o valor de x, pt1 e pt2 (valor 50)
  
printf("Valor final de x: %d \n", x);
printf("Valor final de pt1: %d \n", *pt1);
printf("Valor final de pt2: %d \n", **pt2);

>>> Valor de x e pt1: 10 
>>> Valor de x, pt1 e pt2: 10 
>>>
>>> Valor de x, pt1 e pt2: 30 
>>>
>>> Valor final de x: 50 
>>> Valor final de pt1: 50 
>>> Valor final de pt2: 50 

Sendo:
&pt2: Endereço do ponteiro ‘pt2’;
&pt1: Endereço do ponteiro ‘pt1’;
pt2: Conteúdo de ‘pt2’, ou seja, o endereço de ‘pt1’, que foi recebido através do comando pt2 = &pt1;
pt1: Conteúdo de ‘pt1’, ou seja, o endereço de ‘x’, que foi recebido através do comando pt1 = &x;
*pt2: Conteúdo do endereço apontado, ou seja, o conteúdo de ‘pt1’.
*pt1: Conteúdo do endereço apontado, ou seja, o conteúdo de ‘x’.
**pt2: Acessa o conteúdo do endereço armazenado no ponteiro que é referenciado por ‘pt2’, ou seja, acessa ‘x’ indiretamente.

--------------

#include <stdio.h>
#include <stdlib.h>

int main() {
   // Definição de variaveis do tipo ponteiro
   int numero = 10;
   int *ponteiroInt = &numero;  //Ponteiro para um inteiro

   // Exibindo o valor e o endereço da variavel 'numero' usando ponteiros
   printf("Valor de numero: %d\n", numero);
   printf("Endereço de numero: %p\n", ponteiroInt);
   printf("Valor apontado por ponteiroInt: %d\n", *ponteiroInt);

   // Alterando o valor da variavel 'numero' através do ponteiro
   *ponteiroInt = 20;
   printf("Novo valor de numero após modificação pelo ponteiro: %d\n", numero);

   // Alocação dinâmica de memória com malloc
   int *ponteiroDinamico;
   ponteiroDinamico = (int*) malloc(sizeof(int));       //Aloca memoria para um inteiro

   if (ponteiroDinamico == NULL) {
      printf("Erro ao alocar memoria!\n");
      return 1;                                         //Sai do programa se a alocação falhar
   }

   // Incializando o valor alocado dinamicamente e exibindo
   *ponteiroDinamico = 50;
   printf("Valor armazenado na memoria alocada dinamicamente: %d\n", *ponteiroDinamico);

   // Exemplo de uso seguro de ponteiro com verificação e liberação de memoria
   free(ponteiroDinamico);                              //Libera a memoria alocada
   ponteiroDinamico = NULL;                             //Evita acessos acidentais, tornando o ponteiro invalido

   // Testando o ponteiro após liberar a memoria
   if (ponteiroDinamico == NULL) {
      printf("Memoria foi liberada corretamente e o ponteiro está invalido.\n");
   }

   return 0;
}
  
>>> Valor do numero: 10
>>> Endereço de numero: 0000000000062FE3C
>>> Valor apontado por ponteiroInt: 10
>>> Novo valor de numero após modificação pelo ponteiro: 20
>>> Valor armazenado na memoria alocada dinamicamente: 50
>>> Memoria foi liberada corretamente e o ponteiro está invalido.

-----------------------------------------------------&&&

PONTEIROS E ARRAYS

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};
    int i;

    for (i = 0; i < 4; i++) {
    printf("%p\n", &numeros[i]);
    }

    return 0;
};

>>> 0x7ffe0861fa80
>>> 0x7ffe0861fa84
>>> 0x7ffe0861fa88
>>> 0x7ffe0861fa8c

OBS: Note que o último número de cada endereço de memória dos elementos é diferente, com uma adição de 4.
É porque o tamanho de um tipo int é tipicamente 4 bytes.

---------

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};

    printf("%p\n", numeros);
    printf("%p\n", &numeros[0]);

    return 0;
};

>>> 0x7ffecd91db60
>>> 0x7ffecd91db60

OBS: O nome de um array, é na verdade um ponteiro para o primeiro elemento do array.
O endereço de memória do primeiro elemento é o mesmo que o nome do array.
Isso basicamente significa que podemos trabalhar com arrays por meio de ponteiros.
Como o array numeros é um ponteiro para o primeiro elemento em numeros, você pode usar o operador * para acessá-lo:

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};

    printf("%d", *numeros);

    return 0;
};

>>> 25


Para acessar os outros itens dentro do array:

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};

    printf("%d\n", *(numeros + 1));
    printf("%d\n", *(numeros + 2));
    printf("%d\n", *(numeros + 3));

    return 0;
};

>>> 50
>>> 75
>>> 100


Ou utilizar um loop:

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};
    int i;

    for (i = 0; i < 4; i++) {
    printf("%d\n", *(numeros + i));
    }

    return 0;
};

>>> 25
>>> 50
>>> 75
>>> 100

-----------

Alterar os valores de um array usando um ponteiro:

#include <stdio.h>

int main() {

    int numeros[4] = {25, 50, 75, 100};

    *numeros = 0;                  //Alterou 25 para 0
    *(numeros + 1) = 10;           //Alterou 50 para 10
    *(numeros + 2) = 20;           //Alterou 75 para 20
    *(numeros + 3) = 30;           //Alterou 100 para 30

    for (int i = 0; i < 4; i++) {
    printf("%d\n", *(numeros + i));
    }

    return 0;
};

>>> 0
>>> 10
>>> 20
>>> 30

-----------------------------------------------------&&&

FUNÇÕES / MÉTODOS / OPERAÇÕES

Sintaxe:

void Função() {
    instrução a ser executada;
}

int main() {
    Função();         // Para chamar a função                  
    return 0;
}

----------------

#include <stdio.h>

void Imprimir() {
  printf("Texto de exemplo");
}

int main() {
  Imprimir();          
  return 0;
}

>>> Texto de exemplo

-----------------

OBS: void significa que a função não tem um valor de retorno.
Caso a função retorne algum valor, o tipo será alterado.

int Calcular() {
	int x = 10 + 13;
    return x;
}

int main() {
    printf("%d", Calcular());  
    return 0;
}

>>> 23

-------------

Para otimização do código, é recomendável separar a declaração e a definição da função.

void Função();                       // Declaração da função

int main() {
  Função();                          // Chamou a função
  return 0;
}

void Função() {                      // Definição da função
  printf("A função foi executada");
}

>>> A função foi executada

-------------

#include <stdio.h>

void Calcular() {
  int x = 5;
  int y = 10;
  int soma = x + y;
  printf("%d", soma);
}

int main() {
  Calcular();  
  return 0;
}

>>> 15

-----------------------------------------------------&&&

FUNÇÕES COM PARAMETROS

function Calcular(int x, int y) {           // x e y = Parâmetros formais
    return (x + y);
}

int soma = Calcular(4, 1);                  // 4 e 1 = Parâmetros reais / atuais (argumentos)

----------

#include <stdio.h>

void Imprimir(int x) {
  int numero = x;
  printf("%d", x);
}

int main() {
  Imprimir(10);
  return 0;
}

>>> 10

---------------------

#include <stdio.h>

void Imprimir(char x, int y) {
  char letra = x;
  int numero = y;
  printf("Letra: %c\n", x);
  printf("Numero: %d\n", y);
}

int main() {
  Imprimir('A', 5);
  return 0;
}

>>> Letra: A
>>> Numero: 5

--------------------

#include <stdio.h>

void Calcular(int x, int y) {
  int soma = x + y;
  printf("A soma de %d e %d é igual a: %d\n", x, y, soma);
}

int main() {
  Calcular(5, 3);
  return 0;
}

>>> A soma de 5 e 3 é igual a: 8

--------------------

#include <stdio.h>

void Calcular(int x, int y) {
  int soma = x + y;
  printf("%d\n", soma);
}

int main() {
  Calcular(2, 3);
  Calcular(4, 4);
  Calcular(3, 7);
  return 0;
}

>>> 5
>>> 8
>>> 10

--------------------

#include <stdio.h>

void Pessoa(char nome[]) {
  printf("%s\n", nome);
}

int main() {
  Pessoa("Lucas");
  Pessoa("João");
  Pessoa("Ana");
  return 0;
}

>>> Lucas
>>> João
>>> Ana

--------------------

#include <stdio.h>

void Pessoa(char nome[], int idade) {
  printf("%s tem %d anos de idade.\n", nome, idade);
}

int main() {
  Pessoa("Lucas", 15);
  Pessoa("João", 23);
  Pessoa("Ana", 18);
  return 0;
}

>>> Lucas tem 15 anos de idade.
>>> João tem 23 anos de idade.
>>> Ana tem 18 anos de idade.

---------------------&&&

Separando a assinatura, declaração e  chamada da função:


int Calcular(int x, int y);           // Assinatura da função (Protótipo)

int main() {
  int resultado = Calcular(5, 3);     //Chamada da função
  printf("Total = %d", resultado);
  return 0;
}

int Calcular(int x, int y) {          // Definição da função
  return x + y;
}

>>> 8

Para que o programa compile corretamente quando a função é definida após a função main, é necessário declarar um protótipo da função antes da função main. Isso informa ao compilador sobre a existência da função e sua assinatura, permitindo que ela seja chamada antes de sua definição.


OBS: Não há problema em usar parametros com nomes diferentes na assinatura e na definição da função:

int Calcular(int a, int b);               //Parametros a e b

int main(void) {

  	int resultado = Calcular(5, 3);  
    
  	printf("Total = %d", resultado);
  
    return(0);
}

int Calcular(int x, int y) {             //Parametros x e y     
  return x + y;
}

-----------------------------------------------------&&&

FUNÇÃO COM ARRAYS COMO PARAMETROS


#include <stdio.h>

void Imprimir(int parametro[5]) {
  for (int i = 0; i < 5; i++) {
    printf("%d ", parametro[i]);
  }
}

int main() {
  int lista[5] = {10, 20, 30, 40, 50};
  Imprimir(lista);
  return 0;
}

>>> 10 20 30 40 50


Versão alternativa:

#include <stdio.h>

void Imprimir(int parametro[]) {
  for (int i = 0; i < 5; i++) {
    printf("%d ", parametro[i]);
  }
}

int main() {
  int lista[] = {10, 20, 30, 40, 50};
  Imprimir(lista);
  return 0;
}

>>> 10 20 30 40 50

OBS: O “[ ]” pode ser utilizado sem um valor, pois em C não interessa qual a dimensão do vetor que é passado a uma função, mas, sim, o tipo dos seus elementos.

-----------

Usando o tamanho do array como parametro:

#include <stdio.h>

void Imprimir(int parametro[], int tamanho) {
  for (int i = 0; i < tamanho; i++) {
    printf("%d ", parametro[i]);
  }
}

int main() {
  int lista[] = {10, 20, 30, 40, 50};
  int tamanho = sizeof(lista) / sizeof(lista[0]);
  Imprimir(lista, tamanho);
  return 0;
}

>>> 10 20 30 40 50

-----------

#include <stdio.h>

void v_iniciacao(int *vet, int n) {
    int i;
    for (i = 0; i < n; i++)
    vet[i] = 0;
}

void v_imprime(int *vet, int n){
    int i;
    for(i = 0; i < n; i++)
      printf(" %d - ",vet[i]);
    printf("\n");
}

int main(void) {
    int vet[10], i;
    v_iniciacao(vet,10);

    // Impressao apos inicializacao.
    printf("Impressao do vetor antes da atribuicao.");
    v_imprime(vet,10);

    // Mudando valores de vet.
    for(i = 0; i < 10; i++){
        vet[i] = i;
    }

    // Impressao apos atribuicao.
    printf("Impressao do vetor apos a atribuicao.");
    v_imprime(vet,10);

    return(0);
}

>>> Impressao do vetor antes da atribuicao. 0 -  0 -  0 -  0 -  0 -  0 -  0 -  0 -  0 -  0 - 
>>> Impressao do vetor apos a atribuicao. 0 -  1 -  2 -  3 -  4 -  5 -  6 -  7 -  8 -  9 - 

-----------------------------------------------------&&&

FUNÇÃO COM RETORNO

#include <stdio.h>

int Calcular(int x) {
  return 5 + x;
}

int main() {
  printf("Resultado: %d", Calcular(3));
  return 0;
}

>>> Resultado: 8

----------------

#include <stdio.h>

int Calcular(int x, int y) {
  return x + y;
}

int main() {
  printf("Resultado: %d", Calcular(10, 30));
  return 0;
}

>>> Resultado: 40

------------------

#include <stdio.h>

int Calcular(int x, int y) {
  return x + y;
}

int main() {
  int soma = Calcular(10, 20);
  printf("Resultado: %d", soma);
  return 0;
}

>>> Resultado: 30

-----------------------------------------------------&&&

FUNÇÃO PARA SOMAR TODOS OS ELEMENTOS DE UM ARRAY

#include <stdio.h>

int calcular (int vetor[], int tamanho) {                      // Função que calcula a soma dos elementos de um vetor
    int soma = 0;
    int i;
    for (i = 0; i < tamanho; i++) {
        soma += vetor[i];                                      // Adiciona o valor do elemento ao total
    }
    return soma;
}

int main() {
    
    int lista[] = {10, 20, 30, 40, 50};
    int tamanho = sizeof(lista) / sizeof(lista[0]);            // Calcula o tamanho do vetor

    int total = calcular (lista, tamanho);                     // Chamando a função para calcular a soma do vetor 

    printf("A soma dos números é: %d\n", total);               // Exibindo o resultado

    return 0;
}

>>> A soma dos números é: 150

-----------------------------------------------------&&&

FUNÇÃO PARA ACHAR RAPIDAMENTE UM ELEMENTO EM UM ARRAY USANDO BUSCA BINÁRIA:

Considere, por exemplo, a seguinte lista: [1, 3, 6, 7, 9, 12, 15, 22, 90]. Suponha que você esteja buscando o elemento de valor 5. Pois bem, consultando o elemento central da lista (9), verificamos que ele é maior do que o elemento buscado.

-Etapa 01
Dessa forma, podemos descartar todos os elementos do meio até o fim (pois como se trata de uma lista ordenada, sabemos que o 5, se existir, estará à esquerda de 9).

-Etapa 02
Agora, repitamos o procedimento considerando apenas a primeira metade da lista ( [1, 3, 6, 7, 9] ). Nesse caso, o elemento de valor 6 (central) é maior do que o buscado.

-Etapa 03
Portanto, repetimos o procedimento para o primeiro quarto da lista ( [1, 3] ). É fácil ver que após a última repetição ‒ segundo oitavo da lista ( [3] ), teremos como resposta que o elemento buscado não faz parte da mesma.

O procedimento realizado acima, se você observou atentamente, faz chamadas recursivas a si mesmo sempre dividindo ao meio o espaço de busca. Esse procedimento é chamado de busca binária. Ou seja, tiramos proveito do fato de se tratar de uma lista ordenada, para tornar a busca mais eficiente. A função exibida no Código 3 mostra a implementação da busca binária em C.


#include <stdio.h>
#include <math.h>

int busca_binaria ( int lista[] , int elemento , int inicio , int fim ) {
	int meio = floor( ( fim + inicio ) / 2 );
	if ( ( inicio == fim ) && ( lista[meio] != elemento ) ) {
		printf("O elemento procurado não existe no array.");
    }
	else if ( lista[meio] == elemento ) {
		printf("O elemento %d está na posição %d", elemento, meio);
    }
	else if ( elemento < lista[meio] ) {
		busca_binaria ( lista , elemento , inicio , meio );
    }
	else {
    	busca_binaria ( lista , elemento , meio + 1 , fim );
    }
}

int main() {

  int lista[] = {1, 3, 6, 7, 9, 12, 15, 22, 90};
   
  int elemento = 6;
  
  int tamanho = sizeof(lista) / sizeof(lista[0]);
  
  busca_binaria(lista, elemento, 0, tamanho);   

  return 0;
}

>>> O elemento 6 está na posição 2


Versão alternativa:

#include <stdio.h>

int busca_binaria(int lista[], int elemento, int inicio, int fim) {

    if (inicio > fim) {                     //Se o elemento não for encontrado
        return -1;
    }

    int meio = (inicio + fim) / 2;          //Calcular o índice no meio do array

    if (lista[meio] == elemento) {          //Se o elemento for encontrado no meio
        return meio;
    }

    if (elemento < lista[meio]) {           //Se o elemento for menor, procure na metade à esquerda
        return busca_binaria(lista, elemento, inicio, meio - 1);
    }

    return busca_binaria(lista, elemento, meio + 1, fim);     //Se o elemento for maior, procure na metade à direita
}

int main() {
    int lista[] = {1, 3, 6, 7, 9, 12, 15, 22, 90};
    
    int tamanho = sizeof(lista) / sizeof(lista[0]);
    
    int elemento = 6;

    int resultado = busca_binaria(lista, elemento, 0, tamanho - 1);
    
    if (resultado != -1) {
        printf("Elemento %d encontrado no índice %d\n", elemento, resultado);
    } else {
        printf("Elemento não encontrado\n");
    }
    
    return 0;
}

>>> Elemento 6 encontrado no índice 2

-----------

A busca binária só funciona em vetores ordenados (do menor para o maior). Portanto, caso o vetor esteja fora de ordem, é necessário colocá-lo em ordem primeiro.

#include <stdio.h>
#include <stdlib.h>

int comparar(const void *a, const void *b) {            
   return (*(int*)a - *(int*)b);                   
}

int busca_binaria(int lista[], int elemento, int inicio, int fim) {
    while (inicio <= fim) {
    
        int meio = inicio + (fim - inicio) / 2;  
        
        if (lista[meio] == elemento) {
            return meio;  
        }
        
        if (elemento < lista[meio]) {
            fim = meio - 1;  
        } else {
            inicio = meio + 1;  
        }
    }
    
    return -1;  
}

int main() {
    int lista[] = {12, 3, 16, 47, 19, 12, 25, 42, 30};
    
    int tamanho = sizeof(lista) / sizeof(lista[0]);
    
    int elemento = 42;
    
    qsort(lista, tamanho, sizeof(int), comparar);        //colocando em ordem crescente

    int resultado = busca_binaria(lista, elemento, 0, tamanho - 1);
    
    if (resultado != -1) {
        printf("Elemento %d encontrado no índice %d\n", elemento, resultado);
    } else {
        printf("Elemento não encontrado\n");
    }
    
    return 0;
}

>>> Elemento 42 encontrado no índice 7


-----------

Para procurarmos strings dentro de arrays, é necessário usarmos ponteiros:

#include <stdio.h>
#include <string.h>
#include <strings.h>  

int busca_binaria(char *lista[], char *elemento, int inicio, int fim) {

    if (inicio > fim) {                                        // Se o elemento não for encontrado
        return -1;
    }

    int meio = (inicio + fim) / 2;                             // Para calcular o índice no meio do array
    
    int comparacao = strcasecmp(lista[meio], elemento);        //Para comparar os elementos ignorando maiúsculas e minúsculas
    
    if (comparacao == 0) {                                     // Se o elemento for encontrado no meio
        return meio;
    }
    
    else if (comparacao > 0) {                                 // Se a comparação der resultado menor, procure na metade à esquerda
        return busca_binaria(lista, elemento, inicio, meio - 1);
    }

    else {                                                     //Se a comparação der resultado maior, procure na metade à direita
        return busca_binaria(lista, elemento, meio + 1, fim);   
    }    
}

int main() {
    char *lista[] = {"Ana", "Bruno", "Carlos", "Daniel"};
    
    int tamanho = sizeof(lista) / sizeof(lista[0]);
    
    char *elemento = "daniel";
    
    int resultado = busca_binaria(lista, elemento, 0, tamanho - 1);
    
    printf("Elemento %s %s\n", lista[resultado], resultado != -1 ? "encontrado" : "não encontrado");
    
    return 0;
}

>>> Elemento Daniel encontrado

----------

Para encontrar uma string dentro de um array desordenado:


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int comparar(const void *a, const void *b) {
   return strcasecmp(*(const char **)a, *(const char **)b);
}

int busca_binaria(char *lista_copia[], char *elemento, int inicio, int fim) {

    while (inicio <= fim) {

        int meio = inicio + (fim - inicio) / 2;  
        
        int comparacao = strcasecmp(lista_copia[meio], elemento);
        
        if (comparacao == 0) {
            return meio;  
        }
        
        if (comparacao > 0) {
            fim = meio - 1;  
        } else {
            inicio = meio + 1;  
        }
    }
    
    return -1;  
}

int main() {
    char *lista_original[] = {"Bruno", "Daniel", "Ana", "Maria", "Jorge"};
    
    int tamanho = sizeof(lista_original) / sizeof(lista_original[0]);
    
    char *lista_copia[tamanho];                    
    for (int i = 0; i < tamanho; i++) {
        lista_copia[i] = lista_original[i];
    }
    
    qsort(lista_copia, tamanho, sizeof(char*), comparar);
    
    char *elemento = "ana";
    
    int resultado_ordenado = busca_binaria(lista_copia, elemento, 0, tamanho - 1);
    
    if (resultado_ordenado != -1) {
        char *elemento_encontrado = lista_copia[resultado_ordenado];
        
        for (int i = 0; i < tamanho; i++) {                             //Comparando o resultado encontrado com a lista original
            if (strcasecmp(lista_original[i], elemento_encontrado) == 0) {
                printf("Elemento %s encontrado na posição %d. \n", 
                       elemento_encontrado, i);
                break;
            }
        }
    } else {
        printf("Elemento %s não encontrado\n", elemento);
    }
    
    return 0;
}

>>> Elemento Ana encontrado na posição 2. 


-----------------------------------------------------&&&

FUNÇÃO COM PONTEIROS COMO PARAMETROS

Normalmente uma função seria assim sem usar ponteiros como parametro;

#include <stdio.h>

void Imprimir(int x) {         //Recebeu o valor 10 como parametro
  printf("%d", x);
}

int main() {
  int numero = 10;
  Imprimir(numero);            //Passou o valor 10 como parametro
  return 0;
}

>>> 10


Mas é possível usar um ponteiro como parametro:

#include <stdio.h>

void Imprimir(int *x) {         //Recebeu o endereço e o valor armazenados no ponteiro como parametro
  printf("%d", *x);
}

int main() {
  int numero = 10;
  int *ponteiro = &numero;       //Recebeu e armazenou o endereço e o valor da variavel numero
  
  Imprimir(ponteiro);            //Passou o endereço e o valor armazenados no ponteiro

  return 0;
}

>>> 10

----------

Para checar se os endereços dos ponteiros são válidos:

#include <stdio.h>

void troca(int *x, int *y) {
    int aux;
    if(x != NULL && y != NULL){             //se endereços forem válidos
    aux = *x;                               //faz a troca
    *x = *y;
    *y = aux;
    }
}

int main(){
    int v1 = 5, v2 = 10;
    troca(&v1, &v2);
    printf("v1 = %d e v2 = %d\n", v1, v2);
}

>>> v1 = 10 e v2 = 5

-----------------------------------------------------&&&

PASSAGEM POR VALOR x PASSAGEM POR REFERÊNCIA

Passagem por valor = não altera o valor original, apenas a cópia

#include <stdio.h>

void troca(int x) {                   //Recebeu o valor de x no parametro de mesmo nome
    x = 10;                           //Alteração do valor de x só existe dentro da função
}

int main(){
    int x = 5;
    
    troca(x);                         //Passou o valor de x como parametro
    
    printf("x = %d", x);
}

>>> x = 5                             // Valor original não foi alterado

-----

Passagem por referência = altera o valor original

#include <stdio.h>

void troca(int *x) {                //Recebeu o endereço da variavel x em um ponteiro *x
    *x = 10;                        //Alterou o valor da variavel x através do seu endereço guardado no ponteiro *x
}

int main(){
    int x = 5;
    
    troca(&x);                      //Passou o endereço da variavel x
    
    printf("x = %d", x);
}

>>> x = 10                          // Valor original foi alterado


---------------------

Se estivermos usando arrays/vetores, é como se estivessemos trabalhando com os valores originais. Portanto, se a função mudar algo nela, a mudança acontece na lista de verdade.
Isso ocorre pois o que é passado não é uma cópia do vetor, mas sim o endereço de onde está armazenado.

#include <stdio.h>

void troca(int lista[]) {                   
    lista[0] = 3;                           
}

int main(){
    int lista[] = {5, 2, 7, 4};
    
    troca(lista);                         
    
    printf("Primeiro item da lista = %d", lista[0]);
}

>>> Primeiro item da lista = 3

------------------

Outro exemplo

Passagem por valor:
(não altera o valor original)

#include <stdio.h>

void troca(int x, int y) {                //as 2 variaveis recebem os valores
    int aux;
    aux = x;
    x = y;
    y = aux;
}

int main(){
    int v1 = 5, v2 = 10;
    printf("Antes da troca: v1 = %d e v2 = %d\n", v1, v2);
    troca(v1, v2);                                             //passa os 2 valores como parametros
    printf("Depois da troca: v1 = %d e v2 = %d\n", v1, v2); 

    return 0;
}

>>> Antes da troca: v1 = 5 e v2 = 10
>>> Depois da troca: v1 = 5 e v2 = 10               //Não há alteração!

A passagem por valor é feita entregando a “xerox” das informações, jamais o original. Dessa forma, a sub-rotina pode “riscar e rabiscar” os dados que foram passados, sem, no entanto, danificar o “documento original”.

Ao invocarmos uma sub-rotina passando variáveis no lugar dos parâmetros, os valores das mesmas são copiados para os parâmetros da sub-rotina. Sendo assim, as alterações dentro da sub-rotina no valor dos parâmetros não afetam as variáveis usadas na chamada desta.

Essa forma de relacionamento do programa principal com a sub-rotina chamamos de passagem por valor. Nela, é passada realmente uma cópia do valor indicado na chamada do procedimento ou função. Se alterarmos o conteúdo da variável recebida como parâmetro, alteraremos a cópia do valor original e, portanto, o original não é modificado.

--------

Passagem por referência:
(altera o valor original)

#include <stdio.h>

void troca(int *x, int *y) {                //os 2 ponteiros recebem os endereços
    int aux;
    if(x != NULL && y != NULL){             //se endereços forem válidos
    aux = *x;                               //faz a troca
    *x = *y;
    *y = aux;
    }
}

int main(){
    int v1 = 5, v2 = 10;
    printf("Antes da troca: v1 = %d e v2 = %d\n", v1, v2); 
    troca(&v1, &v2);                                             //passa os 2 endereços como parametros
    printf("Depois da troca: v1 = %d e v2 = %d\n", v1, v2); 

    return 0;
}

>>> Antes da troca: v1 = 5 e v2 = 10
>>> Depois da troca: v1 = 10 e v2 = 5             //Os valores armazenados no endereço são alterados

Na passagem por referência, se alterarmos o conteúdo da variável recebida como parâmetro, alteraremos o valor original, pois temos à nossa disposição o endereço exato onde está localizada na memória e, portanto, podemos alterar diretamente o valor original.

-----------------------------------------------------&&&

FUNÇÃO RECURSIVA

Numa função com recursão, a função chama a si mesmo.

#include <stdio.h>

int Calcular(int k);

int main() {
    int resultado = Calcular(5);
    printf("%d", resultado);
    return 0;
}

int Calcular(int k) {
    if (k > 0) {
        return k + Calcular(k - 1);
    } else {
        return 0;
    }
}

>>> 15
(5 + 4 + 3 + 2 + 1 = 15)

-----------------------------------------------------&&&

FUNÇÕES MATEMATICAS USANDO A BIBLIOTECA <math.h>

-Para achar a raiz quadrada:

#include <stdio.h>
#include <math.h>

int main() {

    printf("%f", sqrt(16));          //Para achar a raiz quadrada de 16

    return 0;
}

>>> 4.000000

Se quiser remover as casas decimais:

printf("%.0f", sqrt(16));

--------

-Para arredondar um numero para cima:

#include <stdio.h>
#include <math.h>

int main() {

	printf("%.0f", ceil(1.4));

    return 0;
}

>>> 2

--------

-Para arredondar um numero para baixo:

#include <stdio.h>
#include <math.h>

int main() {

	printf("%.0f", floor(1.4));

    return 0;
}

>>> 1

---------

-Exponenciação:

#include <stdio.h>
#include <math.h>

int main() {

	printf("%.0f", pow(2, 3));          // 2 elevado ao cubo (3)

    return 0;
}

>>> 8

-------------------------------------------------&&&

FUNÇÕES x PROCEDIMENTOS

As funções são subrotinas que realizam uma tarefa e retornam um valor como resultado. São úteis quando precisamos de um resultado específico.
Exemplo: Calcular(), Somar(), etc.

Os procedimentos são subrotinas que realizam uma tarefa, mas não retornam um valor. São usados quando queremos que uma ação seja executada, mas não precisamos de um resultado específico.
Exemplo: Imprimir(), Exibir(), etc.

-----------&&&

FUNÇÕES

Funções são blocos de código que retornam um valor após sua execução, enquanto procedimentos, representados por funções do tipo void, executam ações sem retornar valores.

As funções são procedimentos que retornam um único valor ao final de sua execução.

Por exemplo, as funções sqrt(), scanf() e printf(), que calculam a raiz quadrada, leem um número da entrada padrão e imprimem um valor na saída padrão.

x = sqrt(4);
if (scanf ("%d", &x) == EOF)
printf("Fim de arquivo.\n");


É aconselhado declarar as funções antes do programa principal, mas o que ocorreria se declarássemos depois?

Embora aparentemente funcione, isso não pode ser feito na prática, pois alguns compiladores simplesmente não aceitam essa sintaxe, obrigando que a declaração ocorra antes da função main (ou melhor, antes de qualquer outra função que utilize uma determinada função).

#include <stdio.h>

void imprime (int numero);         //Declaração da função

int main() {
  ....;
}

Com isso, separamos a declaração da implementação, permitindo que ela possa vir em qualquer lugar do código (antes ou depois de qualquer outra função). Além disso, um programa que declara todas as funções antes de usá-las tende a ser mais claro, pois o programador já sabe qual o conjunto de funções que ele pode usar, sem se preocupar com a forma como elas foram implementadas (ou sequer como elas foram desenvolvidas, caso o código esteja sendo desenvolvido por uma equipe).

int soma (int a, int b) {
    return (a + b);
}	

A expressão contida dentro do comando return é chamada de valor de retorno, e corresponde à resposta de uma determinada função. Esse comando é sempre o último a ser executado por uma função, e nada após ele será executado.

Quando utilizado, o comando return informa ao sistema operacional se o programa funcionou corretamente ou não. O padrão é que um programa retorne zero caso tenha funcionado corretamente, ou qualquer outro valor caso contrário.

-----

Na verdade, podemos invocar uma função em qualquer lugar onde faríamos a leitura de uma variável, mas nunca a escrita. Veja o exemplo a seguir.

printf ("Soma de x e y: %d\n", soma(x, y));

----

O tipo void é um tipo especial, utilizado principalmente em funções. Ele representa o “nada”, ou seja, uma variável desse tipo armazena conteúdo indeterminado, e uma função desse tipo retorna um conteúdo indeterminado.

-----------&&&

PROCEDIMENTOS

São estruturas que agrupam um conjunto de comandos, que são executados quando o procedimento é chamado, ou seja, procedimentos em linguagem C são funções do tipo void.

Um procedimento possui o seguinte formato:

procedimento < nome-de-procedimento >
    [(< sequência-de-declarações-de-parâmetros >)]
var
    // Seção de Declarações Internas
inicio
    // Seção de Comandos
fimprocedimento	


Por exemplo, o procedimento a seguir imprime o número que for passado para ele como parâmetro:

void imprime (int numero) {
    printf ("Número %d\n", numero);
}	


Ao se ignorar o valor de retorno de uma função e, para esta chamada, ela será equivalente a um procedimento.

Para invocarmos um procedimento, devemos utilizá-lo como utilizaríamos qualquer outro comando, ou seja:	

procedimento (parametros);

--------

Como se deve declarar e invocar as funções e procedimentos de maneira adequada?

Declarar a função e o procedimento antes da função main(), mas implementar ambos depois, garantindo que o compilador reconheça suas assinaturas.
Para garantir que o compilador reconheça as assinaturas de funções e procedimentos, é recomendado declará-los antes da função main(). Isso permite que suas implementações possam ser localizadas em qualquer parte do código, facilitando a manutenção e a organização. A prática de declarar antes e implementar depois ajuda a manter um código mais limpo e legível, especialmente em projetos colaborativos.

-----------------------------------------------------&&&

VARIAVEIS LOCAIS E GLOBAIS

-Variavel Estatica (Variaveis globais)
Usada para variaveis que permanecem na memoria durante toda a execuçao do programa, como as variaveis globais e constantes, que precisam estar disponiveis em todo o programa.
Utiliza o DATA.

-Automatica (Variaveis locais)
Usada para variaveis locais, aquelas declaradas dentro de uma função.
Feito atraves de uma pilha (STACK), onde um espaço temporario é reservado e quando a função termina, o espaço é liberado automaticamente.
Utiliza o STACK.

-----------

int varglobal = 10;           // Variavel global = ESTATICA / STACK

void Função() {
  int varlocal = 5;           // Variavel local (AUTOMATICA / DATA). Só funciona dentro da função
  printf("%d", varlocal);     // Imprimirá 5
  printf("%d", varglobal);    // Imprimirá 10
}

int main() {
    Função();
    printf("%d", varglobal);  // Imprimirá 10
    return 0;
}

----------

int x = 10;                 // Variavel global

void Função() {
  int x = 5;                // Variavel local. Só funciona dentro da função
  printf("%d", x);          // Imprimirá a variavel local com valor 5
}

int main() {
    Função();
    printf("%d", x);        // Imprimirá a variavel global com valor 10
    return 0;
}

-----------

#include <stdio.h>

char MANHA[] = "Bom dia";
char TARDE[] = "Boa tarde";
char NOITE[] = "Boa noite";
char MADRUGADA[] = "Boa noite";

int main() {

  int hora = 16;

  if (hora >= 0 && hora < 6) {
    printf("%s", MADRUGADA);
  }
  else if (hora < 12) {
    printf("%s", MANHA);
  }
  else if (hora < 18) {
    printf("%s", TARDE);
  }
  else if (hora < 24) {
    printf("%s", NOITE);
  }
  else {
    printf("Digite um horário entre 0 e 23.");
  }

  return 0;
}

------------

Atenção!!

Em um programa, as variáveis locais e as globais podem ter o mesmo identificador, isto é, o mesmo nome. Porém, dentro de uma sub-rotina, as variáveis locais sobrepõem o valor das globais.

#include <stdio.h>

int num = 20;                                      //Variável global

int main () {
    int num = 10;                                  //Variável local

    printf("O valor da variavel num: %d", num);

    return 0;
}

>>> O valor da variavel num: 10

-------------

Outros exemplos de escopo:

int soma(int x, int y); // Protótipo da função
int resultado_global; // Variável global

int main() {
    int num1, num2;
    
    // Inicializa as variáveis
    num1 = 10;
    num2 = 20;
    
    // Chama a função soma e armazena o resultado na variável global
    resultado_global = soma(num1, num2);
    
    // Imprime o resultado
    printf("%d + %d = %d\n", num1, num2, resultado_global);
    
    return 0;
}

int soma(int x, int y) {
    return x + y;
}

>>> 10 + 20 = 30

---------

#include <stdio.h> 

// Variável global para o total de itens no estoque 
int totalEstoque = 100;

// Procedimento para adicionar itens ao estoque 
void adicionarEstoque(int quantidade) {               // 'quantidade' é um parâmetro formal 
    totalEstoque += quantidade; 
    printf("Itens adicionados: %d\n", quantidade); 
    printf("Estoque atualizado: %d\n", totalEstoque); 
}

// Procedimento para remover itens do estoque 
void removerEstoque(int quantidade) {                 // 'quantidade' é um parâmetro formal 
    if (quantidade <= totalEstoque) { 
        totalEstoque -= quantidade; 
        printf("Itens removidos: %d\n", quantidade); 
        printf("Estoque atualizado: %d\n", totalEstoque); 
    } else { 
        printf("Erro: Quantidade insuficiente no estoque!\n"); 
    } 
}

// Função principal 
int main() { 

    // Variável local para armazenar a quantidade de itens a ser processada 
    int quantidade; 

    // Adicionar itens ao estoque 
    quantidade = 20;  // 'quantidade' é um argumento passado para a função 
    adicionarEstoque(quantidade); 

    // Remover itens do estoque 
    quantidade = 15;  // 'quantidade' é um argumento passado para a função 
    removerEstoque(quantidade); 

    // Tentar remover uma quantidade maior do que o estoque 
    quantidade = 200;  // 'quantidade' é um argumento passado para a função 
    removerEstoque(quantidade); 

    return 0; 
}

>>> Itens adicionados: 20
>>> Estoque atualizado: 120
>>> Itens removidos: 15
>>> Estoque atualizado: 105
>>> Erro: Quantidade insuficiente no estoque!

-----------------------------------------------------&&&

PARA ABRIR E CRIAR ARQUIVOS

A função fopen abre um arquivo, assim como os dispositivos console, impressora e saída serial, que podem ser abertos como arquivos.
As funções de manipulação de arquivos, assim como os ponteiros, devem ser declaradas juntamente com a declaração de variáveis.

Caso o arquivo não exista, um novo arquivo será criado.


FILE *fptr;                                   // Ponteiro para o arquivo 

fptr = fopen("nomedoarquivo.txt", "w");       // Para abrir o arquivo

....

fclose(fptr);                                 // Para fechar o arquivo



OBS: É importante fechar o arquivo com fclose() para liberar os recursos que estavam sendo alocados.

----------

FILE *fptr;

fptr = fopen("C:\\nomedapasta\\nomedoarquivo.txt", "w");       // Para abrir o arquivo em diretório específico

....

fclose(fptr);  


OBS: A função fopen() retorna o ponteiro para o arquivo ou NULL, em caso de erro na abertura do mesmo.


No exemplo acima foi usado o modo w (write). O modo pode conter um dos seguintes valores:

"r" − Leitura (open).  = Abre o arquivo para leitura
"w" − Escrita (write). = Abre o arquivo para escrita
"a" − Adição / Anexar (append) =  Abre o arquivo para adicionar conteúdo sem substituir os dados anteriores.
"r+" − Para atualizar um arquivo (read e write). =  Abre o arquivo para leitura e escrita
"w+" − Para criar um arquivo para atualização.
"a+" − Adição, em arquivo para leitura e escrita.

Os modos mais comuns são r (leitura), w (escrita), a (adicionar) e r+ (atualizar).

--------------

É possível e aconselhável checar se a abertura do arquivo ocorreu corretamente:

#include <stdio.h>

int main() {
    FILE *arquivo;               

    arquivo = fopen("nomedoarquivo.txt", "w");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo!\n"); 
        return 1;
    }

    ...
    return 0;
}

-----------------------------------------------------&&&

PARA ADICIONAR CONTEUDO A ARQUIVOS CRIADOS

FILE *fptr;

fptr = fopen("nomedoarquivo.txt", "w");                  // w = significa modo write (escrita)

fprintf(fptr, "Texto dentro no arquivo criado.");

....

fclose(fptr);


OBS: Se você gravar em um arquivo que já existe, o conteúdo antigo será excluído e o novo conteúdo será inserido. É importante saber disso, pois você pode apagar acidentalmente o conteúdo existente.

FILE *fptr;

fptr = fopen("nomedoarquivo.txt", "w");

fprintf(fptr, "Texto antigo.");

fprintf(fptr, "Texto novo que substituiu o texto antigo.");

....

fclose(fptr);


OBS: A função fprintf() é parecida com a função printf(), com a diferença de que printf() escreve na tela, enquanto fprintf() escreve no arquivo.

-----------------------------------------------------&&&

PARA ADICIONAR CONTEUDO EXTRA A ARQUIVOS SEM APAGAR O CONTEUDO ANTERIOR


FILE *fptr;

fptr = fopen("nomedoarquivo.txt", "a");               // a = significa modo append (anexar)

fprintf(fptr, "Texto 1.");

fprintf(fptr, "Texto 2.");

....

fclose(fptr);

OBS: Se o arquivo não existir, o modo append criará um novo arquivo com o conteúdo "anexado".


-----------------------------------------------------&&&

PARA LER E IMPRIMIR O CONTEUDO DE ARQUIVOS

FILE *fptr;

fptr = fopen("nomedoarquivo.txt", "r");               // r = significa modo read (ler)

char texto[100];                                      // crie uma string que pode armazenar uma quantidade de caracteres

fgets(texto, 100, fptr);                              // para armazenar o conteudo da string criada

printf("%s", texto);                                  // para imprimir o conteudo da string

fclose(fptr);

---------------

Como uma boa prática, podemos usar uma instrução if para testar se é NULL e imprimir algum texto em vez disso (quando o arquivo não existe):

FILE *fptr;

fptr = fopen("nomedoarquivo.txt", "r");

if(fptr == NULL) {
  printf("Não foi possível abrir este arquivo.");
}

fclose(fptr);

---------------

FILE *fptr;

fptr = fopen("arquivo.txt", "r");

char texto[100];

if(fptr != NULL) {                              // Se o arquivo existir
  while(fgets(texto, 100, fptr)) {
    printf("%s", texto);                        // Para imprimir o conteudo
  }
} else {                                        // Se o arquivo não existir
  printf("Não foi possível abrir o arquivo.");
}

fclose(fptr);

-----------------------------------------------------&&&

FUNÇÕES DE MANIPULAÇÃO DE ARQUIVOS

fopen()
Abre um arquivo para leitura, escrita ou atualização.

fgetc()
Responsável pela leitura de um caractere de um arquivo indicado pelo ponteiro file_pointer. No caso de chegar ao fim do arquivo, será retornado EOF. Sintaxe: [caractere] = fgetc (file_pointer).

fputc()
Responsável pela inserção de um caractere no arquivo. A função escreve o caractere na próxima posição do arquivo apontado pelo file_pointer. É a operação inversa de getc. Sintaxe: fputc (caractere, file_pointer).

ungetc()
Responsável em devolver o último caractere lido do arquivo para o file_pointer, aceitando apenas um caractere devolvido por vez (coloca em um buffer temporário). Sintaxe: ungetc (caractere, file_pointer).

fprintf()
Responsável pela saída formatada em arquivos, semelhante à função printf, mas atua sobre arquivos, definidos pelo primeiro parâmetro, que é um ponteiro para o arquivo. Sintaxe: fprintf (file_pointer,"controle", arg1, arg2,...).

fscanf()
Responsável pela entrada formatada a partir de arquivos. Atua como a função inversa de fprintf e análoga à função scanf, só que atuando sobre arquivos. Sintaxe: fscanf (file_pointer,"controle",arg1,arg2,...).

fclose()
Responsável pelo fechamento do arquivo em uso. É utilizado para encerrar o acesso a um arquivo previamente aberto, liberando os recursos associados a ele. Sintaxe: fclose (file_pointer).


Outras funções:

fflush(): Descarrega o buffer; 
fgets(): Obtém uma string do arquivo; 
fputs(): Insere uma string no arquivo; 
fread(): Lê um bloco de dados do arquivo; 
fwrite(): Escreve um bloco de dados no arquivo; 
fseek(): Reposiciona o ponteiro para o arquivo; 
rewind(): Reposiciona o ponteiro para o início do arquivo; 
ftell(): Retorna a posição do ponteiro.

-------------------------

EXEMPLO:

#include <stdio.h>

int main() {
    FILE *arquivo;               // Ponteiro para o arquivo 
    char nome[50];
    int idade;

    // Abrindo o arquivo no modo "w" para escrita 
    arquivo = fopen("dados.txt", "w");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo!\n"); 
        return 1;
    }

    // Coletando dados do usuário
    printf("Digite o nome: ");
    scanf("%s", nome);
    printf("Digite a idade: ");
    scanf("%d", &idade);

    // Gravando os dados no arquivo
    fprintf(arquivo, "Nome: %s\nIdade: %d\n", nome, idade);

    // Fechando o arquivo 
    fclose(arquivo);

    // Reabrindo o arquivo no modo "r" para Leitura 
    arquivo fopen("dados.txt", "r");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo!\n"); 
        return 1;
    }

    // Lendo os dados do arquivo
    fscanf(arquivo, "Nome: %s\nIdade: %d\n", nome, &idade);

    // Exibindo os dados lidos
    printf("Dados lidos do arquivo:\n");
    printf("Nome: %s\nIdade: %d\n", nome, idade);

    // Fechando o arquivo 
    fclose(arquivo);

    return 0;
}

-----------------------------------------------------

FUNÇÕES DE MANIPULAÇÂO DE TIPOS DE DADOS USANDO A BIBLIOTECA <ctype.h>

As funções de manipulação de tipos de dados em C, encontradas na biblioteca ctype.h, são utilizadas para verificar e transformar caracteres. 
Essas funções permitem determinar se um caractere é maiúsculo, minúsculo, numérico, alfabético, um espaço, ou um caractere ASCII.
Além disso, funções como tolower e toupper são usadas para converter caracteres entre maiúsculas e minúsculas. 

-------- &&&

Para verificar se um caractere é maiúsculo usando isupper():

Retornará diferente de zero se for maiúsculo e zero se for minúsculo ou um número.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'A';

  int verifica = isupper(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 256                    (verdadeiro pois é uma letra maiúscula)



char caractere = 'a';                   //retornará 0 pois é minúscula
int verifica = isupper(caractere);

char caractere = '3';                   //retornará 0 pois é um número
int verifica = isupper(caractere);

---------&&&

É possível criar uma condição if/else para imprimir o resultado:

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'b';

  int verifica = isupper(caractere);
  
  if(verifica == 0) {
  	printf("Não é maiúscula.");
  } else {
  	printf("É maiúscula.");  
  };

  return 0;
}

>>> Não é maiúscula.

Ou usar a própria função como condição do if:

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'A';
  
  if(isupper(caractere)) {
  	printf("É maiúscula.");            //Se for verdadeiro
  } else {
  	printf("Não é maiúscula.");        //Se for falso
  };

  return 0;
}

-------- &&&

Para verificar se um caractere é minúsculo usando islower():

Retornará diferente de zero se for maiúscula e zero se for minúscula ou um número.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'a';

  int verifica = islower(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 512                 (verdadeiro pois é uma letra minúscula)


---------- &&&

Para verificar se é um caractere alfabético usando isalpha():

Retornará diferente de zero se for verdade e zero se for falso.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'A';

  int verifica = isalpha(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 1024              (verdadeiro pois é uma letra do alfabeto)

----------&&&

Para verificar se é um digito / número usando isdigit():

Retornará diferente de zero se for verdade e zero se for falso.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = '3';

  int verifica = isdigit(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 2048              (verdadeiro pois é um número)

----------&&&

Para verificar se é um caractere de espaço usando isspace():

Retornará diferente de zero se for verdade e zero se for falso.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = ' ';

  int verifica = isspace(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 8192              (verdadeiro pois é um caractere de espaço)

----------&&&

Para verificar se é um caractere ASCII usando isascii():

Retornará diferente de zero se puder ser representada como um caractere no conjunto de caracteres US-ASCII de 7–bit . Caso contrário, retornará 0.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'a';

  int verifica = isascii(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 1              (verdadeiro pois pode ser representada com um caractere ascii - a = 0x81)

----------&&&

Para verificar se é um caractere de impressão usando isprint():

Retornará diferente de zero se for verdade e zero se for falso.

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'a';

  int verifica = isprint(caractere);

  printf("%d", verifica);

  return 0;
}

>>> 16384              (verdadeiro pois é um caractere que pode ser impresso)

--------- &&&

Para converter um caractere/letra minúscula para maiúscula usando toupper():

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'a';

  char converter = toupper(caractere);

  printf("%c", converter);

  return 0;
}

>>> A

------ &&&

Para converter uma string de texto em maiúscula e imprimir:

#include <stdio.h>
#include <ctype.h>

int main() {

  char txt[] = "texto";
  int i = 0;

  while(txt[i]) {
      if(islower(txt[i])) {
          txt[i] = toupper(txt[i]);
          printf("%c", txt[i]);
          i++;
      } 
  }

  return 0;
}

>>> TEXTO


Porém, é necessário fazer algumas checagens caso tenha espaço entre as palavras ou tenha algum número:

#include <stdio.h>
#include <ctype.h>

int main() {

  char txt[] = "texto de exemplo 1";
  int i = 0;

  while(txt[i]) {

      if (isalpha(txt[i])) {                   //Para checar se é uma letra do alfabeto
          if (islower(txt[i])) {               //Para checar se é uma letra minúscula
              txt[i]= toupper(txt[i]);         //Para converter para maiúscula
              printf("%c", txt[i]);
          }  
      } 
      else if (isspace(txt[i])) {              //Para checar se é um espaço em branco
          printf("%c", txt[i]);  
      } 
      else if (isdigit(txt[i])) {              //Para checar se é um número
          printf("%c", txt[i]);  
      }      
      i++;
  }

  return 0;
}

>>> TEXTO DE EXEMPLO 1

------ &&&

Versão alternativa resumida:

#include <stdio.h> 
#include <ctype.h>

int main() {
    char texto[] = "texto de exemplo 1"; 
    int i = 0;

    while (texto[i]) {                       
        if (isalpha(texto[i]) || isdigit(texto[i])) {            //Se é letra do alfabeto ou número    
            if (islower(texto[i])) {                             //Se é letra minúscula
                texto[i] = toupper(texto[i]);                    //Converte para maiúscula
            }
        }
        i++;
    }

    printf("%s", texto);                       

    return 0;
}

>>> TEXTO DE EXEMPLO 1

--------- &&&

Para converter um caractere/letra maiúscula para minúscula usando tolower():

#include <stdio.h>
#include <ctype.h>

int main() {
  
  char caractere = 'A';

  char converter = tolower(caractere);

  printf("%c", converter);

  return 0;
}

>>> a     

------ &&&

Para converter uma string de texto em minúscula e imprimir:

#include <stdio.h>
#include <ctype.h>

int main() {

  char txt[] = "TEXTO";
  int i = 0;

  while(txt[i]) {
      if(isupper(txt[i])) {
          txt[i] = tolower(txt[i]);
          printf("%c", txt[i]);
          i++;
      } 
  }

  return 0;
}

>>> texto


Porém, é necessário fazer algumas checagens caso tenha espaço entre as palavras ou tenha algum número:

#include <stdio.h>
#include <ctype.h>

int main() {

  char txt[] = "TEXTO DE EXEMPLO 1";
  int i = 0;

  while(txt[i]) {

      if (isalpha(txt[i])) {                   //Para checar se é uma letra do alfabeto
          if (isupper(txt[i])) {               //Para checar se é uma letra maiúscula
              txt[i]= tolower(txt[i]);         //Para converter para minúscula
              printf("%c", txt[i]);
          }  
      } 
      else if (isspace(txt[i])) {              //Para checar se é um espaço em branco
          printf("%c", txt[i]);  
      } 
      else if (isdigit(txt[i])) {              //Para checar se é um número
          printf("%c", txt[i]);  
      }      
      i++;
  }

  return 0;
}

>>> texto de exemplo 1

------ &&&

Versão alternativa resumida:

#include <stdio.h> 
#include <ctype.h>

int main() {
    char texto[] = "TEXTO DE EXEMPLO 1"; 
    int i = 0;

    while (texto[i]) {                       
        if (isalpha(texto[i]) || isdigit(texto[i])) {            //Se é letra do alfabeto ou número    
            if (isupper(texto[i])) {                             //Se é letra maiúscula
                texto[i] = tolower(texto[i]);                    //Converte para minúscula
            }
        }
        i++;
    }

    printf("%s", texto);                       

    return 0;
}

>>> texto de exemplo 1

---------------------

Outro exemplo:

#include <stdio.h> 
#include <ctype.h>

int main() {
    char texto[] = "Programacao123"; 
    int i = 0;

    while (texto[i]) {                                     // Percorrendo cada caractere da string 
        if (isalpha(texto[i])) {                           // Verificando se é uma Letra
            printf("%c - uma letra.\n", texto[i]);

            if (islower (texto[i])) {                      // Transformando em maiúsculo se for minúscula 
                texto[i] = toupper(texto[i]);
                printf("Convertido para maiusculo: %c\n", texto[i]);
            }
        }
        
        else if (isdigit (texto[i])) {                     // Verificando se é um número
            printf("%c - um numero.\n", texto[i]);
        }
        i++;
    }

    printf("%s", texto);                                   //Imprimindo o texto convertido

    return 0;
}

-----------------------------------------------------&&&

STRUCTS (REGISTROS / ESTRUTURAS HETEROGENEAS)
(parecido com classes)

Sintaxe:

struct Estrutura {   
    tipo membro1;
    tipo membro2;
    tipo membro3;
    ...  
};

int main() {
    struct Estrutura variavel1;
    return 0;
}

OBS: É comum chamar os membros de elementos ou campos.

Outra forma:

struct Estrutura {   
    tipo membro1;
    tipo membro2;
    tipo membro3;
    ...  
} Estrutura1;

OBS: Estrutura1 é uma variável do tipo estrutura


Outra forma com mais de 1 variável do tipo estrutura:

struct Estrutura {   
    tipo membro1;
    tipo membro2;
    tipo membro3;
    ...  
} Estrutura1, Estrutura2, Estrutura3;



É possível utilizar também o tipo typedef:

typedef struct {   
    tipo membro1;
    tipo membro2;
    tipo membro3;
    ...  
} Estrutura;

-------------------

#include <stdio.h>

struct Calendario {   
    int dia;
    int mes;
    int ano; 
};

int main() {

    struct Calendario data;

    data.dia = 25;
    data.mes = 12;
    data.ano = 1987;

    printf("%d / %d / %d", data.dia, data.mes, data.ano);

    return 0;
};

--------------------

#include <stdio.h>

struct Calendario {   
    int dia;
    int mes;
    int ano; 
};

int main() {

    struct Calendario data1;

    data1.dia = 25;
    data1.mes = 12;
    data1.ano = 1995;

    printf("%d / %d / %d \n", data1.dia, data1.mes, data1.ano);

    struct Calendario data2;

    data2.dia = 13;
    data2.mes = 10;
    data2.ano = 2003;

    printf("%d / %d / %d \n", data2.dia, data2.mes, data2.ano);

    return 0;
};

-------------------

Para atribuir valores para strings ao usar structs, é necessário usar a biblioteca <string.h> e strcpy() :

#include <stdio.h>
#include <string.h>

struct Veiculos {   
    char nome[50];
};

int main() {

    struct Veiculos carro;

    strcpy(carro.nome, "Ferrari"); 

    printf("%s", carro.nome);

    return 0;
};

-----

Outra forma de atribuir valores em strings sem utilizar a biblioteca <string.h> e a função strcpy() :

#include <stdio.h>

struct Veiculos {   
    char nome[50];
    int ano;
};

int main() {

    struct Veiculos carro = {"Ferrari" , 2025};

    printf("Nome do carro: %s \n", carro.nome);
    printf("Ano do carro: %d \n", carro.ano);

    return 0;
};

-----

#include <stdio.h>

struct Veiculos {   
    char nome[50];
};

int main() {

    struct Veiculos carro1 = {"Ferrari"};
    struct Veiculos carro2 = {"Mercedes"};

    printf("Nome do carro 1: %s \n", carro1.nome);
    printf("Nome do carro 2: %s \n", carro2.nome);

    return 0;
};

-----

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char telefone[15]; 
};

int main() {

    struct Pessoas pessoa1;

    strcpy(pessoa1.nome, "Maria");
    pessoa1.idade = 32;
    strcpy(pessoa1.telefone, "98765-1234");

    printf(" %s \n %d \n %s \n\n ", pessoa1.nome, pessoa1.idade, pessoa1.telefone);

    struct Pessoas pessoa2;

    strcpy(pessoa2.nome, "José");
    pessoa2.idade = 23;
    strcpy(pessoa2.telefone, "12345-6789");

    printf( "%s \n %d \n %s \n\n ", pessoa2.nome, pessoa2.idade, pessoa2.telefone);

    return 0;
};


-----------------------------------------------------&&&

COPIAR O CONTEUDO DE UMA STRUCT

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    char sobrenome[50]; 
    int idade;
};

int main() {

    struct Pessoas pessoa1;

    strcpy(pessoa1.nome, "Maria");
    strcpy(pessoa1.sobrenome, "Nazaré");
    pessoa1.idade = 25;

    struct Pessoas pessoa2;

    pessoa2 = pessoa1;               //Copiou as informações de pessoa1

    printf("Nome: %s\n", pessoa2.nome);
    printf("Sobrenome: %s\n", pessoa2.sobrenome);
    printf("Idade: %d\n", pessoa2.idade);

    return 0;
};

-----

Outro exemplo:

struct Paciente paciente1 = {"Joana", 26, "12345-6789"};
struct Paciente paciente2;

paciente2 = paciente1;                               //Cópia direta

printf("Nome do paciente 2: %s\n", paciente2.nome);

>>> Nome do paciente 2: Joana

-----

Para alterar o valor copiado da struct:

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    char sobrenome[50]; 
    int idade;
};

int main() {

    struct Pessoas pessoa1;

    strcpy(pessoa1.nome, "Maria");
    strcpy(pessoa1.sobrenome, "Nazaré");
    pessoa1.idade = 25;

    struct Pessoas pessoa2;

    pessoa2 = pessoa1;

    strcpy(pessoa2.nome, "Jesus");          //Alterou o nome Maria para Jesus

    printf("Nome: %s\n", pessoa2.nome);

    return 0;
};

-----------------------------------------------------&&&

PONTEIROS EM STRUCTS

° Operador de membro de estrutura . (operador de ponto ou de seleção direta). ACESSO DIRETO
° Operador de ponteiro de estrutura -> (operador de seta). ACESSO INDIRETO

A principal diferença é que quando você tem um array de estruturas (mesmo alocado dinamicamente), você acessa os campos usando o operador ponto (.), não o operador seta (->). O operador seta é usado quando você tem um ponteiro para uma única estrutura.

----------

ACESSO DIRETO (.):

Exemplo 1:
(Com 1 objeto e sem função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa;                           

    strcpy(pessoa.nome, "Maria"); 

    printf("%s", pessoa.nome);

    return 0;
};

>>> Maria


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa = {"Maria"};

    printf("%s", pessoa.nome);

    return 0;
};

>>> Maria

----------

Exemplo 2:
(Com vários objetos e sem função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa[3];                         

    strcpy(pessoa[0].nome, "Maria"); 
    strcpy(pessoa[1].nome, "Ana"); 
    strcpy(pessoa[2].nome, "Carlos"); 

    printf("%s", pessoa[1].nome);

    return 0;
};

>>> Ana


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa[3] = {"Maria", "Ana", "Carlos"};

    printf("%s", pessoa[1].nome);

    return 0;
};

>>> Ana

----------

Exemplo 3:
(Com 1 objeto e com função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas pessoa) {
	printf("%s", pessoa.nome);
}

int main() {

    struct Pessoas pessoa;                      // Ou struct Pessoas pessoa = {"Maria"};      

    strcpy(pessoa.nome, "Maria"); 

    Imprimir(pessoa);

    return 0;
};

>>> Ana


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas pessoa) {
  if (pessoa == NULL) {
    printf("Erro: Ponteiro nulo!\n");
    return;
  }
	printf("%s", pessoa.nome);
}

int main() {

    struct Pessoas pessoa = {"Maria"};      

    Imprimir(pessoa);

    return 0;
};

>>> Ana

-----------

Exemplo 4:
(Com vários objetos e com função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas pessoa) {
	printf("%s", pessoa.nome);
}

int main() {

    struct Pessoas pessoa[3];                           

    strcpy(pessoa[0].nome, "Maria"); 
    strcpy(pessoa[1].nome, "Ana"); 
    strcpy(pessoa[2].nome, "Carlos"); 

    Imprimir(pessoa[1]);

    return 0;
};

>>> Ana


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas pessoa) {
	printf("%s", pessoa.nome);
}

int main() {

    struct Pessoas pessoa[3] = {"Maria", "Ana", "Carlos"};      

    Imprimir(pessoa[1]);

    return 0;
};

>>> Ana

----------

Exemplo 5:    
(Com vários objetos, função para imprimir e ponteiro para receber o array de structs)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas ptr) {
	printf("%s", ptr.nome);
}

int main() {   
    
    struct Pessoas pessoa[3];
    
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 

    Imprimir(ptr[2]);

    return 0;
};

>>> Carlos


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas ptr) {
	printf("%s", ptr.nome);
}

int main() {   
    
    struct Pessoas pessoa[3] = {"Maria", "Ana", "Carlos"}; 
    
    struct Pessoas *ptr = &pessoa;    

    Imprimir(ptr[2]);

    return 0;
};

---------- &&&

É possível utilizar o acesso direto a vários objetos fora de um array de outra forma também:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa1 = {"Maria"};
    struct Pessoas *ptr1 = &pessoa1;
    
    struct Pessoas pessoa2 = {"Ana"};
    struct Pessoas *ptr2 = &pessoa2;
    
    struct Pessoas pessoa3 = {"Carlos"};
    struct Pessoas *ptr3 = &pessoa3;

    printf("%s", (*ptr2).nome);

    return 0;
};

------

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir(struct Pessoas ptr2){
    printf("%s", ptr2.nome);
}

int main() {

    struct Pessoas pessoa1 = {"Maria"};
    struct Pessoas *ptr1 = &pessoa1;
    
    struct Pessoas pessoa2 = {"Ana"};
    struct Pessoas *ptr2 = &pessoa2;
    
    struct Pessoas pessoa3 = {"Carlos"};
    struct Pessoas *ptr3 = &pessoa3;
    
    Imprimir((*ptr2));

    return 0;
};

----------

Exemplo 6:   
(Com vários objetos, função para imprimir, ponteiro para receber o array de structs e alocação/liberação de memória)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas ptr) {
	printf("%s", ptr.nome);
}

int main() {   
    
    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));

    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 

    Imprimir(ptr[1]);

    free(ptr);

    ptr = NULL;

    return 0;
};

>>> Ana

-----------------

Exemplo 7:    (Forma completa)
(Com vários objetos e membros, função para imprimir, ponteiro para receber o array de structs e alocação/liberação de memória)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas ptr) {
	printf("%s %d %s", ptr.nome, ptr.idade, ptr.sexo);
}

int main() {   
    
    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));

    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 
    
    ptr[0].idade = 23; 
    ptr[1].idade = 18; 
    ptr[2].idade = 32; 
    
    strcpy(ptr[0].sexo, "Feminino"); 
    strcpy(ptr[1].sexo, "Feminino"); 
    strcpy(ptr[2].sexo, "Masculino"); 

    Imprimir(ptr[1]);
    
    free(ptr);

    ptr = NULL;

    if (ptr != NULL) {
      printf("Memoria não foi liberada corretamente e o ponteiro não está inválido.\n");
    }

    return 0;
};

>>> Ana 18 Feminino


----------------------------------------------------&&&

PARA IMPRIMIR OS ELEMENTOS DE UM STRUCT USANDO UM FOR()


Exemplo 1:
(Sem função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

int main() {

    struct Pessoas pessoa[3];                           

    strcpy(pessoa[0].nome, "Maria"); 
    pessoa[0].idade = 23; 
    strcpy(pessoa[0].sexo, "Feminino");  
    
    strcpy(pessoa[1].nome, "Ana"); 
    pessoa[1].idade = 18; 
    strcpy(pessoa[1].sexo, "Feminino"); 
    
    strcpy(pessoa[2].nome, "Carlos"); 
    pessoa[2].idade = 35; 
    strcpy(pessoa[2].sexo, "Masculino"); 
    
	for (int i = 0; i < 3; i++) {
    	printf("Nome: %s\n", pessoa[i].nome);
    	printf("Idade: %d\n", pessoa[i].idade);
    	printf("Sexo: %s\n\n", pessoa[i].sexo);
  	}

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>>
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino

-----------

Exemplo 2:
(sem função e com ponteiro com acesso direto)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

int main() {

    struct Pessoas pessoa[3]; 
    struct Pessoas *ptr = pessoa;

    strcpy(ptr[0].nome, "Maria"); 
    ptr[0].idade = 23; 
    strcpy(ptr[0].sexo, "Feminino");  
    
    strcpy(ptr[1].nome, "Ana"); 
    ptr[1].idade = 18; 
    strcpy(ptr[1].sexo, "Feminino"); 
    
    strcpy(ptr[2].nome, "Carlos"); 
    ptr[2].idade = 35; 
    strcpy(ptr[2].sexo, "Masculino"); 
    
	for (int i = 0; i < 3; i++) {
    	printf("Nome: %s\n", ptr[i].nome);           //acesso direto (.)
    	printf("Idade: %d\n", ptr[i].idade);         //acesso direto (.)
    	printf("Sexo: %s\n\n", ptr[i].sexo);         //acesso direto (.)
  	}

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>>
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino

OBS: Não é possivel realizar a impressão usando for com ponteiro com acesso indireto, já que não trabalha com arrays de estruturas.

------------ 

Exemplo 3:
(com função para imprimir todos os objetos)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas pessoa[]) {
    for (int i = 0; i < 3; i++) {
    	printf("Nome: %s\n", pessoa[i].nome);
    	printf("Idade: %d\n", pessoa[i].idade);
    	printf("Sexo: %s\n\n", pessoa[i].sexo);
  	}
}

int main() {

    struct Pessoas pessoa[3];                           

    strcpy(pessoa[0].nome, "Maria"); 
    pessoa[0].idade = 23; 
    strcpy(pessoa[0].sexo, "Feminino");  
    
    strcpy(pessoa[1].nome, "Ana"); 
    pessoa[1].idade = 18; 
    strcpy(pessoa[1].sexo, "Feminino"); 
    
    strcpy(pessoa[2].nome, "Carlos"); 
    pessoa[2].idade = 35; 
    strcpy(pessoa[2].sexo, "Masculino");

    Imprimir(pessoa);

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>>
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino

-------------------

Exemplo 4:
(com função para imprimir um objeto especifico)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas pessoa) {
    printf("Nome: %s\n", pessoa.nome);
    printf("Idade: %d\n", pessoa.idade);
    printf("Sexo: %s\n\n", pessoa.sexo);
}

int main() {

    struct Pessoas pessoa[3];                           

    strcpy(pessoa[0].nome, "Maria"); 
    pessoa[0].idade = 23; 
    strcpy(pessoa[0].sexo, "Feminino");  
    
    strcpy(pessoa[1].nome, "Ana"); 
    pessoa[1].idade = 18; 
    strcpy(pessoa[1].sexo, "Feminino"); 
    
    strcpy(pessoa[2].nome, "Carlos"); 
    pessoa[2].idade = 35; 
    strcpy(pessoa[2].sexo, "Masculino");

    Imprimir(pessoa[1]);

    return 0;
};

>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino


Versão alternativa passando o indice como parametro pela chamada da função:

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas pessoa[], int index) {
    printf("Nome: %s\n", pessoa[index].nome);
    printf("Idade: %d\n", pessoa[index].idade);
    printf("Sexo: %s\n\n", pessoa[index].sexo);
}

int main() {

    struct Pessoas pessoa[3];                           

    strcpy(pessoa[0].nome, "Maria"); 
    pessoa[0].idade = 23; 
    strcpy(pessoa[0].sexo, "Feminino");  
    
    strcpy(pessoa[1].nome, "Ana"); 
    pessoa[1].idade = 18; 
    strcpy(pessoa[1].sexo, "Feminino"); 
    
    strcpy(pessoa[2].nome, "Carlos"); 
    pessoa[2].idade = 35; 
    strcpy(pessoa[2].sexo, "Masculino");

    Imprimir(pessoa, 1);

    return 0;
};

>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino


-------------------

Exemplo 5:
(com função para imprimir e com ponteiro)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas ptr[]) {
    for (int i = 0; i < 3; i++) {
    	printf("Nome: %s\n", ptr[i].nome);
    	printf("Idade: %d\n", ptr[i].idade);
    	printf("Sexo: %s\n\n", ptr[i].sexo);
  	}
}

int main() {

    struct Pessoas pessoa[3];   
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr[0].nome, "Maria"); 
    ptr[0].idade = 23; 
    strcpy(ptr[0].sexo, "Feminino");  
    
    strcpy(ptr[1].nome, "Ana"); 
    ptr[1].idade = 18; 
    strcpy(ptr[1].sexo, "Feminino"); 
    
    strcpy(ptr[2].nome, "Carlos"); 
    ptr[2].idade = 35; 
    strcpy(ptr[2].sexo, "Masculino");

    Imprimir(ptr);

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>>
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino

-------------

Exemplo 5:
(com função, com ponteiro e alocação/liberação de memória)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas ptr[]) {
    for (int i = 0; i < 3; i++) {
    	printf("Nome: %s\n", ptr[i].nome);
    	printf("Idade: %d\n", ptr[i].idade);
    	printf("Sexo: %s\n\n", ptr[i].sexo);
  	}
}

int main() {
 
    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));

    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr[0].nome, "Maria"); 
    ptr[0].idade = 23; 
    strcpy(ptr[0].sexo, "Feminino");  
    
    strcpy(ptr[1].nome, "Ana"); 
    ptr[1].idade = 18; 
    strcpy(ptr[1].sexo, "Feminino"); 
    
    strcpy(ptr[2].nome, "Carlos"); 
    ptr[2].idade = 35; 
    strcpy(ptr[2].sexo, "Masculino");

    Imprimir(ptr);
    
    free(ptr);

    ptr = NULL;

    if (ptr != NULL) {
      printf("Memoria não foi liberada corretamente e o ponteiro não está inválido.\n");
    }

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>>
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino
>>>


---------------------------------------------------- &&&

ACESSO INDIRETO (->):

Exemplo 1:
(Com 1 objeto e sem função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa;                   
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr->nome, "Maria"); 

    printf("%s", ptr->nome);                       //ptr->nome    é igual ao acesso direto   (*ptr).nome

    return 0;
};

>>> Maria


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

int main() {

    struct Pessoas pessoa = {"Maria"};
    struct Pessoas *ptr = &pessoa;

    printf("%s", ptr->nome);

    return 0;
};

>>> Maria

-------

Exemplo 2:
(Com 1 objeto e com função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s", ptr->nome);
}

int main() {

    struct Pessoas pessoa;
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr->nome, "Maria"); 

    Imprimir(ptr);

    return 0;
};

>>> Maria

-----------

Exemplo 3:
(Com 1 objeto, vários membros e com função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas pessoa;
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr->nome, "Maria"); 
    ptr->idade = 23; 
    strcpy(ptr->sexo, "Feminino"); 

    Imprimir(ptr);

    return 0;
};

>>> Maria 23 Feminino


Versão alternativa:

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas pessoa = {"Maria", 23, "Feminino"};
    struct Pessoas *ptr = &pessoa;

    Imprimir(ptr);

    return 0;
};

>>> Maria 23 Feminino

-----------

Exemplo 4:
(Com vários objetos e com função para imprimir)

Diferentemente do acesso direto (.), o operador seta (->) é usado quando você tem um ponteiro para uma única estrutura.
Portanto não é possível passar um array de structs como parametro de uma função.

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s", ptr->nome);
}

int main() {

    struct Pessoas pessoa[3];
    
    struct Pessoas *ptr = pessoa;

    strcpy(ptr[0]->nome, "Maria"); 
	strcpy(ptr[1]->nome, "Ana"); 
	strcpy(ptr[2]->nome, "Carlos"); 
    
    Imprimir(&ptr[2]);

    return 0;
};

>>> ERRO !!!


Portanto é necessário usar o acesso direto (.) para passar arrays de estruturas

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s", ptr->nome);
}

int main() {

    struct Pessoas pessoa[3];
    
    struct Pessoas *ptr = pessoa;

    strcpy(ptr[0].nome, "Maria"); 
	  strcpy(ptr[1].nome, "Ana"); 
	  strcpy(ptr[2].nome, "Carlos"); 
    
    Imprimir(&ptr[2]);

    return 0;
};

>>> Carlos


Ou utilizar somente acesso direto em todos os ponteiros:

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas ptr) {
	printf("%s", ptr.nome);
}

int main() {   
    
    struct Pessoas pessoa[3];
    
    struct Pessoas *ptr = &pessoa;

    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 

    Imprimir(ptr[2]);

    return 0;
};

>>> Carlos

--------

Exemplo 5:
(Com vários objetos, vários membros e função para imprimir)

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas pessoa1;
    struct Pessoas *ptr1 = &pessoa1;

    strcpy(ptr1->nome, "Maria"); 
    ptr1->idade = 23; 
    strcpy(ptr1->sexo, "Feminino"); 


    struct Pessoas pessoa2;
    struct Pessoas *ptr2 = &pessoa2;

    strcpy(ptr2->nome, "Ana"); 
    ptr2->idade = 18; 
    strcpy(ptr2->sexo, "Feminino"); 


    struct Pessoas pessoa3;
    struct Pessoas *ptr3 = &pessoa3;

    strcpy(ptr3->nome, "Carlos"); 
    ptr3->idade = 35; 
    strcpy(ptr3->sexo, "Masculino"); 

    Imprimir(ptr2);

    return 0;
};

>>> Ana 18 Feminino


Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas pessoa1 = {"Maria", 23, "Feminino"};
    struct Pessoas *ptr1 = &pessoa1;

    struct Pessoas pessoa2 = {"Ana", 18, "Feminino"};
    struct Pessoas *ptr2 = &pessoa2;

    struct Pessoas pessoa3 = {"Carlos", 35, "Masculino"};
    struct Pessoas *ptr3 = &pessoa3;

    Imprimir(ptr2);

    return 0;
};

>>> Ana 18 Feminino

---------

Exemplo 6:
(Com 1 objeto, vários membros, função para imprimir e alocação/liberação de memória)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));
    
    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr->nome, "Maria"); 
    ptr->idade = 23; 
    strcpy(ptr->sexo, "Feminino"); 

    Imprimir(ptr);

    free(ptr);

    ptr = NULL;

    if (ptr != NULL) {
      printf("Memoria não foi liberada corretamente e o ponteiro não está invalido.\n");
    }

    return 0;
};

>>> Maria 23 Feminino

--------

Exemplo 7:  (Forma completa)
(Com vários objetos, vários membros, função para imprimir e alocação/liberação de memória)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir(struct Pessoas *ptr) {
	printf("%s %d %s", ptr->nome, ptr->idade, ptr->sexo);
}

int main() {

    struct Pessoas *ptr1 = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));
    struct Pessoas *ptr2 = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));
    struct Pessoas *ptr3 = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));
    
    if (ptr1 == NULL && ptr2 == NULL && ptr3 == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr1->nome, "Maria"); 
    ptr1->idade = 23; 
    strcpy(ptr1->sexo, "Feminino"); 

    strcpy(ptr2->nome, "Ana"); 
    ptr2->idade = 18; 
    strcpy(ptr2->sexo, "Feminino"); 

    strcpy(ptr3->nome, "Carlos"); 
    ptr3->idade = 35; 
    strcpy(ptr3->sexo, "Masculino"); 

    Imprimir(ptr2);

    free(ptr1);
    free(ptr2);
    free(ptr3);

    return 0;
};

>>> Ana 18 Feminino


--------------------- &&&

PARA CHECAR SE A IMPORTAÇÃO DO PARAMETRO DA FUNÇÃO OCORREU CORRETAMENTE

#include <stdio.h>
#include <string.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas *ptr) {

  	if (ptr == NULL) {
    	printf("Erro: Ponteiro nulo!\n");
    	return;
  	}
    
	printf("%s", ptr->nome);           //acesso indireto
}

int main() {   
    
    struct Pessoas pessoa[3];
    
    struct Pessoas *ptr = pessoa;

    strcpy(ptr[0].nome, "Maria");      //acesso direto
    strcpy(ptr[1].nome, "Ana");        //acesso direto 
    strcpy(ptr[2].nome, "Carlos");     //acesso direto

    Imprimir(&ptr[2]);

    return 0;
};



Versão alternativa:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir (struct Pessoas *ptr) {

  	if (ptr == NULL) {
    	printf("Erro: Ponteiro nulo!\n");
    	return;
  	}
  
	printf("%s", ptr->nome);            //acesso indireto
}

int main() {   
    
    struct Pessoas pessoa[3] = {"Maria", "Ana", "Carlos"}; 
    
    struct Pessoas *ptr = &pessoa;    

    Imprimir(&ptr[2]);                //Ou Imprimir(ptr + 2);

    return 0;
};

>>> Carlos

--------------------------------------------------

Forma completa com acesso direto e indireto:
Vários objetos, com função para imprimir e alocação e liberação de memória


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
};

void Imprimir(struct Pessoas *ptr) {
    printf("%s", ptr->nome);
}

int main() {

    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));
    
    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }
    
    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 
    

    Imprimir(&ptr[1]);                //Ou  Imprimir(ptr + 1); 
    
    free(ptr);

    ptr = NULL;
    
    return 0;
}

-----------------------------------------------------&&&

MAIS EXEMPLOS DE STRUCTS

struct Pessoa {
   char nome[50];
   int idade;
   char telefone[15];
};

struct Pessoa pessoa1 = {"Maria", 28, "12345-6789"};      //Inicialização direta da Struct

struct Pessoa pessoa2;
strcpy(pessoa2.nome, "João");                             //Inicialização com strcpy
pessoa2.idade = 32;
strcpy(pessoa2.telefone, "98765-4321");

-----------

#include <stdio.h>
#include <string.h>

struct Pessoa {
   char nome[50];
   int idade;
   char telefone[15];
};

int main() {
   struct Pessoa lista[3];
   int i;

   // Preenchendo as informações para cada pessoa
   strcpy(lista[0].nome, "Alana");
   lista[0].idade = 18;
   strcpy(lista[0].telefone, "12345-6789");

   strcpy(lista[1].nome, "Lucas");
   lista[1].idade = 14;
   strcpy(lista[1].telefone, "98765-4321");

   strcpy(lista[2].nome, "Julia");
   lista[2].idade = 8;
   strcpy(lista[2].telefone, "54321-6789");

   // Imprimindo as informações
   for (i = 0; i < 3; i++) {
      printf("Nome: %s\n", lista[i].nome);
      printf("Idade: %d\n", lista[i].idade);
      printf("Telefone: %s\n\n", lista[i].telefone);
   }

   return 0;
}

>>> Nome: Alana
>>> Idade: 18
>>> Telefone: 12345-6789
>>>
>>> Nome: Lucas
>>> Idade: 14
>>> Telefone: 98765-4321
>>>
>>> Nome: Julia
>>> Idade: 8
>>> Telefone: 54321-6789
>>>

-----------------

#include <stdio.h>
#include <string.h>

struct Paciente {
   char nome[50];
   int idade;
   char telefone[15];
};

int main(){
   struct Paciente paciente1;

   strcpy(paciente1.nome, "Maria Oliveira");
   paciente1.idade = 30;
   strcpy(paciente1.telefone, "1234-6789");
  
   printf("Nome: %s\n", paciente1.nome);
   printf("Idade: %d\n", paciente1.idade);
   printf("Telefone: %s\n", paciente1.telefone);
  
   return 0;
}

>>> Nome: Maria Oliveira
>>> Idade: 30
>>> Telefone: 1234-6789


----------------

#include <stdio.h>
#include <string.h>

struct Paciente {
   char nome[50];
   int idade;
   char telefone[15];
};

int main(){

   struct Paciente paciente1;
   struct Paciente *pPaciente = &paciente1;

   strcpy(pPaciente->nome, "Carlos Silva");
   pPaciente->idade = 45;
   strcpy(pPaciente->telefone, "98765-4321");

   printf("Nome: %s\n", paciente1.nome);
   printf("Idade: %d\n", paciente1.idade);
   printf("Telefone: %s\n", paciente1.telefone);
  
   return 0;
}

>>> Nome: Carlos Silva
>>> Idade: 45
>>> Telefone: 98765-4321


------------

#include <stdio.h>
#include <string.h>

struct Paciente {
   char nome[50];
   int idade;
   char telefone[15];
};

int main(){

  struct Paciente *pPaciente = (struct Paciente *)
  malloc(sizeof(struct Paciente));

  if (pPaciente != NULL) {

    strcpy(pPaciente->nome, "Ana Costa");
    pPaciente->idade = 28;
    strcpy(pPaciente->telefone, "54321-9876");

    printf("Nome: %s\n", pPaciente->nome);
    printf("Idade: %d\n", pPaciente->idade);
    printf("Telefone: %s\n", pPaciente->telefone);

    free(pPaciente); 
  }
  
  return 0;
}

>>> Nome: Ana Costa
>>> Idade: 28
>>> Telefone: 54321-9876

--------------

#include <stdio.h>
#include <string.h>

struct Paciente {
   char nome[50];
   int idade;
   char telefone[15];
};

int main() {
   struct Paciente pacientes[3];
   int i;

   strcpy(pacientes[0].nome, "Alana");
   pacientes[0].idade = 18;
   strcpy(pacientes[0].telefone, "12345-6789");

   strcpy(pacientes[1].nome, "Lucas");
   pacientes[1].idade = 14;
   strcpy(pacientes[1].telefone, "98765-4321");

   strcpy(pacientes[2].nome, "Julia");
   pacientes[2].idade = 8;
   strcpy(pacientes[2].telefone, "54321-6789");

   for (i = 0; i < 3; i++) {
      printf("Paciente %d: \n", i + 1);
      printf("Nome: %s\n", pacientes[i].nome);
      printf("Idade: %d\n", pacientes[i].idade);
      printf("Telefone: %s\n\n", pacientes[i].telefone);
   }

   return 0;
}

>>> Paciente 1: 
>>> Nome: Alana
>>> Idade: 18
>>> Telefone: 12345-6789
>>>
>>> Paciente 2: 
>>> Nome: Lucas
>>> Idade: 14
>>> Telefone: 98765-4321
>>>
>>> Paciente 3: 
>>> Nome: Julia
>>> Idade: 8
>>> Telefone: 54321-6789
>>>

----------------

#include <stdio.h>
#include <string.h>

struct Paciente {
    char nome[50];
    int idade;
    char telefone[15];
};

void exibirPaciente(struct Paciente p) {
    printf("Nome: %s\n", p.nome);
    printf("Idade: %d\n", p.idade);
    printf("Telefone: %s\n", p.telefone);
}

int main() {
    struct Paciente paciente1 = {"Fernando", 22, "72653-8476"};
    exibirPaciente(paciente1);
    return 0;
}

>>> Nome: Fernando
>>> Idade: 22
>>> Telefone: 72653-8476

--------------

#include <stdio.h>
#include <string.h>

struct Aluno {
    int codigo;
    char nome[50];
    float nota;
};

void imprimir(struct Aluno aluno_especial){
    printf("Código: %d\n", aluno_especial.codigo);
    printf("Nome: %s\n", aluno_especial.nome);
    printf("Nota: %.2f\n", aluno_especial.nota);
}

int main() {
   	struct Aluno aluno_especial;
   
   	aluno_especial.codigo = 10;
	  strcpy(aluno_especial.nome, "Manoel");
	  aluno_especial.nota = 10.0;
   
   	imprimir(aluno_especial);
   
   	return 0;
}

>>> Código: 10
>>> Nome: Manoel
>>> Nota: 10.00

-------------------------

#include <stdio.h>
#include <string.h>

struct Aluno {
   int codigo;
   char nome[50];
   float nota;
};

// Opção 1: Função para receber o array completo e o índice do aluno a ser impresso
void imprimir1(struct Aluno aluno_especial[], int indice) {
   printf("Código: %d\n", aluno_especial[indice].codigo);
   printf("Nome: %s\n", aluno_especial[indice].nome);
   printf("Nota: %.2f\n", aluno_especial[indice].nota);
}

// Opção 2: Função para imprimir um único aluno
void imprimir2(struct Aluno aluno_especial) {
   printf("Código: %d\n", aluno_especial.codigo);
   printf("Nome: %s\n", aluno_especial.nome);
   printf("Nota: %.2f\n", aluno_especial.nota);
}

int main() {
   struct Aluno aluno_especial[3];
   
   aluno_especial[0].codigo = 10;
   strcpy(aluno_especial[0].nome, "Ana");
   aluno_especial[0].nota = 10.0;
    
   aluno_especial[1].codigo = 13;
   strcpy(aluno_especial[1].nome, "Bruno");
   aluno_especial[1].nota = 7.5;
    
   aluno_especial[2].codigo = 27;
   strcpy(aluno_especial[2].nome, "Carlos");
   aluno_especial[2].nota = 8.0;
   
   // Opção 1: Passar o array e o índice do aluno a imprimir
   imprimir1(aluno_especial, 2);
   
   // Opção 2: Passar diretamente o aluno específico
   // imprimir2(aluno_especial[2]);
   
   return 0;
}


-------------------------

#include <stdio.h>
#include <string.h>

struct Aluno {
    char nome[50];
    int idade;
    int matricula;
    char curso[30];
};

int main() {
    int i;
    struct Aluno alunos[3];                       // Array de structs para armazenar 3 alunos

    // Cadastrando dados de alunos
    strcpy(alunos[0].nome, "Sergio Silva");
    alunos[0].idade = 16;
    alunos[0].matricula = 1001;
    strcpy(alunos[0].curso, "Matematica");

    strcpy(alunos[1].nome, "Julia Pereira");
    alunos[1].idade = 17;
    alunos[1].matricula = 1002;
    strcpy(alunos[1].curso, "Fisica");

    strcpy(alunos[2].nome, "Joao Souza");
    alunos[2].idade = 18;
    alunos[2].matricula = 1003;
    strcpy(alunos[2].curso, "Quimica");

    printf("=== Dados dos Alunos Cadastrados ===\n");

    for (i = 0; i < 3; i++) {
        printf("Aluno %d:\n", i + 1);
        printf("Nome: %s\n", alunos[i].nome);
        printf("Idade: %d\n", alunos[i].idade);
        printf("Matricula: %d\n", alunos[i].matricula);
        printf("Curso: %s\n\n", alunos[i].curso);
    }

    return 0;
}

--------------------

#include <stdio.h>
#include <stdlib.h>

struct aluno {
   int v_nmat;                       //número da matrícula
   float v_nota[3];                  //notas
   float v_media;                    //media
};

int main() {
   struct aluno Felipe;              //declara uma variável do tipo struct
   
   Felipe.v_nmat = 120;
   Felipe.v_nota[0]=8.5;
   Felipe.v_nota[1]=7.2;
   Felipe.v_nota[2]=5.4;
   Felipe.v_media=(Felipe.v_nota[0]+ Felipe.v_nota[1]+ Felipe.v_nota[2])/3.0;

   printf(“Matricula:%d\n”, Felipe.v_nmat);
   printf(“Media: %2.f\n”, Felipe.v_media);

   system(“pause”);

   return(0);
}   

--------------------

#include <stdio.h>
#include <conio.h>

int main(void) {

   struct ficha_de_aluno {
      char nome[50];
      char disciplina[30];
      float nota_prova1;
      float nota_prova2;
   };
     
   struct ficha_de_aluno aluno;

   printf("\n---------- Cadastro de aluno -----------\n\n\n");     
   printf("Nome do aluno ......: ");

   fflush(stdin);

   fgets(aluno.nome, 40, stdin);   

   printf("Disciplina ......: ");

   fflush(stdin);

   fgets(aluno.disciplina, 40, stdin);  

   printf("Informe a 1a. nota ..: ");  

   scanf("%f", &aluno.nota_prova1);   

   printf("Informe a 2a. nota ..: ");

   scanf("%f", &aluno.nota_prova2);    

   printf("\n\n --------- Lendo os dados da struct ---------\n\n");
   printf("Nome ...........: %s", aluno.nome);
   printf("Disciplina .....: %s", aluno.disciplina);
   printf("Nota da Prova 1 ...: %.2f\n" , aluno.nota_prova1);
   printf("Nota da Prova 2 ...: %.2f\n" , aluno.nota_prova2);    

   getch();

   return(0);
}

>>> ------------- Cadastro de aluno ----------------
>>>
>>> Nome ..................: Alana
>>> Disciplina ............: Inteligência Artificial
>>> Nota da Prova 1 .......: 8
>>> Nota da Prova 2 .......: 9
>>>
>>>
>>> ---------- Lendo os dados da struct ------------
>>>
>>> Nome ..................: Alana
>>> Disciplina ............: Inteligência Artificial
>>> Nota da Prova 1 .......: 8.00
>>> Nota da Prova 2 .......: 9.00

------------

#include <stdio.h>
#include <string.h>

struct Aluno {
    char nome[50];
    int idade;
    int matricula;
    char curso[30];
};

int main(){
   struct Aluno alunos[3];

  //Preenchendo os dados dos alunos
  strcpy(alunos[0].nome, "Carlos Silva");
  alunos[0].idade = 16;
  alunos[0].matricula = 1001;
  strcpy(alunos[0].curso, "Matemática");

  strcpy(alunos[1].nome, "Ana Pereira");
  alunos[1].idade = 11;
  alunos[1].matricula = 1002;
  strcpy(alunos[1].curso, "Física");

  strcpy(alunos[2].nome, "João Souza");
  alunos[2].idade = 18;
  alunos[2].matricula = 1003;
  strcpy(alunos[2].curso, "Química");

  for(int i = 0; i < 3; i++) {
      printf("Aluno %d:\n", i + 1);
      printf(" Nome: %s\n", alunos[i].nome);
      printf(" Idade: %d\n", alunos[i].idade);
      printf(" Matrícula: %d\n", alunos[i].matricula);
      printf(" Curso: %s\n\n", alunos[i].curso);
  }

    return 0;
}

>>> Aluno 1:
>>>  Nome: Carlos Silva
>>>  Idade: 16
>>>  Matrícula: 1001
>>>  Curso: Matemática
>>>
>>> Aluno 2:
>>>  Nome: Ana Pereira
>>>  Idade: 11
>>>  Matrícula: 1002
>>>  Curso: Física
>>> 
>>> Aluno 3:
>>>  Nome: João Souza
>>>  Idade: 18
>>>  Matrícula: 1003
>>>  Curso: Química

---------------------- 

#include <stdio.h>
#include <string.h>

#define NUM_PRODUTOS 5

struct Produto {
    char nome[50];
    int codigo;
    int quantidade;
    float preco;
};

int main() {
    int i;
    struct Produto produtos[NUM_PRODUTOS];

    // Preenchendo os dados dos produtos
    strcpy(produtos[0].nome, "Camiseta");
    produtos[0].codigo = 101;
    produtos[0].quantidade = 50;
    produtos[0].preco = 29.99;

    strcpy(produtos[1].nome, "Calca Jeans");
    produtos[1].codigo = 102;
    produtos[1].quantidade = 30;
    produtos[1].preco = 79.99;

    strcpy(produtos[2].nome, "Tenis Esportivo");
    produtos[2].codigo = 103;
    produtos[2].quantidade = 20;
    produtos[2].preco = 199.99;

    strcpy(produtos[3].nome, "Bolsa de Couro");
    produtos[3].codigo = 104;
    produtos[3].quantidade = 15;
    produtos[3].preco = 149.99;

    strcpy(produtos[4].nome, "Oculos de Sol");
    produtos[4].codigo = 105;
    produtos[4].quantidade = 10;
    produtos[4].preco = 89.99;

    // Exibindo os dados dos produtos
    printf("=== Estoque de Produtos ===\n");
    for (i = 0; i < 5; i++) {
        printf("Produto %d:\n", i + 1);
        printf("  Nome: %s\n", produtos[i].nome);
        printf("  Codigo: %d\n", produtos[i].codigo);
        printf("  Quantidade: %d\n", produtos[i].quantidade);
        printf("  Preco: R$ %.2f\n\n", produtos[i].preco);
    }

    return 0;
}


Será impresso:

=== Estoque de Produtos ===
Produto 1:
  Nome: Camiseta
  Codigo: 101
  Quantidade: 50
  Preco: R$ 29.99

Produto 2:
  Nome: Calca Jeans
  Codigo: 102
  Quantidade: 30
  Preco: R$ 79.99

Produto 3:
  Nome: Tenis Esportivo
  Codigo: 103
  Quantidade: 20
  Preco: R$ 199.99

Produto 4:
  Nome: Bolsa de Couro
  Codigo: 104
  Quantidade: 15
  Preco: R$ 149.99

Produto 5:
  Nome: Oculos de Sol
  Codigo: 105
  Quantidade: 10
  Preco: R$ 89.99


-----------------------------------------------------&&&

FORMA ALTERNATIVA DE STRUCTS

Exemplo 1:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas pessoa[1]) {
	  printf("Nome: %s\n", pessoa[1].nome);
    printf("Idade: %d\n", pessoa[1].idade);
    printf("Sexo: %s\n\n", pessoa[1].sexo);
}

int main() {   
    
    struct Pessoas pessoa[3] = {
        {"Maria", 23, "Feminino"},
        {"Ana", 18, "Feminino"},
        {"Carlos", 35, "Masculino"} 
    };

    Imprimir(pessoa);

    return 0;
};

>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino

------------- 

Exemplo 2:

#include <stdio.h>

struct Pessoas {   
    char nome[50];
    int idade;
    char sexo[15];
};

void Imprimir (struct Pessoas pessoa[]) {
	for(int i = 0; i < 3; i++) {
      printf("Nome: %s\n", pessoa[i].nome);
      printf("Idade: %d\n", pessoa[i].idade);
      printf("Sexo: %s\n\n", pessoa[i].sexo);
    };
}

int main() {   
        
    struct Pessoas pessoa[3] = {
      {"Maria", 23, "Feminino"},
      {"Ana", 18, "Feminino"},
      {"Carlos", 35, "Masculino"} 
    };

    Imprimir(pessoa);

    return 0;
};

>>> Nome: Maria
>>> Idade: 23
>>> Sexo: Feminino
>>>
>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino
>>> 
>>> Nome: Carlos
>>> Idade: 35
>>> Sexo: Masculino

------------------------------------------------------&&&

MEMORIA ESTATICA 

A memória estática é a memória reservada para variáveis ​​antes da execução do programa. A alocação de memória estática também é conhecida como alocação de memória em tempo de compilação.

C aloca memória automaticamente para cada variável quando o programa é compilado.

Por exemplo, se você criar uma matriz de inteiros de 20 alunos, C reservará espaço para 20 elementos, o que normalmente é 80 bytes de memória (20 * 4):

int alunos[20];
printf("%lu", sizeof(alunos));         // 80 bytes

Mas quando as aulas começam, apenas 12 alunos estão presentes. Então você desperdiçou o espaço de 8 elementos não utilizados.

Como você não consiga alterar o tamanho do array, você fica com memória reservada desnecessária.

Observe que o programa ainda será executado e não será danificado de forma alguma. Mas se seu programa contiver muito desse tipo de código, ele poderá ser executado mais lentamente do que seria ideal.

-----------------------------------------------------&&&

MEMORIA DINAMICA 

Memória dinâmica é a memória que é alocada depois que o programa começa a ser executado. A alocação de memória dinâmica também pode ser chamada de alocação de memória de tempo de execução.

Ao contrário da memória estática, você tem controle total sobre quanta memória está sendo usada a qualquer momento. Você pode escrever código para determinar quanta memória precisa e alocá-la.

A memória dinâmica não pertence a uma variável, ela só pode ser acessada com ponteiros.

Para alocar memória dinâmica, você pode usar as funções malloc() ou calloc(). É necessário incluir o cabeçalho <stdlib.h> para usá-las. As funções malloc() e calloc() alocam alguma memória e retornam um ponteiro para seu endereço.

Sintaxe:
int *ponteiro1 = malloc(tamanho);
int *ponteiro2 = calloc(quantidade, tamanho);

A função malloc() tem 1 parâmetro, tamanho, que especifica quanta memória alocar, medida em bytes.

A função calloc() tem 2 parâmetros:

quantidade - Especifica a quantidade de itens a alocar
tamanho - Especifica o tamanho de cada item medido em bytes

Os dados na memória alocada por malloc() são imprevisíveis. Para evitar valores inesperados, certifique-se de escrever algo na memória antes de lê-la.

Ao contrário de malloc(), a função calloc() escreve zeros em toda a memória alocada. No entanto, isso torna calloc() um pouco menos eficiente.

A melhor maneira de alocar a quantidade certa de memória para um tipo de dado é usar o operador sizeof:

int *ptr1, *ptr2;
ptr1 = malloc(tamanho);
ptr2 = calloc(quantidade, tamanho);


-----------------------------------------------------&&&

ALOCANDO MEMORIA DINAMICA USANDO MALLOC 
ponteiro = malloc(tamanho);

Sintaxe: 

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *ptr
    ptr = malloc(sizeof(*ptr));
    ...
    return 0;
};

-----------

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    alunos = malloc(sizeof(*alunos));

    int numeroAlunos = 12;

    printf("Total alocado: %d bytes", numeroAlunos * sizeof(*alunos));          

    return 0;
}

>>> Total alocado: 48 bytes

O resultado deu 48 bytes pois:
-Uma variavel int ocupa 4 bytes
-A variavel numeroAlunos possui como valor 12

numeroAlunos * sizeof(*alunos) = 12 * 4

-----------

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    alunos = malloc(sizeof(*alunos));

    int numeroAlunos = 10;

    printf("Total alocado: %d bytes", numeroAlunos * sizeof(*alunos));   

    return 0;
}

>>> Total alocado: 40 bytes

------------

É possível especificar o tamanho alocado em malloc usando o tipo da variavel:

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    alunos = malloc(sizeof(int));        // Especificou que o tamanho alocado será de um int

    int numeroAlunos = 12;

    printf("Total alocado: %d bytes", numeroAlunos * sizeof(int));          

    return 0;
}

-------------

Especificando um tamanho de alocação de memoria:

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    alunos = malloc(3 * sizeof(int));        // Especificou que o tamanho alocado será 3 vezes de um int

    int numeroAlunos = 12;

    printf("Total alocado: %d bytes", numeroAlunos * sizeof(int));          

    return 0;
}

-------------

É possível pegar o tamanho de memoria que será alocado através de um prompt que o usuario digitar:
(utilizando um terminal ou aplicativo)

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    int tamanho;

    printf("Digite o tamanho: ");
    scanf("%d", &tamanho);

    alunos = malloc(tamanho * sizeof(int));             // Especificou que o tamanho alocado será 3 vezes de um int

    int numeroAlunos = 12;

    printf("Total alocado: %d bytes", numeroAlunos * sizeof(int));          

    return 0;
}

-------------

#include <stdio.h>
#include <stdlib.h>

int main() {
   int *ponteiro;
   ponteiro = (int*) malloc(5 * sizeof(int));        //Aloca memória para 5 inteiros

   if (ponteiro != NULL) {                           //Verifica se a alocação foi bem-sucedida
      int i;
      for (i = 0; i < 5; i++) {
         ponteiro[i] = i + 1;                        //Inicializa os valores manualmente
      }

      for (i = 0; i < 5; i++) {
         printf("%d ", ponteiro[i]);
      }

      free(ponteiro);                                // Libera a memória
   } else {
      printf("Erro na alocação da memória.\n"); 
   }

   return 0;
}

>>> 1 2 3 4 5

-----------------------------------------------------&&&

ALOCANDO MEMORIA DINAMICA USANDO CALLOC
ponteiro = calloc(quantidade, tamanho);

Sintaxe:

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *ptr;
    ptr = calloc(quantidade, sizeof(*ptr));
    ...
    return 0;
};

------------

OBS: Calloc inicia as variaveis com o valor zero.

#include <stdio.h>
#include <stdlib.h>

int main() {
   int *ponteiro;
   ponteiro = (int*) calloc(5, sizeof(int));              //Aloca memória para 5 inteiros, inicializados em zero

   if (ponteiro != NULL) {                                //Verifica se a alocação foi bem-sucedida
      int i;
      for (i = 0; i < 5; i++) {
         printf("%d ", ponteiro[i]);                      // Exibe os valores iniciais (todos devem ser zero)
   }

      free(ponteiro);                                     // Libera a memória
   } else {
      printf("Erro na alocação da memória.\n"); 
   }

   return 0;
}

>>> 0 0 0 0 0

------------

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *alunos;
    alunos = calloc(numeroAlunos, sizeof(*alunos));

    int numeroAlunos = 12;

    printf("%d", numeroAlunos * sizeof(*alunos)); 

    return 0;
}

>>> 48 (bytes)

O resultado deu 48 bytes pois:
-Uma variavel int ocupa 4 bytes
-A variavel numeroAlunos possui como valor 12

numeroAlunos * sizeof(*alunos) = 12 * 4

-----------------------------------------------------&&&

ACESSAR A MEMORIA DINAMICA

ptr[0] = 12;

é igual A

*ptr = 12;

-----

#include <stdio.h>

int main() {

    int numero = 10;     
    int *ponteiro = &numero;        

    printf("%d\n", numero);
	printf("%d\n", *ponteiro);
    printf("%d\n", ponteiro[0]);
    
    printf("%p\n", ponteiro);

    return 0;
};

>>> 10
>>> 10
>>> 10
>>> 0x7ffe3940f604

---------

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *ptr;
    ptr = calloc(4, sizeof(*ptr));

    *ptr = 2;          //Ou   ptr[0] = 2;
    ptr[1] = 4;
    ptr[2] = 6;

    printf("%d\n", *ptr);
    printf("%d\n", ptr[0]);
    printf("%d\n", ptr[1]);
    printf("%d\n", ptr[2]);
    printf("%d\n", ptr[3]);

    return 0;
};

>>> 2      (*ptr é igual a ptr[0])
>>> 2      (*ptr é igual a ptr[0])
>>> 4      (valor de ptr[1])
>>> 6      (valor de ptr[2])
>>> 0      (valor de ptr[3]. A função calloc inicia uma variavel com zero)


-----------------------------------------------------&&&

REALOCAR MEMORIA DINAMICA USANDO realloc()

Sintaxe:

realloc(tamanhooriginal, tamanhonovo)

--------

#include <stdio.h>
#include <stdlib.h>

int main() {

  int *ptr1, *ptr2, tamanho;

  tamanho = 4 * sizeof(*ptr1);
  ptr1 = malloc(tamanho);

  printf("%d bytes alocados para o endereço %p \n", tamanho, ptr1);

  tamanho = 6 * sizeof(*ptr1);
  ptr2 = realloc(ptr1, tamanho);

  printf("%d bytes realocados para o endereço %p \n", tamanho, ptr2);

  return 0;
}

>>> 16 bytes alocados para o endereço 0x5652aeaa62a0 
>>> 24 bytes realocados para o endereço 0x5652aeaa62a0 

-----------------------------------------------------&&&

CONTROLE E CHECAGEM DE ALOCAÇÃO DE MEMORIA

Sintaxe:

if (ponteiro == NULL) {
    ....
} else {
    ....
}

-----------

#include <stdio.h>
#include <stdlib.h>

int main() {

    int *ptr;
    ptr = malloc(4);
    int tamanho = 3 * sizeof(*ptr);

    if (ptr == NULL) {
        printf("Não conseguiu alocar a memoria.");
    } 
    else {
        printf("%d bytes foram alocados no endereço %p \n", tamanho, ptr);
    }

    return 0;
}

>>> 12 bytes foram alocados no endereço 0x55f83a6d62a0 


-----------------------------------------------------&&&

LIBERAÇÃO DE MEMORIA USANDO free()

Sintaxe:

free(variavel);

------------

#include <stdio.h>
#include <stdlib.h>

int main() {

  int *ptr, tamanho;

  tamanho = 5 * sizeof(*ptr);
  ptr = malloc(tamanho);

  printf("%d bytes alocados para o endereço %p.\n", tamanho, ptr);
  
  free(ptr);

  ptr = NULL;
  
  tamanho = sizeof(*ptr);

  printf("%d bytes alocados para o endereço %p após liberar.\n", tamanho, ptr);

  return 0;
}

-------------

É considerada uma boa prática definir um ponteiro como NULL após liberar memória para que você não possa continuar a usá-lo acidentalmente.

#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr;
    ptr = malloc(sizeof(*ptr)); 

    if (ptr == NULL) {
        printf("Não foi possível alocar memória.");
        return 1;               // Sai do programa com uma mensagem de erro
    } 
    else {
        printf("%d bytes foram alocados para a memoria ao iniciar.\n", sizeof(*ptr));
    }

    *ptr = 20;

    printf("Valor no número inteiro: %d\n", *ptr);
    printf("%d bytes foram ocupados no total.\n", *ptr * sizeof(*ptr));


    free(ptr);

    ptr = NULL; 
    
    return 0;
}

>>> 4 bytes foram alocados para a memoria ao iniciar.
>>> Valor no número inteiro: 20
>>> 80 bytes foram ocupados no total.

---------------- &&&

É possível também adicionar uma checagem para ver se a atribuição do valor NULL ao ponteiro foi feita corretamente

#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr;
    ptr = malloc(sizeof(*ptr)); 

    if (ptr == NULL) {
        printf("Não foi possível alocar memória.");
        return 1;              
    } 
    else {
        printf("%d bytes foram alocados para a memoria ao iniciar.\n", sizeof(*ptr));
    }

    *ptr = 20;

    printf("Valor no número inteiro: %d\n", *ptr);
    printf("%d bytes foram ocupados no total.\n", *ptr * sizeof(*ptr));


    free(ptr);

    ptr = NULL; 

    if (ptr == NULL) {
      printf("Memoria foi liberada corretamente e o ponteiro está invalido.\n");
    }
    
    return 0;
}

>>> 4 bytes foram alocados para a memoria ao iniciar.
>>> Valor no número inteiro: 20
>>> 80 bytes foram ocupados no total.


Versão alternativa da checagem:

    if (ptr != NULL) {
      printf("Memoria não foi liberada corretamente e o ponteiro não está invalido.\n");
    }


----------------

AS 2 FORMAS DE CHECAGEM DE ALOCAÇÃO DE MEMORIA

Sintaxe Forma 1:

#include <stdio.h>
#include <stdlib.h>

struct Estrutura {
    tipo variavel1;
    tipo variavel2;
    tipo variavel3;
    ....
};

int main(){

    struct Estrutura *ponteiro = (struct Estrutura *) malloc(sizeof(struct Estrutura));     

    if (ponteiro == NULL) {                            //Se a alocação de memória não for bem sucedida
        printf("Alocação de memória falhou.\n");
        return 1;                                    
    }

    intrução 1;
    intrução 2;
    intrução 3;

    ....

    return 0;
}

---

Sintaxe Forma 2:

#include <stdio.h>
#include <stdlib.h>

struct Estrutura {
    tipo variavel1;
    tipo variavel2;
    tipo variavel3;
    ....
};

int main(){

    struct Estrutura *ponteiro = (struct Estrutura *) malloc(sizeof(struct Estrutura));     

    if (ponteiro != NULL) {                          //Se a alocação de memória for bem sucedida
        intrução 1;
        intrução 2;
        intrução 3;
        ....                         
    } else {                                         //Opcional
        printf("Alocação de memória falhou.\n");
        return 1;     
    }

    return 0;
}


---------
Exemplos:

FORMA 1 (com acesso direto - ponto):

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
};

//void Imprimir (struct Pessoas ptr) {                              //Opcional
//	printf("Nome: %s", ptr.nome);
//}

int main() {   
    
    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));     //com um array de 3 elementos

    if (ptr == NULL) {
        printf("Alocação de memória falhou.\n");
        return 1;
    }

    strcpy(ptr[0].nome, "Maria"); 
    strcpy(ptr[1].nome, "Ana"); 
    strcpy(ptr[2].nome, "Carlos"); 
    
    printf("Nome: %s", ptr[1].nome);                                // Ou uma chamada de função: Imprimir(ptr[1]);
    
    free(ptr);

    ptr = NULL;

    return 0;
};

>>> Nome: Ana

----------------


FORMA 2 (com acesso direto - ponto):

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoas {   
    char nome[50];
};

//void Imprimir (struct Pessoas ptr) {                                   //Opcional
//	printf("Nome: %s", ptr.nome);
//}

int main() {   
    
    struct Pessoas *ptr = (struct Pessoas *) malloc(3 * sizeof(struct Pessoas));     //com um array de 3 elementos

    if (ptr != NULL) {

        strcpy(ptr[0].nome, "Maria"); 
        strcpy(ptr[1].nome, "Ana"); 
        strcpy(ptr[2].nome, "Carlos"); 
        
        printf("Nome: %s", ptr[1].nome);                                // Ou uma chamada de função: Imprimir(ptr[1]);
        
        free(ptr);

        ptr = NULL;

    }

    return 0;
};

>>> Nome: Ana

------------

FORMA 1 (com acesso indireto - seta)

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoa {
   char nome[50];
};

int main(){

  struct Pessoa *ptr = (struct Pessoa *) malloc(sizeof(struct Pessoa));        //Sem nenhum array

  if (ptr == NULL) {
      printf("Alocação de memória falhou.\n");
      return 1;
  }

  strcpy(ptr->nome, "Ana");
    
  printf("Nome: %s\n", ptr->nome);                                            //Ou uma chamada de função

  free(ptr); 

  ptr = NULL;
  
  return 0;
}

>>> Nome: Ana

----------

FORMA 2 (com acesso indireto - seta):

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Pessoa {
   char nome[50];
};

int main(){

  struct Pessoa *ptr = (struct Pessoa *) malloc(sizeof(struct Pessoa));        //Sem nenhum array

  if (ptr != NULL) {

    strcpy(ptr->nome, "Ana Costa");
    
    printf("Nome: %s\n", ptr->nome);                                           //Ou uma chamada de função

    free(ptr); 

    ptr = NULL;
  }
  
  return 0;
}

>>> Nome: Ana


-----------------------------------------------------&&&

VAZAMENTO DE MEMORIA (Memory Leaks)

Exemplo 1:
O valor do ponteiro é sobreescrito

int x = 5;
int *ptr;
ptr = calloc(2, sizeof(*ptr));
ptr = &x;

------

Exemplo 2:
O ponteiro existe apenas dentro de uma função

void myFunction() {
  int *ptr;
  ptr = malloc(sizeof(*ptr));
}

int main() {
  myFunction();
  printf("The function has ended");
  return 0;
}

------

Exemplo 3:
O ponteiro fica perdido quando a realocação falha

int* ptr;
ptr = malloc(sizeof(*ptr));
ptr = realloc(ptr, 2*sizeof(*ptr));


-----------------------------------------------------&&&

ENUMERAÇÃO / ENUM

Uma enumeração é um tipo especial que representa um grupo de constantes (valores imutáveis).
Enums são usados ​​para dar nomes a constantes, o que torna o código mais fácil de ler e manter.
Use enums quando tiver valores que você sabe que não vão mudar.

Atenção!
Enum só funciona com variaveis com valores int !!!!

#include <stdio.h>

enum Nivel {                              // Para criar um enum e seus itens
  BAIXO,                                  // itens em maiusculas pois são constantes (não é obrigatório)
  MEDIO,
  ALTO
};

int main() {

  enum Nivel variavel = MEDIO;           // Para criar uma variavel enum

  printf("%d", variavel);

  return 0;
}

Por padrão, o primeiro item (BAIXO) tem o valor 0, o segundo (MEDIO) tem o valor 1, o terceiro (ALTO) tem o valor 2, etc.

----------

Para atribuir ou alterar os valores das constantes

enum Constantes {
  CONSTANTE1 = 25,
  CONSTANTE2 = 50,
  CONSTANTE3 = 75
};

Observe que se você atribuir um valor a um item específico, os próximos itens atualizarão seus números de acordo (será somado +1 na proxima variavel constante)

enum Constantes {
  CONSTANTE1 = 15,              // valor é 15
  CONSTANTE2,                   // valor será 16 (15 + 1)
  CONSTANTE3                    // valor será 17 (16 + 1)
};

----------

Enum usando switch

#include <stdio.h>

enum Podio {
  PRIMEIRO = 1,
  SEGUNDO,
  TERCEIRO
};

int main() {
  enum Podio posicao = 2;

  switch (posicao) {
    case 1:
      printf("Primeiro lugar");
      break;
    case 2:
      printf("Segundo lugar");
      break;
    case 3:
      printf("Terceiro lugar");
      break;
    default:
      printf("Não chegou ao pódio.");
  }
  return 0;
}

OBS: Como enum só funciona com variaveis int, não é possível utilizar outros tipos de condicionais como if/else if, apenas switch.

-----------------------------------------------------&&&

TYPEDEF()

O comando typedef permite criar um novo nome para outro tipo de dados. 

Sintaxe:

#include <stdio.h>

typedef struct {
  tipo membro1;
  tipo membro2;
  tipo membro3;
} Estrutura;

int main(){
  ...
}


Ao invés do normal que é:

#include <stdio.h>

struct Estrutura{
  tipo membro1;
  tipo membro2;
  tipo membro3;
};

int main(){
  ...
}

-----------

Criando diversas estruturas/campos:

#include <stdio.h>

typedef struct {
  tipo membro1;
  tipo membro2;
  tipo membro3;
} Estrutura1 Estrutura2 Estrutura3;

int main(){
  ...
}

----------

Exemplo:

#include <stdio.h>

typedef struct {
  char nome[50];
  int idade;
  char sexo[15];
} Pessoa;

int main(){

  Pessoa pessoa1 = {"Maria", 23, "Feminino"};
  
  printf("Nome: %s \n", pessoa1.nome);
  printf("Idade: %d \n", pessoa1.idade);
  printf("Sexo: %s \n", pessoa1.sexo);
  
  return 0;
}

>>> Nome: Maria 
>>> Idade: 23 
>>> Sexo: Feminino 



Versão alternativa usando ponteiro:

#include <stdio.h>

typedef struct {
  char nome[50];
  int idade;
  char sexo[15];
} Pessoa;

int main(){

  Pessoa pessoa1 = {"Maria", 23, "Feminino"};
  Pessoa *ptr = &pessoa1;
  
  printf("Nome: %s \n", ptr->nome);             //Ou  printf("Nome: %s \n", (*ptr).nome);
  printf("Idade: %d \n", ptr->idade);           //Ou  printf("Idade: %d \n", (*ptr).idade);
  printf("Sexo: %s \n", ptr->sexo);             //Ou  printf("Sexo: %s \n", (*ptr).sexo);
  
  return 0;
}

>>> Nome: Maria 
>>> Idade: 23 
>>> Sexo: Feminino 

----------

#include <stdio.h>

typedef struct {
  char nome[50];
  int idade;
  char sexo[15];
} Aluno, Professor, Funcionario;

int main(){

  Aluno aluno1 = {"Maria", 15, "Feminino"};
  Aluno *ptrAluno = &aluno1;
  
  Professor professor1 = {"Ana", 42, "Feminino"};
  Professor *ptrProfessor = &professor1;
  
  Funcionario funcionario1 = {"Carlos", 47, "Masculino"}; 
  Funcionario *ptrFuncionario = &funcionario1; 
  
  printf("Nome: %s \n", ptrProfessor->nome);
  printf("Idade: %d \n", ptrProfessor->idade);
  printf("Sexo: %s \n", ptrProfessor->sexo);
  
  return 0;
}

>>> Nome: Ana 
>>> Idade: 42 
>>> Sexo: Feminino 

-----------

#include <stdio.h>

typedef struct {
  char nome[50];
  int idade;
  char sexo[15];
} Aluno;

int main(){

  Aluno alunos[3] = {
  	{"Maria", 15, "Feminino"},
    {"Ana", 17, "Feminino"},
    {"Carlos", 16, "Masculino"},
  };
  
  printf("Nome: %s \n", alunos[1].nome);
  printf("Idade: %d \n", alunos[1].idade);
  printf("Sexo: %s \n", alunos[1].sexo);
  
  return 0;
}

>>> Nome: Ana 
>>> Idade: 17 
>>> Sexo: Feminino 

-----------

Caso esteja trabalhando com alocação de memória (malloc ou calloc),  não é necessário especificar a palavra struct antes da estrutura.

typedef struct {
  tipo membro1;
  tipo membro2;
  tipo membro3;
} Estrutura;

int main(){
  Estrutura *campo1 = (Estrutura *) malloc(3 * sizeof(Estrutura)); 
  ...
}


Ao invés do normal que é:

struct Estrutura{
  tipo membro1;
  tipo membro2;
  tipo membro3;
};

int main(){
  struct Estrutura *campo1 = (struct Estrutura *) malloc(3 * sizeof(struct Estrutura)); 
  ...
}


--------

Exemplo:

#include <stdio.h>
#include <string.h>

typedef struct {   
    char nome[50];
    int idade;
    char sexo[15];
} Pessoas;

int main() {

    Pessoas *pessoa = (Pessoas *) malloc(3 * sizeof(Pessoas));     

    strcpy(pessoa[0].nome, "Maria"); 
    pessoa[0].idade = 23; 
    strcpy(pessoa[0].sexo, "Feminino");  
    
    strcpy(pessoa[1].nome, "Ana"); 
    pessoa[1].idade = 18; 
    strcpy(pessoa[1].sexo, "Feminino"); 
    
    strcpy(pessoa[2].nome, "Carlos"); 
    pessoa[2].idade = 35; 
    strcpy(pessoa[2].sexo, "Masculino");

   	printf("Nome: %s\n", pessoa[1].nome);
    printf("Idade: %d\n", pessoa[1].idade);
    printf("Sexo: %s\n\n", pessoa[1].sexo);

    return 0;
};


>>> Nome: Ana
>>> Idade: 18
>>> Sexo: Feminino

-----------------------------------------------------&&&

STRUCTS ANINHADAS (STRUCTS DENTRO DE STRUCTS)

FORMA 1:

#include <stdio.h>

struct Estrutura1 {
   char membro1[20];
   
   struct Estrutura2 {
      char membro2[20]; 
   };
};

int main(){

  struct Estrutura2 campo2[10] = {"Texto"};
  
  printf("%s", campo2->membro2);

  return 0;
}

---------

#include <stdio.h>

struct Pessoa {
   char nome[20];
   struct Aluno {
      int matricula;
   };
};

int main(){

  struct Pessoa pessoas[3] = {"Maria", "Ana", "Carlos"};
  
  struct Aluno alunos[3] = {1000, 1001, 1002};
  
  printf("Nome do aluno: %s \n", pessoas[0].nome);
  
  printf("Matrícula do aluno: %d \n", alunos[0].matricula);

  return 0;
};


>>> Nome do aluno: Maria 
>>> Matrícula do aluno: 1000 


Versão alternativa:

#include <stdio.h>
#include <string.h>

struct Pessoa {
   char nome[20];
   struct Aluno {
      int matricula;
   };
};

int main(){

  struct Pessoa pessoas[3]; 
  struct Aluno alunos[3]; 
  
  strcpy(pessoas[0].nome, "Maria");
  alunos[0].matricula = 1000;
  
  strcpy(pessoas[1].nome, "Ana");
  alunos[1].matricula = 1001;
  
  strcpy(pessoas[2].nome, "Carlos");
  alunos[2].matricula = 1002;
  
  printf("Nome do aluno: %s \n", pessoas[0].nome);
  printf("Matrícula do aluno: %d \n", alunos[0].matricula);

  return 0;
};

>>> Nome do aluno: Maria 
>>> Matrícula do aluno: 1000 

----------

#include <stdio.h>

struct Pessoa {
   char nome[20];
   int idade;
   struct Aluno {
      int matricula;
      char classe[15];
      float nota;
   };
};

int main(){

  struct Pessoa pessoas[3] = {
     {"Maria", 16},
     {"Ana", 14},
     {"Carlos", 15}
  };
  
  struct Aluno alunos[3] = {
     {1000, "Matemática", 9.5},
     {1001, "Matemática", 7.0},
     {1002, "Matemática", 8.5}
  };
  
  printf("Nome do aluno: %s \n", pessoas[0].nome);
  printf("Idade do aluno: %d anos \n", pessoas[0].idade);
  
  printf("Matricula do aluno: %d \n\n", alunos[0].matricula);
  printf("Classe: %s \n", alunos[0].classe);
  printf("Nota: %.1f \n", alunos[0].nota);

  return 0;
};

>>> Nome do aluno: Maria 
>>> Idade do aluno: 16 anos
>>> Matricula do aluno: 1000 
>>>
>>> Classe: Matemática 
>>> Nota: 9.5 

-----------------------

FORMA 2:

#include <stdio.h>

struct Estrutura1 {
   int membro1;
};

struct Estrutura2 {
   char membro2[20];
   struct Estrutura1 campo1;                          // campo1 está dentro de... (ou abre) Estrutura1
};


int main(){

  struct Estrutura2 campo2;
  
  campo2.campo1.membro1 = 10;                         //campo2 acessa campo1 (que está em Estrutura1) e depois acessa membro1
  
  printf("%d \n", campo2.campo1.membro1);

  return 0;
}

>>> 10

----------

#include <stdio.h>
#include <string.h>

struct Estrutura1 {
   int membro1;
};

struct Estrutura2 {
   char membro2[20];
   struct Estrutura1 campo1;
};


int main(){

  struct Estrutura2 campo2;
  
  campo2.campo1.membro1 = 10;
  strcpy(campo2.membro2, "Texto");
  
  printf("%d \n", campo2.campo1.membro1);
  printf("%s \n", campo2.membro2);

  return 0;
}

>>> 10
>>> Texto

-------

#include <stdio.h>

struct Estrutura1 {
   int membro1;
};

struct Estrutura2 {
   int membro2;
   struct Estrutura1 campo1;
};


int main(){

  struct Estrutura2 campo2[3];
  
  campo2[0].campo1.membro1 = 10;
  campo2[1].campo1.membro1 = 50;
  campo2[2].campo1.membro1 = 75;
  
  printf("%d", campo2[0].campo1.membro1);

  return 0;
}

>>> 10

--------

#include <stdio.h>
#include <string.h>

struct Estrutura1 {
   char membro1[20];
};

struct Estrutura2 {
   char membro2[20];
   struct Estrutura1 campo1;
};


int main(){

  struct Estrutura2 campo2[3];
  
  strcpy(campo2[0].campo1.membro1, "Texto 1");
  strcpy(campo2[1].campo1.membro1, "Texto 2");
  strcpy(campo2[2].campo1.membro1, "Texto 3");
  
  printf("%s", campo2[0].campo1.membro1);

  return 0;
}

>>> Texto 1

-----------------

SEM ARRAY:

#include <stdio.h>

struct Pessoa {
   int idade;
};

struct Aluno {
   int matricula;
   struct Pessoa pessoas;
};


int main(){

  struct Aluno alunos;
  
  alunos.pessoas.idade = 17;
  
  printf("Idade: %d anos", alunos.pessoas.idade);

  return 0;
}

>>> Idade: 17 anos

---

COM ARRAY:

#include <stdio.h>

struct Pessoa {
   int idade;
};

struct Aluno {
   int matricula;
   struct Pessoa pessoas;
};


int main(){

  struct Aluno alunos[3];
  
  alunos[0].pessoas.idade = 17;
  alunos[1].pessoas.idade = 15;
  alunos[2].pessoas.idade = 13;
  
  printf("Idade: %d anos", alunos[0].pessoas.idade);

  return 0;
}

>>> Idade: 17 anos

------------------

Comparativo:

Versão sem structs aninhadas:

#include <stdio.h>

struct Classe {
   char materia[20];
};

struct Professor {
   char nome[20];
};

int main(){
  
  struct Professor professores[3] = {"Janete", "Sérgio", "Carlos"};
  struct Classe classes[3] = {"Matemática", "Geografia", "Português"};
  
  printf("Nome: %s \n", professores[1].nome);
  printf("Matéria: %s \n", classes[1].materia);

  return 0;
}

>>> Nome: Sérgio 
>>> Matéria: Geografia 

-----

Versão com structs aninhadas:

#include <stdio.h>
#include <string.h>

struct Professor {
   char nome[20];
};

struct Classe {
   char materia[20];
   struct Professor professores;
};

int main(){
  
  struct Classe classes[3];
  
  strcpy(classes[0].professores.nome, "Janete");
  strcpy(classes[0].materia, "Matemática");
  
  strcpy(classes[1].professores.nome, "Sérgio");
  strcpy(classes[1].materia, "Geografia");
  
  strcpy(classes[2].professores.nome, "Carlos");
  strcpy(classes[2].materia, "Português");
  
  printf("Nome: %s \n", classes[1].professores.nome);
  printf("Matéria: %s \n", classes[1].materia);

  return 0;
}

>>> Nome: Sérgio 
>>> Matéria: Geografia 

---------------------

Outros exemplos:

#include <stdio.h>
#include <string.h>

struct Cargo {
    char materia[30];
    int cargaHoraria;
};
 
struct Professor {
    char nome[30];
    float salario;
    struct Cargo profCargo;
};
 
int main() {
	struct Professor professor1;
    
    strcpy(professor1.nome, "Carlos");
    professor1.salario = 1500.00;
    strcpy(professor1.profCargo.materia, "Português");
    professor1.profCargo.cargaHoraria = 40;
    
    
    printf("Nome: %s \n", professor1.nome);
    printf("Salário: R$ %.2f \n", professor1.salario);
    printf("Matéria: %s \n", professor1.profCargo.materia);
    printf("Carga Horária: %d horas\n", professor1.profCargo.cargaHoraria);

	return 0;
}

>>> Nome: Carlos 
>>> Salário: R$ 1500.00 
>>> Matéria: Português 
>>> Carga Horária: 40 horas

---------

#include <stdio.h>
#include <string.h>

struct Aluno {
   char nome[20];
   int idade;
   int matricula;
};

struct Professor {
   char nome[20];
   char materia[20];
};

struct Turma {
   int classe; 
   int ano;
   char turno[10];
   struct Aluno alunos;
   struct Professor professores;
};

int main(){

  struct Turma turmas[50];
  
  turmas[0].classe = 402;
  turmas[0].ano = 2025;
  strcpy(turmas[0].turno, "Manhã");
  
  strcpy(turmas[0].alunos.nome, "Maria");
  turmas[0].alunos.idade = 15;
  turmas[0].alunos.matricula = 2025432;
  
  strcpy(turmas[0].professores.nome, "Carlos");
  strcpy(turmas[0].professores.materia, "Português");
    
  printf("Classe: %d \n", turmas[0].classe);
  printf("Ano: %d \n", turmas[0].ano);
  printf("Turno: %s \n\n", turmas[0].turno);
  
  printf("Nome do aluno: %s \n", turmas[0].alunos.nome);
  printf("Idade: %d \n", turmas[0].alunos.idade);
  printf("Matrícula: %d \n\n", turmas[0].alunos.matricula);
  
  printf("Nome do Professor: %s \n", turmas[0].professores.nome);
  printf("Matéria: %s \n\n", turmas[0].professores.materia);

  return 0;
}

---------------------

Compartilhando membros entre 2 ou mais structs aninhadas:

#include <stdio.h>
#include <string.h>

struct Endereco {
    char rua[50];
    int numero;
};

struct Pessoa {
    char nome[50];
    struct Endereco casa;
    struct Endereco trabalho;
};

int main(){

  struct Pessoa pessoas[1];	

  strcpy(pessoas[0].casa.rua, "Rua das Rosas");
  pessoas[0].casa.numero = 11;
  
  strcpy(pessoas[0].trabalho.rua, "Rua das Quitandas");
  pessoas[0].trabalho.numero = 203;
  
  printf("Endereço da casa: %s, %d \n", pessoas[0].casa.rua, pessoas[0].casa.numero);
  
  printf("Endereço do trabalho: %s, %d \n", pessoas[0].trabalho.rua, pessoas[0].trabalho.numero);

  return 0;
}

>>> Endereço da casa: Rua das Rosas, 11 
>>> Endereço do trabalho: Rua das Quitandas, 203 

----

#include <stdio.h>
#include <string.h>

struct Endereco {
    char rua[50];
    char cidade[30];
    char estado[3];
    char cep[10];
};

struct Aluno {
    char nome[50];
    int matricula;
    int idade;
    struct Endereco casa;
    struct Endereco escola;
};

int main(){

  struct Aluno alunos[1];	
  
  strcpy(alunos[0].nome, "Bruno Campos");
  alunos[0].matricula = 202509655;
  alunos[0].idade = 15;

  strcpy(alunos[0].casa.rua, "Rua das Rosas");
  strcpy(alunos[0].casa.cidade, "Rio de Janeiro");
  strcpy(alunos[0].casa.estado, "RJ");
  strcpy(alunos[0].casa.cep, "22560-001");
  
  strcpy(alunos[0].escola.rua, "Rua das Quitandas");
  strcpy(alunos[0].escola.cidade, "Rio de Janeiro");
  strcpy(alunos[0].escola.estado, "RJ");
  strcpy(alunos[0].escola.cep, "22560-751");
  
  printf("Nome: %s \n", alunos[0].nome);
  printf("Matrícula: %d \n", alunos[0].matricula);
  printf("Idade: %d anos \n", alunos[0].idade);
  
  printf("Endereço da casa: \n");
  printf("   Rua: %s \n", alunos[0].casa.rua);
  printf("   Cidade: %s \n", alunos[0].casa.cidade);
  printf("   Estado: %s \n", alunos[0].casa.estado);
  printf("   CEP: %s \n", alunos[0].casa.cep);
  
  printf("Endereço da escola: \n");
  printf("   Rua: %s \n", alunos[0].escola.rua);
  printf("   Cidade: %s \n", alunos[0].escola.cidade);
  printf("   Estado: %s \n", alunos[0].escola.estado);
  printf("   CEP: %s \n", alunos[0].escola.cep);

  return 0;
}

>>> Nome: Bruno Campos 
>>> Matrícula: 202509655 
>>> Idade: 15 anos 
>>> Endereço da casa: 
>>>    Rua: Rua das Rosas 
>>>    Cidade: Rio de Janeiro 
>>>    Estado: RJ 
>>>    CEP: 22560-001 
>>> Endereço da escola: 
>>>    Rua: Rua das Quitandas 
>>>    Cidade: Rio de Janeiro 
>>>    Estado: RJ 
>>>    CEP: 22560-751 

--------------

#include <stdio.h>
#include <string.h> 

struct Disciplina {
    char nome[30];
    char professor[50];
    int cargaHoraria;
};

struct Aluno {
    char nome[50];
    int idade;
    int matricula;
    struct Disciplina disciplinas[3];
}; 

void cadastrarDisciplina(struct Disciplina *disciplina, const char *nome, const char *professor, int cargaHoraria) {
    strcpy(disciplina->nome, nome);
    strcpy(disciplina->professor, professor);
    disciplina->cargaHoraria = cargaHoraria;
}

void cadastrarAluno(struct Aluno *aluno, const char *nome, int idade, int matricula) {
    strcpy(aluno->nome, nome);
    aluno->idade = idade;
    aluno->matricula = matricula;

    cadastrarDisciplina(&aluno->disciplinas[0], "Matematica", "Prof. Joao Silva", 60);
    cadastrarDisciplina(&aluno->disciplinas[1], "Historia", "Prof. Julia Costa", 45);
    cadastrarDisciplina(&aluno->disciplinas[2], "Quimica", "Prof. Carlos Souza", 50);
}

void exibirAluno(struct Aluno *aluno) {
	int i;
	
    printf("Nome do Aluno: %s\n", aluno->nome);
    printf("Idade: %d\n", aluno->idade);
    printf("Matricula: %d\n\n", aluno->matricula);

    printf("Disciplinas:\n\n");
    for (i = 0; i < 3; i++) {
        printf("Disciplina %d\n", i + 1);
        printf("Nome: %s\n", aluno->disciplinas[i].nome);
        printf("Professor: %s\n", aluno->disciplinas[i].professor);
        printf("Carga Horaria: %d horas\n\n", aluno->disciplinas[i].cargaHoraria);
    }
}

int main() {
    struct Aluno aluno1;
    cadastrarAluno(&aluno1, "Alana Lima", 20, 1234);
    exibirAluno(&aluno1);
    return 0;
}


>>> Nome do Aluno: Alana Lima
>>> Idade: 20
>>> Matricula: 1234
>>> 
>>> Disciplinas:
>>> 
>>> Disciplina 1
>>> Nome: Matematica
>>> Professor: Prof. Joao Silva
>>> Carga Horaria: 60 horas
>>> 
>>> Disciplina 2
>>> Nome: Historia
>>> Professor: Prof. Julia Costa
>>> Carga Horaria: 45 horas
>>> 
>>> Disciplina 3
>>> Nome: Quimica
>>> Professor: Prof. Carlos Souza
>>> Carga Horaria: 50 horas


------------------------------

TYPEDEF COM STRUCTS ANINHADAS

Caso esteja trabalhando com struct aninhadas, não há uma limitação para o número de níveis na declaração aninhada. Contudo, não seria prático incluir muitos níveis, pois isso irá complicar o entendimento para manutenção do código-fonte.

Sintaxe:

#include <stdio.h>

typedef struct {
	tipo membro1;
	tipo membro2;
	...
	struct{
		tipo membro_interno1;
		tipo membro_interno2;
		....
	}
} Estrutura;

int main(){
    Estrutura campo;
    ....
}


E para acessar os membros, o acesso é direto e a sintaxe é:

//Para atribuir valores:
campo.membro_interno1 = 0;
campo.membro1 = 0;
 
//Para leitura do teclado:
&campo.membro_interno1
&campo.membro1

//Para impressão:
campo.membro_interno1
campo.membro1

------

A outra forma é você declarar a Estrutura1 antes e, na Estrutura2, declarar uma variável da estrutura 1. Dessa forma, a sintaxe é a seguinte:

#include <stdio.h>

typedef struct {
	tipo membro1;
	tipo membro2;
	...
} Estrutura1;
	
typedef struct {
	tipo membro3;
	tipo membro4;
	Estrutura1 campo1;
	...
} Estrutura2;
	
int main(){
    Estrutura2 campo2;
...
}

Para acessar os membros da Estrutura2, a sintaxe é:
campo2.membro3;
campo2.membro4;

Para acessar os membros da Estrutura1, a sintaxe é:
campo2.campo1.membro1;
campo2.campo1.membro2;

-------------------

Comparativo com e sem typedef:

SEM TYPEDEF:

#include <stdio.h>

struct Pessoa {
   int idade;
};

struct Aluno {
   int matricula;
   struct Pessoa pessoas;
};


int main(){

  struct Aluno alunos;
  
  alunos.pessoas.idade = 17;
  
  printf("Idade: %d anos", alunos.pessoas.idade);

  return 0;
}

>>> Idade: 17 anos

-----

COM TYPEDEF:

#include <stdio.h>

typedef struct {
   int idade;
} Pessoa;

typedef struct {
   int matricula;
   Pessoa pessoas;
} Aluno;


int main(){

  Aluno alunos;
  
  alunos.pessoas.idade = 17;
  
  printf("Idade: %d anos", alunos.pessoas.idade);

  return 0;
}

>>> Idade: 17 anos


-----------------

Exemplos:







-------------------

Exemplo da Estacio:

#include <stdio.h>
#include <stdlib.h>

typedef struct departamento {                //Está correto????
    int cod;
    char descricao[30];
} Departamento;
 
typedef struct cargo {                       //Está correto????
    int cod;
    char descricao[30];
} Cargo;

typedef struct funcionario {                //Está correto????
    int cod;
    char nome[30];
    float salario;
    Departamento depto;
    Cargo cargo;
} Funcionario;

printf( "\n TEXTO %_" , nome_vetor_struct[indice].nome_membro_struct);

int main(void){
...
}	


----------------------



-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




-----------------------------------------------------&&&




------------------------------- &&&

A declaração da estrutura de dados struct pode ser feita de três maneiras diferentes.

A primeira é a declaração do tipo struct realizada da mesma forma que declaramos variáveis de outros tipos quaisquer. Por exemplo, vamos declarar a variável x para que seja do tipo struct endereço com a declaração a seguir. Veja!

struct endereco x;


A segunda maneira é a declaração de uma ou mais variáveis durante a definição da própria estrutura. Por exemplo, podemos declarar três variáveis de nomes livro1, livro2 e livro3 a partir de uma estrutura de nome livro.

struct livro {
   char nome[30];
   char autor[50];
   int paginas;
   float preco;
} livro1, livro2, livro3;


A terceira maneira é para o caso de apenas uma variável do tipo estrutura ser necessária no programa. Sendo assim, não precisamos declarar um identificador, basta definir o nome da variável que será criada. Por exemplo, podemos criar uma variável estrutura chamada livro, da seguinte forma:

struct {
   char nome[30];
   char autor[50];
   int paginas;
   float preco;
} livro;


-----------------------------

SYSTEM()

#include <stdio.h>
#include <stdlib.h>

struct aluno {
   int v_nmat;                       //número da matrícula
   float v_nota[3];                  //notas
   float v_media;                    //media
};

int main() {
   struct aluno Felipe;              //declara uma variável do tipo struct

   Felipe.v_nmat = 120;
   Felipe.v_nota[0]=8.5;
   Felipe.v_nota[1]=7.2;
   Felipe.v_nota[2]=5.4;
   Felipe.v_media=(Felipe.v_nota[0]+ Felipe.v_nota[1]+ Felipe.v_nota[2])/3.0;

   printf(“Matricula:%d\n”, Felipe.v_nmat);
   printf(“Media: %2.f\n”, Felipe.v_media);

   system(“pause”);

   return(0);
}   

------------------------------

FFLUSH()

#include <stdio.h>
#include <conio.h>

int main(void) {
   /*Criando a struct */
   struct ficha_de_aluno {
      char nome[50];
      char disciplina[30];
      float nota_prova1;
      float nota_prova2;
   };
     
   struct ficha_de_aluno aluno;

   printf("\n---------- Cadastro de aluno -----------\n\n\n");     
   printf("Nome do aluno ......: ");

   fflush(stdin);

   fgets(aluno.nome, 40, stdin);   

   printf("Disciplina ......: ");

   fflush(stdin);

   fgets(aluno.disciplina, 40, stdin);  

   printf("Informe a 1a. nota ..: ");  

   scanf("%f", &aluno.nota_prova1);   

   printf("Informe a 2a. nota ..: ");

   scanf("%f", &aluno.nota_prova2);    

   printf("\n\n --------- Lendo os dados da struct ---------\n\n");
   printf("Nome ...........: %s", aluno.nome);
   printf("Disciplina .....: %s", aluno.disciplina);
   printf("Nota da Prova 1 ...: %.2f\n" , aluno.nota_prova1);
   printf("Nota da Prova 2 ...: %.2f\n" , aluno.nota_prova2);    

   getch();

   return(0);
}

>>> ----------- Cadastro de aluno --------------
>>>
>>> Nome ..................: Alana
>>> Disciplina ............: Inteligência Artificial
>>> Nota da Prova 1 .: 8
>>> Nota da Prova 2 .: 9
>>>
>>>
>>> -------- Lendo os dados da struct --------
>>>
>>> Nome ..................: Alana
>>> Disciplina ............: Inteligência Artificial
>>> Nota da Prova 1 .: 8.00
>>> Nota da Prova 2 .: 9.00

-----------------------------


----------------------

conio.h é um uma biblioteca(arquivo cabeçalho) de C usado principalmente por compiladores MS-DOS para fornecer input / output console.  Esse cabeçalho não faz parte da da biblioteca padrão C.

A maioria dos compiladores em C que foram feitos pensando nas plataformas DOS, Windows 3.x, Phar Lap, DOSX, OS / 2, Win32 tem esse cabeçalho além das funções associadas com a biblioteca padrão de C. 

A maioria dos compiladores em C que foram feitos pensando nas plataformas UNIX e Linux não possuem esse cabeçalho e não fornecem as funções de biblioteca conio. 

As funções da biblioteca declarados pela conio.h variam um pouco de compilador para compilador. 

Compiladores que foram feitos baseando-se em sistemas que não eram direcionados ao DOS, como o Linux, possuem diferentes implementações das funções contidas em conio.h. 

Segue a lista de funções:
kbhit - Determina se uma tecla foi pressionada.
getch - Lê um personagem diretamente do console sem buffer, e sem eco.
getche - Lê um personagem diretamente do console sem buffer, mas com eco.
ungetch - Coloca o caráter c volta para os buffers de teclado.
cgets - Lê uma string diretamente do console.
cscanf - Lê valores formatados diretamente do console.
putch - Grava um caractere diretamente ao console.
cputs - Grava uma seqüência diretamente ao console.
cprintf - valores formata e grava-los diretamente para o console.
clrscr - Limpa a tela.

-----------------------------------------

#include <stdio.h>
#include <conio.h>

int main()
{
    printf("Hello world");
    getch();
    return 0;

}

O getch() como também o getche() retorna a tecla digitada, muito usado em menus com switch.(Diferença entre os dois é que o getch() não mostra a tecla que digitou na tela, já o getche() mostra na tela qual foi a tecla digitada)

Arquivos com extensão .h não são bibliotecas, mas arquivos de cabeçalho onde, entre outras coisas, se encontram os protótipos das funções utilizadas.

conio.h é para desenhar tela, e é para dos/windows (as funções do conio são úteis para manipular caracteres na tela, especificar cor de carácter e de fundo.)

Agora você deve estar se perguntando:
Mas quais funções eu poderei usar com conio.h e qual a relação com o getch()?

As funções tipicas utilizadas com o conio.h são clrscr(para limpar a tela), gotoxy(posiciona o cursor na tela nas coordenadas x e y), getch(lê um carácter do teclado e não o mostra na tela), kbhit(testa se alguma tecla foi apertada, é necessário usar o comando getch ou getche antes), delline(apaga a linha que contem o cursor e move todas as linhas abaixo dela uma linha para cima), textcolor(muda a cor do texto), textbackground(muda a cor do fundo), cprintf (utilizada para imprimir na tela textos coloridos, é necessário especificar a cor usando a função textcolor).

No caso do seu código o emprego do conio foi por causa do emprego do getch() que é o maior responsável pela utilização da biblioteca. Os outros comandos geralmente você pode usar o comando system() que irá utilizar comando DOS para as mesmas finalidades.

---------------------------------


----------------

Código meio zoado!!!!


#include <stdio.h>
#include <string.h> 

typedef struct {
    char nome[200];
    char disciplina[100];
    float nota;
} Aluno;

int main(){

    Aluno aluno_nota[10];

    for(i=0; i< 10; i++) {
        strcpy(aluno_nota [i].nome, " NULL");
        strcpy(aluno_nota [i].disciplina = ‘ ‘);
        aluno_nota [i].nota = 0.0;
    }

    for (i=0; i< 10; i++) {
        printf(" Digite nome do aluno: ");
        scanf("%s%*c", & aluno_nota [i].nome);
        printf(" Digite a disciplina do aluno: ");
        scanf("%s%*c", & aluno_nota [i].disciplina);
        printf(" Digite o nota do aluno: ");
        scanf("%f%*c", & aluno_nota [i].nota);
    }

    for(i=0; i< 10; i++) {
        printf(" \n O nome do aluno é: %s ", aluno_nota [i].nome);
        printf(" \n A disciplina do aluno é: %s ", aluno_nota [i].disciplina);
        printf(" \n A nota do aluno é: %.2f ", aluno_nota [i].nota);
    }


    printf(" \n Digite um nome: ");
    scanf("%s%*c", nome);
    
    for(i=0; i< 10; i++) {
        if(strcmp(nome, aluno_nota [i].nome)== 0) {
            printf("\n Registro encontrado! ");
            posicao = i;
        } else {
            posicao = -1;
        }
    }
    
    if(posicao = -1) {
        printf(" \n Registro não encontrado! ");
    } else {
        printf(" \n Registro Encontrado: ");
        printf(" \n O nome do aluno é: %s ", aluno_nota [posicao].nome);
        printf(" \n A disciplina do aluno é: %s ", aluno_nota [posicao].disciplina);
        printf(" \n A nota do aluno é: %.2f ", aluno_nota [posicao].nota);
    }

    return 0;

}

------------------------
















-------------------


---------

