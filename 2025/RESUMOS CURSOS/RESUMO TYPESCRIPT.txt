 
////////////////////////////////////////////////////////// &&& ###
TYPESCRIPT SOZINHO (SEM REACT OU NEXTJS)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4

instalação do Typescript:
npm install -g typescript

instalação do Typescript em versão de desenvolvimento:
npm i -D typescript
(essa forma instala o typescript diretamente no seu projeto, possuindo o benefício de não ter versões conflitantes do Typescript)

Para saber a versão do typescript instalada:
tsc -v

Na pasta do projeto, digite:
tsc --init

Será gerado o arquivo tsconfig.json

Dentro desse arquivo terá:

{
  "compilerOptions": {
    "lib": ["esnext"],                //especifica a biblioteca de arquivos a serem incluídas na compilação
    "target": "esnext"                // especifica a versão do ECMAscript para o Javascript
  }
}

//////////////////////////////////////////////// &&& ###
Rodando o arquivo:

Na pasta do arquivo, digite no terminal:
tsc

Será gerado o arquivo teste.js que compilará o arquivo typescript em javascript

-------

-Arquivo teste.ts:

let name: string = "Carlos";

console.log(name);

Para rodar o codigo javascript compilado:
-No terminal, dentro da pasta do arquivo, digite:
node teste.js

-------------------

Então, sempre antes de rodar o arquivo, digite tsc para atualizar o arquivo .js 
Depois rode o arquivo com: node nome_do_arquivo.js

--------------------- ###
Declaration files:

O tipo de arquivo do typescript possui a extensão .ts

É possível criar um arquivo global com a extensão d.ts (Exemplo: globals.d.ts)

--------------------- ###

Caso o Typescript pare de analisar e indicar os erros, é possível reiniciá-lo fazendo:
Ctrl+Shift+P  =>  Typescript: Restart TS Server 

/////////////////////////////////////////////////////////// &&& 
@ts-ignore / @ts-nocheck / @ts-expect-error

Se quiser que o Typescript pare de checar e ignore o código que vem abaixo, pode-se usar o //@ts-ignore :

//@ts-ignore
const x: number = "Texto em string que não é um number"     //Erro ignorado

OBS: Apenas a linha de baixo é ignorada, as outras não:

//@ts-ignore
const x: number = "32"     //Erro ignorado
const x: number = "32"     //Erro!!!

-------------- ###

Se quiser ignorar todo o código do arquivo, pode-se usar o //@ts-nocheck :

//@ts-nocheck
const A: number = "3"                //Erro ignorado
const B: number = "Texto"            //Erro ignorado
const C: string = 36                 //Erro ignorado

function Mostrar(): void {           //Erro ignorado
  return "Texto que deveria ter como saída string e não void"
}

-------------- ###

Caso queira que o Typescript já saiba de antemão que virá um erro na linha de baixo e não indique o erro:

//@ts-expect-error
const x: number = "Texto"     //Erro esperado e ignorado

const x: number = "Texto"     //Erro!!!

////////////////////////////////////////////////////////// &&& ###
VARIAVEIS

Modo javascript:
let id = 5;

Modo typescript:
let id: number = 5;

É preciso especificar o tipo de variavel.

let name: string = "Carlos";
let isPublished: boolean = true;

//////////////////////////////////////////////// &&& ###
TIPOS DE VARIÁVEIS

const nome: string = "Carlos";
const idade: number = 30;
const status: boolean = true;
const vazio: null = null;
const indefinido: undefined = undefined;

Caso o tipo errado seja atribuído, o typescript mostrará o erro, mas o código rodará normalmente no browser:

const nome: number = "Carlos"

-----
Tipo Date:

const data: Date = new Date()

data.toLocaleDateString()
ou
data.getFullYear()
ou
data.getHours()
...

/////////////////////////////////////////////////////////////// &&&
TIPO ANY

Para aceitar qualquer tipo de variavel: (Use apenas se não souber o tipo da variavel!)
let x: any = "pedro";
let x: any = 40;
let x: any = true;
let x: any = [];

////////////////////////////////////////////////////////////////// &&&
FORÇANDO TIPOS (TYPE INFERING)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

let x: string | number             //variavel é string OU numero

x.toLowerCase()                    //Não é possível

(x as string).toLowerCase()        //É possível

ou

(<string>x).toLowerCase()        //É possível

ou

if(typeof x == "string"){          //É possível
  x.toLowerCase()
}

OBS: Se der um valor para a variável, o erro sumirá pois o typescript entenderá qual é o tipo correto
let x: string | number = "TEXTO"; 

---------------------------- ###

type ButtonColor = "red" | "blue" | "green"

export default function Button() {

  useEffect(() => {
    const previousButtonColor = localStorage.getItem("button-color") as ButtonColor
  }, [])

  return (
    <>
      <button>Clique aqui</button>
    </>
  )
}

//////////////////////////////////////////////////////// &&&
NON NULL (!)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

const txt: string | null = "Texto"

Enviar(txt!)         //A ! indica que a variavel Não pode ser null

----

export default function App() {

  const txt: string | null = "Texto"

  return (
    <div>
      {typeof txt!}
    </div>
  );
}

>>> string

-----
Mas é melhor fazer uma checagem ao invés de usar !:

function Texto(txt: string | null) {
  if (txt === null){
    throw new Error("Texto é obrigatório")
  }
  sendText(txt)
}


//////////////////////////////////////////////// &&& ###
FUNÇÕES
Tipos de variaveis em funções:

Strings:

Forma errada:

const juntarValores = (a, b) => {
  return a + b;
}

console.log(juntarValores("Ana ", "Maria"))
>>> Ana Maria

---------
Forma correta:

const juntarValores = (a: string, b: string) => {
  return a + b;
}

console.log(juntarValores("Ana ", "Maria"))
>>> Ana Maria

------------------ ###
Números:

const juntarValores = (a: string , b: string) => {
  return a + b;
}

console.log(juntarValores("10", "5"))      //Soma de strings
>>> 105

-------

const juntarValores = (a: number, b: number) => {
  return a + b;
}

console.log(juntarValores(10, 5))       //Soma de números
>>> 15

------------------- ###

Definindo o valor de saída:

const juntarValores = (a: number, b: number):number => {
  return a + b;
}

console.log(juntarValores(10, 5))
>>> 15

---------

const juntarValores = (a: string, b: string):string  => {
  return a + b;
}

console.log(juntarValores("10", "5"))
>>> 105

---------

const juntarValores = (a: number, b: number, c: string):string  => {
  return a + b + c;
}

console.log(juntarValores(10, 5, " anos"))
>>> 15 anos

----------------------- ###

function funcao(mensagem: string) {
  return mensagem
}

export default function App() {
  return (
    <>
      <h1>{funcao("Texto da mensagem")}</h1>
    </>
  )
}

----------------------------- ###
O valor de saída não precisa necessariamente ser um tipo (string, number, etc.):

function Maioridade(idade: any): "Maior de idade" | "Menor de idade" | "Não sei" {
  if (idade >= 18) {
    return "Maior de idade"
  } else if (idade <18) {
    return "Menor de idade"
  } else {
    return "Não sei"
  }
}

export default function App() {
  return (
    <div>
      <h1>{Maioridade(20)}</h1>
    </div>
  );
}

-------------------------------------- ###
TIPO VOID

Para funções que não possuem um valor de retorno, o seu será void:

function Pessoa(nome: string): void {
  alert(`Olá, ${nome}`);                  //OU console.log(`Olá, ${nome}`);
}

export default function App() {
  return (
    <>
      <button onClick={() => Pessoa("João")}>Clique aqui</button>
    </>
  );
}

//////////////////////////////////////////////// &&& ###
TYPE ALIAS 

É possível criar um tipo persolnalizado em funções:

Exemplos:
type UserName = string;
type Point = { x: number; y: number; };
type Status = "success" | "error" | "pending";

------------------ ###

type Ano = number

const carYear: Ano = 2001

export default function App() {
  return (
    <>
      <h1>{carYear}</h1>
    </>
  );
}

-------

type Ano = number
type Tipo = string
type Modelo = string
type Carro = {
  year: Ano,
  type: Tipo,
  model: Modelo
}

const carYear: Ano = 2001
const carType: Tipo = "Toyota"
const carModel: Modelo = "Corolla"
const car: Carro = {
  year: carYear,
  type: carType,
  model: carModel
};

export default function App() {
  return (
    <>
      <h1>{carYear}</h1>
      <h1>{carType}</h1>
      <h1>{carModel}</h1>
      <p>{car.year} - {car.type} - {car.model}</p>
    </>
  );
}

-------------- ###
Type alias em funções:

type Soma = (a: number, b: number) => number;

const add: Soma = (a, b) => {
  return a + b;
};

export default function App() {
  return (
    <div>
      <h1>{add(5, 3)}</h1>
    </div>
  )
}

------------- ###

type Pessoa = {
  nome: string;
};

function Hello(pessoa: Pessoa) {
  return `Olá, ${pessoa.nome}`;
}

function Goodbye(pessoa: Pessoa) {
  return `Adeus, ${pessoa.nome}`;
}

export default function App() {
  return (
    <>
      <h1>{Hello({ nome: "João" })}</h1>
      <p>{Goodbye({ nome: "João" })}</p>
    </>
  );
}

--------------- ###

type TiposDeID = string | number;

const printID = (id: TiposDeID) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");
>>> ID: 123

---------
Interfaces are similar to type aliases, except they only apply to object types.

Example
interface Rectangle {
  height: number,
  width: number
}

const rectangle: Rectangle = {
  height: 20,
  width: 10
};

--------------------------------------- ###
IMPORTANDO TYPE ALIAS 

-Arquivo models.ts:

export type Soma = (a: number, b: number) => number;
export type Nome = (nome: string, sobrenome: string) => string;

¨¨¨¨
-Arquivo App.tsx:

import type {Soma, Nome} from "./models"
// ou import {type Soma, type Nome} from "./models"

const add: Soma = (a, b) => {
  return a + b;
};

const pessoa: Nome = (nome, sobrenome) => {
  return `${nome} ${sobrenome}`;
};

export default function App() {
  return (
    <div>
      <h1>{add(5, 3)}</h1>
      <h1>{pessoa("João", "Silva")}</h1>
    </div>
  )
}

/////////////////////////////////////////////////////// &&&
INTERFACE

Modo javascript:

const User = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = 40                 //tipo number

console.log(User.age)
>>> 40

Se aplicasse esse código no typescript, ele até funcionaria, mas não é o ideal.
Teríamos problemas com o código abaixo, por exemplo:

const User = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = "40"                //tipo string

console.log(User.age)
>>> ERRO!!!

--------- ###

Modo typescript usando interface:

interface UserInterface {
  id: number;
  name: string;
  age: number;
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = 40           //tipo number

console.log(User.age)
>>> 40

-------------------------- ###
Interface é bem parecido com type:

type Pessoa = {
  nome: string,
  idade: number,
}

interface Pessoa {
  nome: string,
  idade: number,  
}

------------------------- ### &&&
Interface com campos faltando: (campo opcional)

interface UserInterface {
  id: number;
  name: string;
  age?: number;       //adicione uma ? para o campo ser opcional
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
}

console.log(User.age)
>>> undefined

------
Adicionando uma condicional:

interface UserInterface {
  id: number;
  name: string;
  age?: number;       
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
}

if (!User.age){
  console.log("Idade não foi informada")
} else {
  console.log(User.age)
}

>>> Idade não foi informada

--------------------------- ###

Interface com funções:

Modo javascript:

const User = {
    funcao(mensagem) {
        console.log(mensagem);
    }
};
User.funcao("Texto da mensagem");
>>> Texto da mensagem

----

Modo typescript:

interface UserInterface {
  funcao(mensagem: string): void;     
}

const User: UserInterface = {
  funcao(mensagem) {
    console.log(mensagem);
  }
}

User.funcao("Texto da mensagem")
>>> Texto da mensagem

----

Os nomes dos parametros na interface não precisam ser exatamente os mesmos:

interface UserInterface {
  funcao(mensagem: string): void;  
}

const User: UserInterface = {
  funcao(msg) {
    console.log(msg);
  }
}

User.funcao("Texto da mensagem")

------

interface SomaInterface {
  Somar(a: number, b: number): void;     
}

const Adicao: SomaInterface = {
  Somar(a, b) {
    console.log(a + b);
  }
}

Adicao.Somar(2, 5)
>>> 7

----------

É possível colocar os tipos dentro da função também:

interface UserInterface {
  funcao(mensagem: string): void;  
}

const User: UserInterface = {
  funcao(mensagem: string): void {
    console.log(mensagem);
  }
}

User.funcao("Texto da mensagem")
>>> Texto da mensagem

------------------------------------------------- ###
Herança com Interfaces:

interface Pessoa {
  nome: string,
  idade: number
}

interface Funcionario extends Pessoa {
  cargo: string,
}

-A interface Funcionario passará a herdar as propriedades nome e idade de Pessoa

-------------------- %%%

interface User {
  id: string;
  nome: string;
  idade: number;
  email: string;
}

interface UserSemEmail {
  id: string;
  nome: string;
  idade: number;
}

Ao invés de fazer isso acima, faria:

interface UserSemEmail {
  id: string;
  nome: string;
  idade: number;
}

interface User extends UserSemEmail {
  email: string;
}

------------------- %%%

interface Personagem {
  nome: string,
  level: number
}

interface Mago extends Personagem {
  magias: string[],
  mana: number
}

const Merlin: Mago = {
  nome: "Merlin",
  level: 100,
  magias: ["Fireball", "Alakazam", "Abracadabra"],
  mana: 76
}

------------------------- %%%
Herdando mais de 1 interface:

interface Pessoa {
  nome: string,
  idade: number
}

interface Empregado {
  turno: string,
  salario: number,
}

interface Professor extends Pessoa, Empregado {
  disciplina: string,
  escola: string
}

------------------------------------------------ ### 
Interfaces com React:

interface Pessoa {
  nome: string,
  idade: number
}

function Mostrar(funcionario: Pessoa): string {
  return funcionario.nome
}

export default function App() {

  const funcionario = {
    nome: 'João',
    idade: 25
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

---------------------- %%%

interface Pessoa {
  nome: string,
  idade: number
}

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)
}

export default function App() {

  const funcionario = {
    nome: 'João',
    idade: 25
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------- %%%

interface Pessoa {
  nome: string,
  idade: number
}

interface Funcionario extends Pessoa {
  cargo: string,
}

function Mostrar(funcionario: Funcionario): void {
  console.log(funcionario.cargo)
}

export default function App() {

  const funcionario = {
    nome: 'João',
    idade: 25,
    cargo: 'Desenvolvedor'
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------- %%%

interface Personagem {
  nome: string,
  level: number
}

interface Mago extends Personagem {
  magias: string[],
  mana: number
}

function Mostrar(wizard: Mago): void {
  console.log(wizard.magias)
}

export default function App() {

  const wizard: Mago = {
    nome: "Merlin",
    level: 100,
    magias: ["Fireball", "Alakazam", "Abracadabra"],
    mana: 76
  }

  return (
    <div>
      <button onClick={() => Mostrar(wizard)}>CLIQUE</button>
    </div>
  );
}

-------------------------------- %%%

interface Pessoa {
  nome: string,
  idade: number
}

interface Empregado {
  turno: string,
  salario: number,
}

interface Professor extends Pessoa, Empregado {
  disciplina: string,
  escola: string
}

function Mostrar(funcionario: Professor): string {
  return funcionario.escola
}

export default function App() {

  const funcionario: Professor = {
    nome: "Carlos",
    idade: 23,
    turno: "Manhã",
    salario: 1200,
    disciplina: "Matemática",
    escola: "Escola Estadual",
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

------------------------------------------------ ###
Substituindo um tipo de propriedade em uma interface:

interface Pessoa {
  nome: string,
  idade: string | number
}

interface Funcionario extends Pessoa {
  cargo: string,
  idade: number                                  //idade deixou de aceitar string
}

export default function App() {

  const funcionario: Funcionario = {
    nome: 'João',
    idade: "25",                           //Typescript mostrará erro pois idade só aceita number agora
    cargo: 'Desenvolvedor'
  }

  return (
    <div>
      {funcionario.idade}
    </div>
  );
}

¨¨¨¨
Atenção!
Não é possível trocar para um tipo incompatível:

interface Pessoa {
  nome: string,
  idade: string
}

interface Funcionario extends Pessoa {
  cargo: string,
  idade: number                                  //ERRO!!! Passará a ser do tipo Never
}

--------------------------------------------------------- ###
INTERFACE COM CLASSES

interface Animal {
  name: string;
  makeSound(): string;
}

export default function App() {

  class Dog implements Animal {
    name: string;

    constructor(name: string) {
      this.name = name;
    }

    makeSound(): string {
      return `${this.name} está latindo!`;
    }
  }

  const cachorro = new Dog("Rex");

  return (
    <div>
      {cachorro.makeSound()}
    </div>
  );
}

-------------------- %%%

interface Pessoa {
  nome: string;
  idade: number;
}

export default function App() {

  class Funcionario implements Pessoa {

    nome: string;
    idade: number;

    constructor(nome: string, idade: number) {
      this.nome = nome;
      this.idade = idade;
    }

    getNome() {
      return this.nome;
    }
  }

  const funcionario = new Funcionario("Carlos", 30);

  return (
    <div>
      {funcionario.getNome()}
    </div>
  );
}


////////////////////////////////////////////////////////////////////////////////// &&& 
GENERICS (CONTAINER)     <T>
Tipo genérico que aceita qualquer tipo de dado.

Se os valores passados forem de um tipo, então o container assumirá este tipo:

getIdade<T>         //É o mesmo que getIdade<number>
getIdade(22)        //Passou número como valor

getNome<T>          //É o mesmo que getIdade<string>
getNome("Maria")    //Passou string como valor

------

Exemplos:
type lista = Array<Item>
type numero = Array<NUMERO>
type nome = getNome<n>
type texto = getText<txt>

Pode-se chamar de qualquer coisa, mas o convencional é chamar de <T>.


-------------------------------- %%%
String e Number:

function Mostrar<T>(item: T): T {
  return item;
}

export default function App() {

  return (
    <div>
      <p>{Mostrar("Carlos")}</p>
      <p>{Mostrar(22)}</p>
    </div>
  );
}

>>> Carlos
>>> 22

----------------------------------- %%%
Boolean:

function Mostrar<T>(item: T): string {
  if (item === true) {
    return "É um booleano";
  } else {
    return "Não é um booleano";
  }
}

export default function App() {

  return (
    <div>
      {Mostrar(true)}
    </div>
  );
}

>>> É um booleano

--------------------------------- %%%
Array:

function getFirstElement<Item>(arr: Item[]): Item | undefined {
  return arr[0]
}

export default function App() {
  return (
    <div>
      {getFirstElement([1, 2, 3, 4])}
    </div>
  );
}

>>> 1

----------------------------------- %%%
Objetos: 

type Pessoa<T> = {
  id: T;                  //id pode ser de qualquer tipo
  nome: string;
}

export default function App() {
  
  const funcionario1: Pessoa<string> = {
    id: "ABC",                                //tipo string
    nome: "Carlos"
  };

  const funcionario2: Pessoa<number> = {
    id: 123,                                  //tipo number
    nome: "João"
  };

  return (
    <>
      <p>{funcionario1.id}</p> 
      <p>{funcionario2.id}</p>
    </>  
  );
}

>>> ABC
>>> 123

---------------------
Com interfaces:

interface ResponseData<T> {
  data: T | null;
  error: string | null;
  isLoading: boolean;
}

export default function App() {
  
  const response: ResponseData<string> = {
    data: "Dados recebidos",
    error: null,
    isLoading: false,
  };

  return (
    <>
      {response.data} 
    </>  
  );
}

>>> Dados recebidos

----------------------

interface Pessoa<Generico> {
  nome: string;
  idade: Generico;
}

function Mostrar<Tipo>(funcionario: Pessoa<Tipo>): Tipo {
  return funcionario.idade;
}

export default function App() {

  const funcionario1: Pessoa<string> = {
    nome: 'João',
    idade: '25 anos',
  }

  const funcionario2: Pessoa<number> = {
    nome: 'Carlos',
    idade: 32,
  }

  return (
    <div>
      <p>{Mostrar(funcionario1)}</p>
      <p>{Mostrar(funcionario2)}</p>
    </div>
  );
}

>>> 25 anos
>>> 32

-------
OUTRA FORMA SEM INTERFACE:

function Mostrar<T>(funcionario: { nome: string, idade: T } ): T {
  return funcionario.idade;
}

export default function App() {

  const funcionario1 = {
    nome: 'João',
    idade: '25 anos',
  }

  const funcionario2 = {
    nome: 'Carlos',
    idade: 32,
  }

  return (
    <div>
      <p>{Mostrar(funcionario1)}</p>
      <p>{Mostrar(funcionario2)}</p>
    </div>
  );
}

-----------------------

function Mostrar<Item extends { nome: string }>(pessoa: Item): string {
  return pessoa.nome
}

export default function App() {

  const pessoa = {
    nome: 'João',
    idade: 25,
  }

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

Não funciona tão bem dessa forma, pois isso é o mesmo que:

type Pessoa = {
  nome: string;
  idade: 25;
}

function Mostrar(pessoa: Pessoa): string {
  return pessoa.nome
}

export default function App() {

  const pessoa: Pessoa = {
    nome: 'João',
    idade: 25,
  }

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

--------------------------------------------- ### &&&
GENERICS COM FUNÇÕES NORMAIS vs ARROW FUNCTION
VIDEO: https://www.youtube.com/embed/TPACABQTHvM

const convertToArray = (value: string): string[] => {
  return [value.toUpperCase()];
}

convertToArray(5)           //Erro!
convertToArray("Texto")     //OK!

-Só aceitará strings

-------
Usando generic:

const convertToArray = <T,>(value: T): T[] => {
  return [value.toUpperCase()];
}

OU 

function convertToArray <T>(value: T): T[] {
  return [value.toUpperCase()];
}


Atenção!!!
Ao usar arrow function, é necessário colocar uma virgula após o nome do container genérico:  <T,> 
Isso é para que o Javascript não pense que é uma tag HTML entre <> e aponte um erro

Se colocar da forma abaixo, dará o seguinte erro no Typescript: 
JSX element 'T' has no corresponding closing tag.

const Funcao= <T>(parametro: T): T => {
  //intrução
}

---------------------------------------------- ### 
GENERICS COM CLASSES    

export default function App() {

  class Pessoa<T> {
    idade: T;

    constructor(idade: T) {
      this.idade = idade;
    }

    getIdade(): T {
      return this.idade;
    }
  }

  const pessoa = new Pessoa('30');

  return (
    <div>
      {pessoa.getIdade()}
    </div>
  );
}

------------------------ %%%

export default function App() {

  class Pessoa <T> {
    nome: string;
    idade: T;

    constructor(nome: string, idade: T) {
      this.nome = nome;
      this.idade = idade;
    }

    getIdade(): T {
      return this.idade;
    }
  }

  const pessoa = new Pessoa("João", '30 anos');

  return (
    <div>
      {pessoa.getIdade()}
    </div>
  );
}


------------------------ %%%

Criando uma interface genérica que aceite vários tipos de dados:

class Container <T> {
  private contents: T[]

  constructor() {
    this.contents = []
  }

  addItem(item: T):void {
    this.contents.push(item)
  }

  getItem(indice: number):T | undefined {
    return this.contents[indice]
  }
}

const pessoas = new Container <string> () 
pessoas.addItem("Maria")
const p1 = pessoas.getItem(0)
console.log(p1)                    // >>> Maria

const numeros = new Container <number> ()
numeros.addItem(1)
const num1 = numeros.getItem(0)
console.log(num1)                  // >>> 1

------------------------ %%%
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

interface Repository<T> {
  getAll(): T[];
  getById(id: string): T | undefined;
  save(item: T): void;
}

class InMemoryRepository<T extends {id: string}> implements Repository<T> {
  private items: T[] = [];

  getAll(): T[] {
    return [...this.items];
  }

  getById(id: string): T | undefined {
    return this.items.find((item) => item.id === id)
  }

  save(item: T): void {
    const index = this.items.findIndex((i) => i.id === item.id);
    if (index >= 0) {
      this.items[index] = item;
    } else {
      this.items.push(item)
    }
  }
}

interface Pessoa {
  id: string;
  name: string;
}

const Repo = new InMemoryRepository<Pessoa>();

Repo.save({id: "1", name: "Maria"})
Repo.save({id: "2", name: "Carlos"})

console.log(Repo.getAll())

---------------------------- %%%

interface IRepository<T> {
  getById(id: number): T | undefined;
  getAll(): T[];
  add(item: T): void;
  update(id: number, item: T): void;
  delete(id: number): void;
}

class GenericRepository<T extends { id: number }> implements IRepository<T> {
  private items: T[] = [];

  getById(id: number): T | undefined {
    return this.items.find(item => item.id === id);
  }

  getAll(): T[] {
    return [...this.items];
  }

  add(item: T): void {
    this.items.push(item);
  }

  update(id: number, item: T): void {
    const index = this.items.findIndex(item => item.id === id);
    if (index > -1) {
      this.items[index] = item;
    }
  }

  delete(id: number): void {
    this.items = this.items.filter(item => item.id !== id);
  }
}

interface Product {
  id: number;
  name: string;
  price: number;
}

const productRepository = new GenericRepository<Product>();

productRepository.add({ id: 1, name: "Laptop", price: 1200 });
productRepository.add({ id: 2, name: "Keyboard", price: 75 });

console.log(productRepository.getAll());

const laptop = productRepository.getById(1);
console.log(laptop);

----------------------------------------------------- ###
MULTIPLOS PARAMETROS USANDO INTERFACE GENERICA

Pode-se usar várias interfaces genéricas como parâmetros de funções.
O convencional é usar as letras T, U, V, etc...  

function getData<T, U, V, W>(dados: <T, U, V, W> ) {
  return dados.txt1
}

------------------ %%%

function Mostrar<X, Y>(pessoa: X, idade: Y): string {
  return `${pessoa} tem ${idade} anos`;
}

export default function App() {

  const pessoa = "João"
  const idade = 33           

  return (
    <div>
      <p>{Mostrar(pessoa, idade)}</p>
    </div>
  );
}

>>> João tem 33 anos

-------------------- %%%

function Mostrar<X, Y>(yearStr: X, yearNum: Y): [X, Y] {
  return [yearStr, yearNum]
}

export default function App() {

  const yearStr = "Ano"
  const yearNum = 2025

  return (
    <div>
      {Mostrar(yearStr, yearNum)}
    </div>
  );
}

>>> Ano2025            

--------------------- %%%

function Mostrar<X, Y>(a: X, b: Y): [X, Y] {
  return [a, b]
}

export default function App() {

  return (
    <div>
      {Mostrar([1, 2, 3], ["A", "B", "C"])}        //OU Mostrar<number, string>([1, 2, 3], ["A", "B", "C"])
    </div>
  );
}

OU

function Mostrar<X, Y>(a: X, b: Y): [X, Y] {
  return [a, b]
}

export default function App() {

  const array1 = [1, 2, 3]
  const array2 = ["A", "B", "C"]

  return (
    <div>
      {Mostrar(array1, array2)}
    </div>
  );
}

>>> 123ABC

--------------------- %%%


function pair<A, B>(a: A[][], b: B[][]) {
  return a[0][0];
}

export default function App() {

  const A = [
    ['ab', 'ac'], ['ad', 'ae']
  ]

  const B = [
    ['ba', 'bc'], ['bd', 'be']
  ]

  return (
    <div>
      <p>{pair(A, B)}</p>
    </div>
  );
}

>>> ab

-------------------- %%%


function pair<A, B>(a: A[], b: B[]): [A, B][] {
  const array: [A, B][] = []
  for (let i = 0; i < a.length || i < b.length; i++) {
    array.push([a[i], b[i]])
  }
  return array;
}

export default function App() {

  const A = [
    ['ab', 'ac'], ['ad', 'ae']
  ]

  const B = [
    ['ba', 'bc'], ['bd', 'be']
  ]

  return (
    <div>
      <p>{JSON.stringify(pair(A, B))}</p>
    </div>
  );
}

>>> [[["ab","ac"],["ba","bc"]],[["ad","ae"],["bd","be"]]]

------------------------------------------------------- ###
GENERIC CONTRAINTS
Para especificar um pouco o tipo que uma interface genérica seria.

type Pessoa = {
  idade: string;
}

function Mostrar<T extends Pessoa>(funcionario: T) {
  return funcionario.idade
}

export default function App() {

  const funcionario = {
    idade: "25",                    //Se colocar tipo number no valor, dará erro no typescript
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

>>> 25

¨¨¨¨
Isso é o equivalente a dizer que:

function Mostrar<T extends {idade: string}>(funcionario: T) {
  return funcionario.idade
}

export default function App() {

  const funcionario = {
    idade: "25",
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

------------------- %%%

type Texto = {
  numero: string;
  letra: string;
}

function Mostrar<T extends Texto>(arr: T[]) {
  return arr.map((item) => item.numero)
}

export default function App() {

  const txt = [{
    numero: "30",
    letra: "Z"
  }]

  return (
    <div>
      {Mostrar(txt)}
    </div>
  );
}

>>> 30

OU

function Mostrar<T extends {numero: string}>(arr: T[]) {
  return arr.map((item) => item.numero)
}

export default function App() {

  const txt = [{
    numero: "30",
    letra: "Z"
  }]

  return (
    <div>
      {Mostrar(txt)}
    </div>
  );
}

-------------------- %%%

type Texto = {
  numeros: string[];
  letras: string[];
}

function Mostrar<T extends Texto>(arr: T[]) {
  return  arr.map((item) => item.numeros)
}

export default function App() {

  const txt = [{
    numeros: ["1", "2", "3", "4"],
    letras: ["A", "B", "C", "D"]
  }]

  return (
    <div>
      {Mostrar(txt)}
    </div>
  );
}

>>> 1234

OU

function Mostrar<T extends {numeros: string[]}>(arr: T[]) {
  return  arr.map((item) => item.numeros)
}

export default function App() {

  const txt = [{
    numeros: ["1", "2", "3", "4"],
    letras: ["A", "B", "C", "D"]
  }]

  return (
    <div>
      {Mostrar(txt)}
    </div>
  );
}

----------------------------------------------------------- ### 
TYPE PARAMETERS FOR TYPES
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

Parametros de tipos genericos não são limitados apenas à funções ou métodos. Pode-se criar tipos genéricos também:

type Pessoa<T> = {
  nome: string;
  idade: T;
}

export default function App(){

  const funcionario: Pessoa<string> = {
    nome: "Maria",
    idade: "20 anos",         
  }

  return (
    <>
      <p>{funcionario.idade}</p>
    </>
  )
}

OU

type Pessoa<T> = {
  nome: string;
  idade: T;
}

export default function App(){

  const funcionario: Pessoa<number> = {
    nome: "Maria",
    idade: 20,         
  }

  return (
    <>
      <p>{funcionario.idade}</p>
    </>
  )
}

-------------------------------- ### 

export default function App(){

  function getIdade<T>(idade: T): string {
    return String(idade);
  }

  return (
    <>
      <p>{getIdade("20 anos")}</p>
      <p>{getIdade(20)}</p>
    </>
  )
}

----

type Pessoa<T> = {
  idade: T;
}

export default function App(){

  function getIdade <T>({idade}: Pessoa<T>): string {
    return String(idade);
  }

  return (
    <>
      <p>{getIdade({idade: "20 anos"})}</p>
      <p>{getIdade({idade: 20})}</p>
    </>
  )
}

-----

type Pessoa<T> = {
  idade: T;
}

export default function App(){

  function getIdade <T>({idade}: Pessoa<T>): number {
    return Number(idade);
  }

  return (
    <>
      <p>{getIdade({idade: "20"})}</p>
      <p>{getIdade({idade: 20})}</p>
    </>
  )
}

-----

type Pessoa<T> = {
  idade: T;
}

export default function App(){

  function getIdade <T>({idade}: Pessoa<T>): void {
    console.log(idade);
  }

  return (
    <>
      <button onClick={() => getIdade({idade:"20"})}>String</button>
      <button onClick={() => getIdade({idade:20})}>Number</button>
    </>
  )
}

-------------------------------- ###

interface Store<T> {
  get(id: string): T;
  save(id: string, item: T): void;
  list(): T[];
}

function handleItems<T>(store: Store<T>, id: string, newItem: T): T[]{
  store.save(id, newItem)
  return store.list()
}

type Product = {
  name: string;
  price: number;
}

const productStore= {
  products: {} as Record<string, Product>,
  get(id: string): Product {
    return this.products[id]
  }
  save(id: string, item: Product): void {
    this.products[id] = item
  }
  list(): Product[] {
    return Object.values(this.products)
  }
}

const newStore = handleItems(productStore, "Dell", {
  name: "Laptop",
  price: 999,
})

console.log(newStore)

const finalStore = handleItems(productStore, "Sharp", {
  name: "TV",
  price: 1100,
})

console.log(finalStore)


OBS: Também funciona com type alias:
type Store<T> = { ... }

----------------------------------------- ###
GENERICS COM PROPS 

-Arquivo Teste.tsx:

type Pessoa<T> = {
  nome: string;
  idade: T;
}

export default function Teste<T>({nome, idade}: Pessoa<T>) {
  return (
    <>
      <p>{nome} tem {String(idade)} anos</p>                   
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from './components/Teste'

export default function App() {
  const funcionario = {
    nome: "João",
    idade: "25",
  }

  return (
    <>
      <Teste nome={funcionario.nome} idade={funcionario.idade} />
    </>
  )
}

-------------------

-Arquivo Teste.tsx:

type Pessoa<T> = {
  nome: string;
  idade: T;
}

export default function Teste<T>({ nome, idade }: Pessoa<T>) {
  return (
    <>
      <p>{nome} tem {String(idade)}</p>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from './components/Teste'

export default function App() {
  const funcionario = {
    nome: "João",
    idade: "25 anos",                     // string
  }
  
  const funcionario2 = {
    nome: "Maria",
    idade: 30,                            // number
  }
  
  const funcionario3 = {
    nome: "Pedro",
    idade: { anos: 35, meses: 6 },        // object
  }
  
  return (
    <>
      {/* Explicitamente definindo o tipo genérico */}
      <Teste<string> nome={funcionario.nome} idade={funcionario.idade} />
      
      {/* TypeScript pode inferir automaticamente */}
      <Teste nome={funcionario2.nome} idade={funcionario2.idade} />
      
      {/* Usando um objeto como idade */}
      <Teste nome={funcionario3.nome} idade={funcionario3.idade.anos} />
    </>
  )
}

----------------------- %%%

-Arquivo Teste.tsx:

type Pessoa<T> = {
  data: T[]; 
  onItemClick: (item: T) => void; 
}

export default function Teste<T>({ data, onItemClick }: Pessoa<T>) {
  return (
    <div>
      {data.map((item, index) => (
        <div 
          key={index} 
          onClick={() => onItemClick(item)}
          style={{ cursor: 'pointer', padding: '8px', border: '1px solid #ccc', margin: '4px' }}
        >
          {typeof item === 'object' ? JSON.stringify(item) : String(item)}
        </div>
      ))}
    </div>
  );
}

¨¨¨¨

-Arquivo App:

import Teste from './components/Teste';

type User = {
  id: number;
  name: string;
}

export default function App() {

  const users: User[] = [
    { id: 1, name: "Alice" }, 
    { id: 2, name: "Bob" }
  ];

  const handleUserClick = (user: User) => {
    console.log(`Clicked user: ${user.name}`);
  };

  return (
    <div>
      <Teste data={users} onItemClick={handleUserClick} />
    </div>
  );
}

------------------------------- %%%

-Arquivo Button.tsx:

type ButtonProps<T> = {
  countValue: T;                   //CountValue terá que ser do mesmo tipo que countHistory
  countHistory: T[]; 
}

export default function Button<T>({ countValue, countHistory }: ButtonProps<T>) {
  return (
    <div>
      <button>CLIQUE</button>
    </div>
  );
}

¨¨¨¨

-Arquivo App:

import Button from './components/Button';

export default function App() {

  return (
    <div>
      <Button countValue={5} countHistory={[10, 20, 30]}  />
    </div>
  );
}


///////////////////////////////////////////////////////////////////// &&&
CAMPOS IMUTÁVEIS EM UMA INTERFACE    (readonly)

Para proibir que valores de certos campos de uma interface possam ser alterados:

interface PessoaInterface {
  readonly id: number;            //Não pode ser alterado
  readonly nome: string;          //Não pode ser alterado
  readonly dataInicio: Date;       //Não pode ser alterado
  idade: number;                    //Pode ser alterado
}

const funcionario: PessoaInterface = {
  id: 12345,
  nome: "Maria",
  dataInicio: new Date(),
  idade: 20,
}

funcionario.idade = 33

console.log(funcionario)

////////////////////////////////////////////////////////////// &&&
INTERFACE vs TYPE

Sintaxe:

type Pessoa = {
  nome: string;
  idade: number;
  status: boolean;
}

interface Pessoa {
  nome: string;
  idade: number;
  status: boolean;
}

Alguns devs escrevem type e interface colocando um T ou I na frente do nome:

type TPessoa = { ... }
ou
interface IPessoa { ... }

----------------------------------------- ###
Diferenças:

INTERFACE:

Extensibilidade: Interfaces são abertas, o que significa que você pode adicionar novas propriedades a uma interface existente em qualquer parte do seu código.

interface User {
  name: string;
}

interface User {
  age: number;
}
¨
¨¨¨¨
Herança: Interfaces podem estender outras interfaces, facilitando a reutilização de tipos e a criação de tipos compostos.

interface Person {
  name: string;
}

interface User extends Person {
  login: string;
}

¨¨¨¨
Classes: Interfaces são comumente usadas para definir contratos para classes, especificando quais métodos e propriedades uma classe deve ter.

interface Serializable {
  serialize(): string;
}

class User implements Serializable {
  serialize() {
    return "User Data";
  }
}

--------------------- %%%
TYPE:

Versatilidade: type permite criar tipos que não são apenas objetos. Isso inclui uniões, interseções, primitivos, entre outros.

type ID = string | number;

type User = { name: string } & { age: number };

¨¨¨¨
Composição: type pode ser usado para compor novos tipos a partir de tipos existentes.

type PartialUser = Partial<User>;

¨¨¨¨
Expressões Condicionais: type pode expressar tipos condicionais e mapeados, oferecendo um alto grau de flexibilidade e funcionalidade.

type ReadOnly<T> = { readonly [P in keyof T]: T[P] };

---------------------- %%%
RESUMO DE DIFERENÇAS:

Extensibilidade: interface é extensível, mas type não é. Isso significa que você pode adicionar novas propriedades a uma interface existente, mas não pode fazer isso com um type.

Declaração vs. Expressão: interface é sempre uma declaração de forma, enquanto type pode ser uma declaração ou uma expressão.

União e Interseção: type é mais flexível e pode ser usado para criar uniões e interseções de tipos.

Use interface quando precisar de extensibilidade ou estiver definindo contratos para objetos ou classes.
Use type para uniões, interseções, tipos primitivos, ou quando precisar de tipos complexos ou expressões condicionais.

----------------------- %%%

Podem existir interfaces com o mesmo nome:  

interface Pessoa {
  nome: string
}

interface Pessoa {
  idade: number
}

Isso é o mesmo que:

interface Pessoa {
  nome: string,
  idade: number
}

----

interface Pessoa {
  nome: string,
}

interface Pessoa {
  idade: number,
}

function Mostrar(funcionario: Pessoa): string {
  return funcionario.nome
}

export default function App() {

  const funcionario = {
    nome: 'João',
    idade: 25
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

¨¨¨¨
Se fizer o mesmo usando type, dará erro!!!

type Pessoa = {
  nome: string,
}

type Pessoa = {
  idade: number,
}

>>> ERRO

------------------------------- ###

type URL = string                                      // OK
const google: URL = "https://google.com"

interface URL = string                                // Não pode
interface URL { string }                              // Não pode
const google: URL = "https://google.com"

¨¨¨¨
Interfaces podem apenas descrever objetos.

interface URL {                                       // OK
  tipo: string 
}              

const google: URL = {
  tipo: "https://google.com"
}

¨¨¨¨
-O mesmo vale para union types:

type Colors = "red" | "blue" | "green"

interface Colors {
  color: "red" | "blue" | "green"
}

//////////////////////////////////////////////////////////////// &&& 
USE REF NO TYPESCRIPT:

import {useRef} from 'react'

export default function App() {

  const ref = useRef<HTMLButtonElement | null>(null)

  return (
    <button ref={ref} >
      Clique aqui 
    </button>
  )
}

----------------- ###

Para evitar a re-renderização, pode-se usar o useRef ao invés do useState:

import { useRef, useEffect } from "react";

export default function App() {

  const number = useRef<number>(0)

  useEffect(() => {
    console.log("Componente renderizado")
  })

  function handleClick(): void{
    number.current = number.current + 1
    console.log(number.current)
  }

  return (
    <div>
      <p>{number.current}</p>
      <button onClick={handleClick}>Clique</button>
    </div>
  )
}

-Com isso, ao clicar no botão e alterar o valor de number, o componente não é renderizado novamente.

------------------------- ###

import { useRef, useEffect } from "react";

export default function App() {

  const inputRef = useRef<HTMLInputElement | null>(null);

  useEffect(() => {                 //opcional
    console.log("Componente renderizado");
  }, []);

  function handleClick(): void {
    if (inputRef.current) {
      inputRef.current.focus();                                 //Coloca foco no input
      inputRef.current.style.backgroundColor = "yellow";        //Muda a cor de fundo do input
    }
  }

  return (
    <div>
      <input ref={inputRef} />
      <button onClick={handleClick}>MUDAR</button>
    </div>
  );
}

------------------------- ###


-Para referenciar algum elemento HTML:

import { useState, useEffect, useRef } from "react";

const App = () => {
  const [name, setName] = useState<string>("");

  const renders = useRef<number>(0);

  useEffect(() => {
    renders.current = renders.current + 1;            //Conta a quantidade de vezes que name é alterado
  });

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <p>Olá, {name}</p>
      <p>{renders.current}</p>
    </div>
  );
};

export default App;

Neste exemplo, o useRef vai guardar a quantidade de vezes que houver alguma alteração no input e o componente precisar ser renderizado

-------------- ###

-FOCUS usando useRef:

import { useState, useRef } from "react";

const App = () => {
  const [name, setName] = useState<string>("");

  const inputRef = useRef<HTMLInputElement | null>(null)

  const focusInput = () => {
    inputRef.current?.focus()
  }

  return (
    <div>
      <input 
        ref={inputRef}
        value={name} 
        onChange={(e) => setName(e.target.value)} />
      <button onClick={focusInput}>FOCUS INPUT</button>
    </div>
  )
}

export default App;

Ao clicar no botão, o focus irá para o input

-----------

-Para guardar o valor anterior de um componente usando o useRef:

import { useState, useEffect, useRef } from "react";

const App = () => {
  const [name, setName] = useState<string>("");

  const nomeAntigo = useRef<string | undefined>(undefined)

  useEffect(() => {
    nomeAntigo.current = name
  }, [name])

  return (
    <div>
      <input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      />
      <p>Nome atual: {name}</p>
      <p>Nome antigo: {nomeAntigo.current || ""}</p>
    </div>
  )
}

export default App;


//////////////////////////////////////////////////////////////// &&&
COMPONENT PROPS COM E SEM REF    React.ComponentProps<...>
VIDEO: https://www.youtube.com/embed/TPACABQTHvM

-Arquivo Button.tsx:

import React from 'react'

type ButtonProps = React.ComponentProps<'button'>             //OU type ButtonProps = React.ComponentPropsWithoutRef<'button'>

export default function Button({type, style, onClick}: ButtonProps) {

  return (
    <button type={type} style={style} onClick={onClick}>
      Clique aqui 
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  function handleClick(): void {
    alert("Clicou");
  }

  return (
    <>
      <Button 
        type="submit" 
        style={{backgroundColor: "red", color: "white"}} 
        onClick={handleClick} 
      />
    </>
  )
}

---------------------- %%%

-Arquiv Teste.tsx:

import React from 'react'

type TextoProps = React.ComponentProps<'h1'>               //OU type ButtonProps = React.ComponentPropsWithoutRef<'button'>

export default function Teste({className, style, id}: TextoProps) {

  return (
    <h1 style={style} className={className} id={id} >
      Clique aqui 
    </h1>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"
import "../src/index.css"

export default function App() {

  return (
    <>
      <Teste 
        style={{color: "red"}}
        className={"texto"}
        id={"textoID"}
      />
    </>
  )
}

¨¨¨¨
-Arquivo index.css:

.texto {
  font-size: 30px;
}

#textoID {
  font-family: 'Inter', sans-serif;
}

-------------------------------- ###
Usando Ref:


-Arquivo Button.tsx:

import React from 'react'

type ButtonProps = React.ComponentPropsWithRef<'button'>           //Ao invés de React.ComponentPropsWithoutRef<'button'> 

export default function Button({style}: ButtonProps) {

  return (
    <button style={style}>
      Clique aqui 
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"
import { useRef } from 'react';

export default function App() {
  
  const ref = useRef(null);

  return (
    <>
      <Button 
        ref={ref}
        style={{backgroundColor: "yellow", color: "red"}} 
      />
    </>
  )
}

------------------------------------------- ###
COM PROPS REST  ...rest

-Arquivo Teste.tsx:

import React from 'react'

type InputProps = React.ComponentProps<'input'>             //OU type InputProps = React.ComponentPropsWithoutRef<'input'>

export default function FormInput({type, ...rest}: InputProps) {

  return (
    <input type={type} {...rest} />
  )
}

¨¨¨¨
-Arquivo App.tsx:

import FormInput from "./components/Teste"

export default function App() {

  return ( 
    <FormInput 
      type="text"
      placeholder="Digite algo" 
      autoFocus={true}
      maxLength={10}
      required={true}
    />
  )
}




//////////////////////////////////////////////// &&&
FUSÃO DE TYPE COM INTERFACE (HERANÇA)

type Pessoa = {
  nome: string,
  idade: number,
}

interface Empregado extends Pessoa {
  cargo: string
}

-------

interface Personagem {
  nome: string,
  level: number
}

type Mago = Personagem & {
  magias: string[],
  mana: number
}

///////////////////////////////////////////////// &&&
PARTIAL UTILITY TYPE:   PARTIAL<T>

Transforma todas as propriedades em opcionais. Muito útil para formulários.
OBS: Vale para type e interface.

type Empregado = {
  cargo: string;
  salario: number;
}

type Pessoa  = {
  nome: string;
  idade: number;
}

function Mostrar(funcionario: Pessoa, info: Partial<Empregado>): string {
  return `${funcionario.nome} é ${info.cargo} e tem ${funcionario.idade} anos`
}

export default function App() {

  const funcionario = {
    nome: "João",
    idade: 30,
  } 

  const info = {
    cargo: "Desenvolvedor",
  }

  return (
    <div>
      <p>{Mostrar(funcionario, info)}</p>  
    </div>
  );
}

-O utility type Partial transformou as propriedades em type Empregado em opcionais: 

type Empregado = {
  cargo?: string;
  salario?: number;
}

---------------- ###
ATENÇÃO:

Partial não torna propriedades aninhadas em opcionais:

Partial<Pessoa>

type Pessoa = {
  id: string;         //Passou a ser opcional
  nome: string;       //Passou a ser opcional
  pais: {
    mae: string;      //Não passou a ser opcional
    pai: string;      //Não passou a ser opcional
  } 
}

----
Exemplo:

type Pessoa = {
  nome: string;
  idade: number;
  info: {
    cargo: string;
    salario: number;
  }
}

function Mostrar(funcionario: Partial<Pessoa>): string {
  return `${funcionario.nome} é ${funcionario.info.cargo} e tem ${funcionario.idade} anos`
}

export default function App() {

  const funcionario = {
    nome: "João",
    idade: 30,
    info: {
      cargo: "Desenvolvedor",              //Não está opcional
    }
  } 

  return (
    <div>
      <p>{Mostrar(funcionario)}</p>            //Está faltando passar o salario pois não está opcional
    </div>
  );
}

-Não conseguirá acessar os dados dentro de info (cargo e desenvolvedor) se colocar Partial em propriedades aninhadas


--------------- ###

type User = {
  id: string;
  nome: string;
  email: string;
}

function updateSemPartial(       //Sem Partial
  userId: string,
  userInfo: {
    id?: string;
    nome?: string;
    email?: string;
  }){
  //instrução dentro da função
}

function updateComPartial(userId: string, userInfo: Partial<User>) {
  //instrução dentro da função
}

///////////////////////////////////////////////////////////////////// &&& 
REQUIRED UTILITY TYPE       REQUIRED<T>

É um utility type que faz o oposto de Partial. Ele torna as propriedades de um type obrigatórias de serem passadas.
OBS: Vale para type e interface.

type Empregado = {
  cargo?: string;                //opcional
  salario?: number;              //opcional
}

type Pessoa  = {
  nome: string;
  idade: number;
}

function Mostrar(funcionario: Pessoa, info: Required<Empregado>): string {         //É obrigatório passar cargo e salario
  return `${funcionario.nome} é ${info.cargo} e tem ${funcionario.idade} anos`
}

export default function App() {

  const funcionario = {
    nome: "João",
    idade: 30,
  } 

  const info = {
    cargo: "Desenvolvedor",               //Não é mais opcional 
    salario: 2000,                        //Não é mais opcional
  }

  return (
    <div>
      <p>{Mostrar(funcionario, info)}</p>  
    </div>
  );
}

-O utility type Required transformou as propriedades em type Empregado que antes eram opcionais em obrigatórias de serem passadas como parametros. 

----------- %%%

Required<Pessoa> 

function Mostrar(funcionario: Required<Pessoa>): string {         
  return `${funcionario.nome} tem ${funcionario.idade} anos`
}

é o equivalente a:

function Mostrar(funcionario: Pessoa): string {         
  return `${funcionario.nome!} tem ${funcionario.idade!} anos`
}

! passa por cima do typescript, ditando que será obrigatório passar os valores. Portanto, é melhor usar Required<T>

///////////////////////////////////////////////////////////////////// &&& 
READONLY UTILITY TYPE     Readonly<T>

Transforma todas as propriedades de uma interface ou type em readonly.
OBS: Vale para type e interface.

interface Empregado {
  cargo: string;
  salario: number;
}

interface Pessoa {
  nome: string;
  idade: number;
}

function Mostrar(funcionario: Pessoa, info: Readonly<Empregado>): string {
  return `${funcionario.nome} é ${info.cargo} e tem ${funcionario.idade} anos`
}

export default function App() {

  const funcionario = {
    nome: "João",
    idade: 30,
  } 

  let info = {
    cargo: "Desenvolvedor",
    salario: 2000,
  }

  info = {                       //ERRO!!! Os campos da interface Empregado são readonly e não podem ser alterados
    cargo: "Gerente",
    salario: 3000,
  }

  return (
    <div>
      <p>{Mostrar(funcionario, info)}</p>  
    </div>
  );
}

-Isso é o mesmo que:

interface Empregado {
  readonly cargo: string;
  readonly salario: number;
}

//////////////////////////////////////////////////// &&& 
PICK UTILITY TYPE     Pick<Type, Key>

Cria um novo tipo selecionando um subset de propriedades de um tipo já existente.

interface Produto {
  id: number;
  nome: string;
  preco: number;
  marca: string;
  descricao: string;
  categoria: string;
}

type ResumoProduto = Pick<Produto, "nome" | "preco" | "marca">

function Mostrar(lista: ResumoProduto[]) {
  return lista[0].nome
}

export default function App() {

  const lista: ResumoProduto[] = [
    {nome: "TV", preco: 2000, marca: "Sharp"},
    {nome: "Laptop", preco: 3500, marca: "Dell"},
  ]

  return (
    <div>
      {Mostrar(lista)}
    </div>
  );
}

>>> TV

------------------------------ ###

interface Pessoa {
  nome: string;
  idade: number;
  cargo: string;
  tel: number;
  email: string;
}

type ResumoPessoa = Pick<Pessoa, "nome" | "idade" | "cargo">

export default function App() {

  const funcionarios: ResumoPessoa[] = [
    {nome: "Carlos", idade: 33, cargo: "Gerente"},
    {nome: "Maria", idade: 25, cargo: "Desenvolvedora"},
    {nome: "Pedro", idade: 35, cargo: "Faxineiro"},
  ]

  return (
    <div>
      {funcionarios.map ((funcionario) => (
        <div key={funcionario.nome}>
          <p>Nome: {funcionario.nome}</p>
          <p>Idade: {funcionario.idade}</p>
          <p>Cargo: {funcionario.cargo}</p>
          <hr />
        </div>
      ))}
    </div>
  );
}

//////////////////////////////////////////////////// &&& 
OMIT UTILITY TYPE     Omit<Type, Key>

É o oposto de Pick.
Omite propriedades de um tipo já existente. Útil para omitir certos dados de um usuário no banco de dados, como senha, passwordhash, timestamp, createdAt, updateAt, etc.

interface Produto {
  id: number;
  nome: string;
  preco: number;
  marca: string;
  descricao: string;
  categoria: string;
}

type ResumoProduto = Omit<Produto, "id" | "descricao" | "categoria">

function Mostrar(): void {

  const lista: ResumoProduto = {
    nome: "TV", 
    preco: 2000, 
    marca: "Sharp",
  }

  console.log(lista)
}

export default function App() {

  return (
    <div>
      <button onClick={Mostrar}>CLIQUE</button>
    </div>
  );
}

>>> Object {nome: "TV", preco: 2000, marca: "Sharp"}

------------------

interface Pessoa {
  nome: string;
  idade: number;
  senha: string;
}

type PessoaSemSenha = Omit<Pessoa, "senha">;

const usuario: PessoaSemSenha = {
  nome: "Pedro",
  idade: 30,
};

export default function App() {
  return (
    <p>{usuario.nome} tem {usuario.idade} anos.</p>
  );
}

>>> Pedro tem 30 anos.

------------------------------ ###

type User = {
  sessionId: string;
  name: string;
}

type Guest = Omit<User, "name">;

///////////////////////////////////////////////////////////////////// &&& 
LIDANDO COM TIPOS DE VARIAVEIS INCERTAS EM FUNÇÕES

Modo javascript:

const printID = (id) => {
  console.log("ID: " + id);
};

printID("123");        //OU printID(123);   
>>> ID: 123

-----

Modo typescript:

const printID = (id: number) => {      
  console.log("ID: " + id);
};

printID(123);   
>>> ID: 123

OU

const printID = (id: string) => {      
  console.log("ID: " + id);
};

printID("123");   
>>> ID: 123

//////////////////////////////////////////////// &&& ###
UNION
Aceita um tipo ou outro tipo

Porém, e se não souber qual tipo de dados virá para o parâmetro?
É possível usar o | (significa ou) para resolver o problema:

const printID = (id: string | number) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");       
>>> ID: 123

------
Colocando as opções de tipos em uma variavel: (type alias)

type TiposDeID = string | number;

const printID = (id: TiposDeID) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");
>>> ID: 123

///////////////////////////////////////////////// &&& 
INTERSECTIONS 

type Pessoa = {
  nome: string,
  idade: number,
}

type Empregado = {
  cargo: string,
  salario: number,
}

type Trabalhador = Pessoa & Empregado

function Mostrar(funcionario: Trabalhador): string | number {
  return funcionario.idade
}

export default function App() {

  const funcionario: Trabalhador = {
    nome: "Maria",
    idade: 33,
    cargo: "Gerente",
    salario: 2000
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

-------------------- 
Outra forma:

type 

type Pessoa = {
  nome: string,
  idade: number,
}

type Empregado = Pessoa & {
  cargo: string,
  salario: number,
}

--------------------------------- ###
Para juntar os campos de mais de uma interface:

interface Dados1 {
  nome: string;
}

interface Dados2 {
  idade: number;
}

type TodosDados = Dados1 & Dados2;

function Mostrar(pessoa: TodosDados): void {
  console.log(`${pessoa.nome} tem ${pessoa.idade} anos`)
}

export default function App() {

  const pessoa: TodosDados = {
    nome: "Carlos", 
    idade: 32
  }

  return (
    <div>
      <button onClick={() => Mostrar(pessoa)}>CLIQUE</button>
    </div>
  );
}

------------------------------------------------ ###
INTERSECTION DE TIPOS INCOMPATÍVEIS
(Interseção de campos com tipos repetidos)

type Pessoa = {
  nome: string,
  idade: number,
}

type Empregado = {
  nome: string,
  cargo: string,
  setor: string,
}

type Funcionario = Pessoa & Empregado

Irá fundir as propriedades dos dois tipos e ignorar os repetidos

Type Funcionario = {
  nome: string,
  idade: number,
  cargo: string,
  setor: string,  
}

------------------- ###
Mas e o que acontece se fundirmos 2 tipos com nomes iguais e tipos diferentes?

type Pessoa = {
  nome: "Carlos" | "Daniel",
  idade: number,
}

type Empregado = {
  nome: "Maria" | "Ana",
  cargo: string,
  setor: string,
}

type Funcionario = Pessoa & Empregado

Ao fundir as 2 propriedades nome com tipos diferentes, eles se tornam um tipo Never (não possuem uma condição de checagem if)

type Pessoa = {
  nome: string,
  idade: number,
}

type Empregado = {
  nome: number
  cargo: string,
  salario: number,
}

type Trabalhador = Pessoa & Empregado

const funcionario: Trabalhador = {
  nome: "Maria",                          //Erro: Type 'string' is not assignable to type 'never'.
  idade: 33,
  cargo: "Gerente",
  salario: 2000
}

--------------
Uma forma de resolver isso, seria colocar a interseção como um objeto:

type Pessoa = {
  nome: string,
}

type Empregado = {
  nome: number,
}

type Trabalhador = {
  tipoPessoa: Pessoa, 
  tipoEmpregado: Empregado
}

function Mostrar(funcionario: Trabalhador) {
  return funcionario.tipoPessoa.nome
}

export default function App() {

  const funcionario: Trabalhador = {
    tipoPessoa: {nome: "Maria"},
    tipoEmpregado: {nome: 398}
  }

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

///////////////////////////////////////////////////////////////// &&&
NEVER TYPE
Representa valores que não possuem uma condição if própria na função.
Usado para quando esquecer de colocar uma condição if.

function handleStatusCode (code: 200 | 404 | 500) {
  if (code === 200) {
    console.log("OK")
    return;
  }
  if(code === 404) {
    console.log("Not Found")
    return;
  }
  const err: never = code;      //Caso não seja 200 ou 404  
  return err;
}

export default function App() {

  return (
    <div>
      {handleStatusCode(500)}
    </div>
  );
}

>>> 500

No exemplo acima, a variável err dará erro no typescript, indicando que está faltando alguma condição e mostrará qual valor foi passado como parâmetro da função.
Caso complete as condições if, o erro sumirá:

function handleStatusCode (code: 200 | 404 | 500) {
  if (code === 200) {
    console.log("OK")
    return;
  }
  if(code === 404) {
    console.log("Not Found")
    return;
  }
  if(code === 500) {
    console.log("Internal Server Error")
    return;
  }
  const err: never = code;                   //Não mostrará erro no typescript
  return err;
}

---------------- %%%

type Turno = "manhã" | "tarde" | "noite"

const msg1 = "Bom dia"
const msg2 = "Boa tarde"
const msg3 = "Boa noite"

function handleMsg (msg: Turno) {
  if (msg === "manhã") {
    console.log(msg1)
  }
  if (msg === "tarde") {
    console.log(msg2)
  }
  const err: never = msg;                                   //Variável err indicará erro no typescript
  console.log("O valor passado como parametro foi: " + err);
}

export default function App() {

  return (
    <div>
      <button onClick={() => handleMsg("noite")}>CLIQUE</button>
    </div>
  );
}

>>> O valor passado como parametro foi: noite

-------------------------------- ###
Outra forma:
(quebrará a página, mas mostrará a mensagem de erro no console)

function handleStatusCode (code: 200 | 404 | 500) {
  if (code === 200) {
    return "OK";
  }
  if(code === 404) {
    return "Not Found";
  }
  throw new Error("Unknown status code " + code satisfies never)
}

export default function App() {

  return (
    <div>
      {handleStatusCode(500)}
    </div>
  );
}

>>> ERRO!!!

//////////////////////////////////////////////////////////////// &&&
INTERSECTION vs UNION

Union: (OU)
-Usa o símbolo |
-Abrange mais o resultado de tipos (mais valores possíveis)

Intersection: (E)
-Usa o símbolo & 
-Estreita mais o resultado de tipos (menos valores possíveis)

type Humano = {
  nome: string,
  idade: number
}

type Elfo = {
  nome: string,
  orelhas: "pontudas"
}

type HumanoElfo = Humano & Elfo              //Terá nome, idade e orelhas pontudas

type humanoOUelfo = Humano | Elfo            //Tem que ter nome

////////////////////////////////////////////////////////////////&&& 
PARAMETROS OPCIONAIS (?) EM FUNÇÕES

Ao colocar ? no parametro, ele automaticamente passa a aceitar o tipo undefined também.

function pessoa(nome: string, sobrenome?: string): string {
  if (sobrenome) {
    return `Olá, ${nome} ${sobrenome}.`;
  }
  return `Olá, ${nome}.`
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("João")}</h1>
    </div>
  )
}

Atenção!!!
O parâmetro opcional NUNCA pode ser o primeiro a ser passado! Por exemplo:

function pessoa(sobrenome?: string, nome: string): string {
  ...
}

Os parâmetros opcionais serão sempre os últimos a serem passados.

/////////////////////////////////////////////////////// ### &&&
DEFAULT PARAMS (PARAMETROS INICIAIS) EM FUNÇÕES

function pessoa(nome: string, sobrenome: string = "Sem nome"): string {
  return `Nome: ${nome} - Sobrenome: ${sobrenome}.`;
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("João")}</h1>
    </div>
  )
}

---------
Não é necessário especificar o tipo da variavel se declarar um valor inicial para ela

function Texto (txt = "Texto de exemplo"): void {
  alert(txt)
}

export default function App() {
  return (
    <div>
      <button onClick={() => Texto()}>Clique aqui</button>
    </div>
  )
}

/////////////////////////////////////////////// &&&
PARAMETROS LITERAIS EM FUNÇÕES

function pessoa(nome: "João") {
  if(nome === "João") {
    return `Olá, ${nome}.`;
  }
  return "Nome inválido!"
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("Carlos")}</h1>
    </div>
  )
}

Dará Nome inválido pois foi especificado que a variavel nome só pode aceitar o valor João.
O typescript apresentará um erro sinalizando que o valor passado é diferente do especificado.

É possível declarar mais de um tipo de valor para o parametro:

function pessoa(nome: "João" | "Carlos") {
  if(nome === "João") {
    return `Olá, ${nome}.`;
  }
  return "Nome inválido!"
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("Carlos")}</h1>
    </div>
  )
}

>>> Olá, Carlos.

------------------------ ###
Armazenando em um type alias:

type Direction = "norte" | "sul" | "leste" | "oeste"

function Mover(caminho: Direction) {
  alert(`Foi para a direção ${caminho}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => Mover("norte")}>Mover</button>  
    </div>
  )
}

---------

type Prioridade = 1 | 2 | 3

function setPrioridade (nivel: Prioridade) {
  switch(nivel) {
    case 1 : {
      return alert("Prioridade baixa")
    }
    case 2 : {
      return alert("Prioridade média")
    }
    case 3 : {
      return alert("Prioridade alta")
    }
    default:
      return alert("Prioridade não estabelecida")
  }
}

export default function App() {
  return (
    <div>
      <button onClick={() => setPrioridade(3)}>Enviar</button>  
    </div>
  )
}

---------------------------- ###
SUPER UNION TYPE ALIAS

type estadoCivil = "casado" | "solteiro" | "divorciado" | string

function handleClick(status: estadoCivil) {
  alert(`Fulano é ${status}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick("viúvo")}>Enviar</button>  
    </div>
  )
}

------------------------------- ###
TEMPLATE LITERAL UNIONS
juntar mais de 1 type alias

type Sobrenome = "Silva" | "Souza" | "Costa"
type Nome = `Carlos ${Sobrenome}`

function handleClick(username: Nome) {
  alert(`Olá, ${username}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick("Carlos Silva")}>Enviar</button>  
    </div>
  )
}

OBS: Cuidado com muitos tipos de template unions pois pode causar erro devido a quantidade gigante de variações que o sistema terá que guardar.

//////////////////////////////////////////////// &&& ###
ARRAYS

Criando variaveis:

let ids: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Ana", "Bruno", "Carlos"];
let ArrayVariado: any[] = ["pedro", 0, true];

-----
O tipo any evolve com o passar de informações em arrays:

let lista = []      // lista: any[]
lista.push(3)       // lista: number[]
lista.push("A")     // lista: (number | string)[]

/////////////////////////////////////////////// &&&
ARRAYS HETEROGENEOS

function handleClick(elementos: string | number) {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista = [1, 2, "A", "B"]       //Typescript irá inferir que é um tipo (string | number)[]
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}


¨¨¨¨ //Forma correta

function handleClick(elementos: (string | number)[]) {         
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista = [1, 2, "A", "B"]       
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}

OU

function handleClick(elementos: (string | number)[]) {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista: (string | number)[] = [1, 2, "A", "B"]     
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}

/////////////////////////////////////////////// &&&
ARRAYS EM PARAMETROS DE FUNÇÕES

Recebendo um array como parametro de uma função:

const printID = (id: number[]): void => {      
  console.log("IDs: " + id);
};

printID([1, 2, 3]); 
>>> IDs: 1,2,3

---------------- ###

function handleClick(frutas: string[]): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}

export default function App() {
  const frutas = ["Banana", "Uva", "Morango"]

  return (
    <div>
      <button onClick={() => handleClick(frutas)}>Enviar</button>  
    </div>
  )
}

--------------- ###

Arrays dentro de arrays também é válido:

function handleClick(cidades: string[][]): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

export default function App() {
  const cidades = [["RJ", "Rio de Janeiro"], ["SP", "São Paulo"], ["MG", "Belo Horizonte"]]

  return (
    <div>
      <button onClick={() => handleClick(cidades)}>Enviar</button>  
    </div>
  )
}

-------------------- ###
Usando junto com UNION:

function handleClick(elementos: (string | number)[]): void {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const elementos = ["Casa", 18, "Morango", 13]

  return (
    <div>
      <button onClick={() => handleClick(elementos)}>Enviar</button>  
    </div>
  )
}

--------------------- ###

function averageScore(ratings: number[]): void {
  if (ratings.length === 0) return 0
  const soma: number = ratings.reduce((sum, rating) => sum + rating, 0) 
  alert(soma / ratings.length)
}

export default function App() {
  const ratings = [7, 11, 42]

  return (
    <div>
      <button onClick={() => averageScore(ratings)}>Enviar</button>  
    </div>
  )
}

>>> 20       (7 + 11 + 42 dividido por 3)

////////////////////////////////////////////////////////////////////// &&&
ARRAYS COM PROPS

-Arquivo Teste.tsx:

interface Pessoa {                        //OU type Pessoa = {nomes: string[]}          
  nomes: string[];
}

export default function Teste({nomes}: Pessoa) {
  return (
    <div>
      {nomes[0]}, {nomes[1]}, {nomes[2]}
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nomes={["Maria", "Carlos", "João"]} />
    </>
  )
}

>>> Maria, Carlos, João

-------------------------- %%%

-Arquivo Teste.tsx:

interface Pessoa {                        //OU type Pessoa = {nomes: string[]}          
  nomes: string[];
}

export default function Teste({nomes}: Pessoa) {
  return (
    <div>
      {nomes.map((nome) => (
        <div key={nome}>
          <p>{nome}</p>
        </div>
      ))}
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nomes={["Maria", "Carlos", "João"]} />
    </>
  )
}

>>> Maria
>>> Carlos
>>> João


//////////////////////////////////////////////////// &&&
READONLY ARRAYS (NÃO PODEM SER MODIFICADOS)

const cores = ["azul", "verde", "roxo"] as const             //cores passa a ser readonly e não pode ser modificado

cores.push("laranja")                                        //Mostrará erro no typescript

---------------------- ###
Para especificar qual array é:

const buttonTextOptions = [
  "Clique aqui",
  "Enviar",
  "Resetar",
] as const;

export default function Button() {
  return (
    <button>
      {buttonTextOptions.map((option) => {
        return option;
      })}
    </button>
  )
}

No exemplo acima, option só poderá ser os elementos do array buttonTextOptions:
option[0] = "Clique aqui"
option[1] = "Enviar"
option[2] = "Resetar"

/////////////////////////////////////////////// &&&
TYPE PARAMETERS PARA ARRAYS COMO PARAMETROS EM FUNÇÔES

É um modo genérico de indicar o tipo de um array em uma função

function handleClick(frutas: Array<string>): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}

export default function App() {
  const frutas = ["Banana", "Uva", "Morango"]

  return (
    <div>
      <button onClick={() => handleClick(frutas)}>Enviar</button>  
    </div>
  )
}


É o mesmo que:

function handleClick(frutas: string[]): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}
...

------------- ###

Arrays dentro de arrays também é válido:

function handleClick(cidades: Array<Array<string>>): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

É o mesmo que:

function handleClick(cidades: string[][]): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

const cidades = [["RJ", "Rio de Janeiro"], ["SP", "São Paulo"], ["MG", "Belo Horizonte"]]

handleClick(cidades)

///////////////////////////////////////////////&&&
REST PARAMETERS EM FUNÇÕES (PARÂMETROS REST) ...REST

Permite um número indefinido de argumentos:

function Mostrar(...pessoas: string[]) {
  return `${pessoas.join(", ")}`;
}

export default function App() {
  return (
    <div>
      <p>{Mostrar("Maria", "Carlos", "Ana")}</p>
    </div>
  )
}

OU

function Mostrar(...pessoas: string[]) {
  pessoas.map(pessoa => {
    console.log(pessoa)
  })
}

export default function App() {
  return (
    <div>
      <button onClick={() => Mostrar("Maria", "Carlos", "Ana")}>Mostrar</button>
    </div>
  )
}

¨¨¨¨

function Mostrar(empresa: string, ...funcionario: string[]) {
  return `Empresa: ${empresa} - Funcionarios: ${funcionario.join(", ")}`;
}

export default function App() {
  return (
    <div>
      <p>{Mostrar("Santander", "Maria", "Carlos", "Ana")}</p>
    </div>
  )
}

///////////////////////////////////////////////&&& 
OBJETOS EM FUNÇÕES

Type alias para objetos literais:

type Pessoa = {
  nome: string;
  idade: number;
}

OU

type Pessoa = {
  nome: string,
  idade: number,
}

OU

type Pessoa = {
  nome: string
  idade: number
}

¨¨¨¨
Atenção!!! 
Não pode:

type Pessoa = {
  nome: string idade: number      //ERRADO!
}

type Pessoa = {
  nome: string , idade: number      //CORRETO!
}

type Pessoa = {
  nome: string ; idade: number      //CORRETO!
}

type Pessoa = {
  nome: string ; idade: number , status: boolean      //CORRETO!
}

------------------------ ###

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.nome);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "João", 
    idade: 33
  };
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

------------------------ ###
Propriedades/Campos extras em objetos como parametros:

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 33, 
    status: "Casada",
  }
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

-Irá imprimir o resultado, mas o typescript apontará erro pois não existe status no type Pessoa

--------

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  return (
    <div>
      <button onClick={() => handleClick({nome: "Maria", idade: 33, status: "Casada" })}>CLIQUE</button>
    </div>
  );
}

-Irá imprimir o resultado, mas o typescript apontará erro pois não existe status no type Pessoa
(NO TYPESCRIPT PURO DARÁ ERRO!!!)

-------------------------------------------- ###
PARAMETROS OPCIONAIS (?) EM OBJETOS EM FUNÇÕES

type Pessoa = {
  nome: string;
  idade: number;
  status?: string;           //Parametro opcional. É o equivalente a:    string | undefined
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 33, 
  }
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

-Se pedisse para mostrar funcionario.status, daria undefined

--------------------------------------- ###
Type Alias em objetos vazios:

const pessoa = {}
pessoa.nome = "Maria"     // Dará erro

let pessoa = {}
pessoa = "Maria"          // OK

----------

function handleClick() {
  let pessoa = {};
  pessoa = "João";
  console.log(pessoa);
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick()}>CLIQUE</button>
    </div>
  );
}

------------------------------------------- ###
DISCRINATED UNIONS EM OBJETOS

type RJ = {
  ddd: 21;
  sigla: string;
  capital: string;
}

type SP = {
  ddd: 11;
  sigla: string;
  capital: string;
}

type Estados = RJ | SP;

function handleClick(estado: Estados): void {
  console.log(estado.capital);
}

export default function App() {

  const rio: Estados = {
    ddd: 21,                       //Só aceitará 11 ou 21
    sigla: "RJ",
    capital: "Rio de Janeiro"
  }

  return (
    <div>
      <button onClick={() => handleClick(rio)}>CLIQUE</button>
    </div>
  );
}

---------------- %%%

type RJ = {
  ddd: 21;
  sigla: string;
  capital: string;
}

type SP = {
  ddd: 11;
  sigla: string;
  capital: string;
}

type Estados = RJ | SP;

function Mostrar(estado: Estados): string {
  switch (estado.ddd){
    case (11):
      return "São Paulo"
    case (21):
      return "Rio de Janeiro"
    default:
      return "Outro estado"
  }
}

export default function App() {

  const rio: Estados = {
    ddd: 21,                       
    sigla: "RJ",
    capital: "Rio de Janeiro"
  }

  return (
    <div>
      <h1>{Mostrar(rio)}</h1>
    </div>
  );
}

------------------ %%%

Union em objetos pode ser usado ao tratar reultados de busca de dados de uma API, por exemplo:

type Loading = {status: "loading"}
type Error = {status: "loading"; error: number}
type Success = {status: "loading"; data: string}

type Result = Loading | Error | Success;

------------------------------------------------- ### &&&
SETS EM OBJETOS
Sets = coleção de valores únicos


function Mostrar(): string {
  const pessoa = new Set<string>(["Maria", "João"]);
  pessoa.add("Pedro");
  pessoa.delete("João");
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Maria, Pedro

---------------- %%%

function Mostrar(): string {
  const pessoa = new Set<string>();               //Set vazio
  pessoa.add("Pedro");                            
  pessoa.add("Maria");
  pessoa.add("Pedro");                              //O Set ignora objetos já existentes
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Pedro, Maria

---------------- %%%

Com Set, usamos:

objeto.add() = para adicionar
objeto.delete() = para remover
objeto.size = para saber o tamanho

---------------- %%%

Não consegui fazer funcionar passando o set como parâmetro.
Então faria da forma normal mesmo:

function Mostrar(pessoas: string[]): void {
  pessoas.forEach((pessoa: string) => {
    console.log(pessoa)
  })
}

export default function App() {

  const pessoas: Pessoas = ["Maria", "João"];
  pessoas.push("Pedro");
  pessoas.splice(pessoas.indexOf("João"), 1);

  return (
    <div>
      <button onClick={() => Mostrar(pessoas)}>CLIQUE</button>
    </div>
  );
}

OU

function Mostrar(pessoas: string[]): void {
  pessoas.forEach((pessoa: string) => {
    console.log(pessoa)
  })
}

export default function App() {

  const pessoas = ["Maria", "João"];
  pessoas.push("Pedro");
  pessoas.splice(pessoas.indexOf("João"), 1);

  return (
    <div>
      <button onClick={() => Mostrar(pessoas)}>CLIQUE</button>
    </div>
  );
}

--------------- %%%
Set aceitando mais de 1 tipo:

function Mostrar(): string {
  const pessoa = new Set<string | number>();
  pessoa.add("Pedro");
  pessoa.add(13);
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Pedro, 13


--------------------------------------------------- ### &&&
MAPS COM OBJETOS

const objeto = new Map<string, number>(key, value)

objeto.set("Chave", 1)

Obs: A key é usada para identificar o objeto. É com ela que deletamos um objeto.

------------- %%%

Caso seja informado um valor inicial para o map, não é preciso especificar o tipo da key e do value:

const objeto = new Map([["Chave1", "Valor1"]])            //Typescript entendeu que o tipo será <string, string>

------------ %%%

function Mostrar(): string {
  const pessoa = new Map<string, string>();
  pessoa.set("Pedro", " 20 anos");
  pessoa.set("Maria", " 25 anos");
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Pedro, 20 anos - Maria, 25 anos

-------------- %%%

function Mostrar(): string {
  const pessoa = new Map([["João", 15]]);             //Typescript entende que será <string, number>
  pessoa.set("Pedro", 13);
  pessoa.set("Maria", 19);
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> João,15 - Pedro,13 - Maria,19

---------------- %%%

function Mostrar(): string {
  const pessoa = new Map([["Carlos", "18 anos"]]);             //tipo <string, string>
  pessoa.set("Pedro", " 20 anos");
  pessoa.set("Maria", " 25 anos");
  pessoa.set("Carlos", " 18 anos");                  //O Map ignora objetos já existentes
  pessoa.delete("Pedro")
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Carlos, 18 anos - Maria, 25 anos

-------------------------------------------- ### &&&
DYNAMIC KEYS COM OBJETOS 
(Chaves dinâmicas que podem ser strings ou numeros)

type Pessoa = {
  [chave: string]: number;                          //chave de qualquer tipo e valor do tipo number
}

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.idade);                   //imprime a chave do tipo string
  console.log(funcionario[75]);                     //imprime a chave do tipo number
  //console.log(funcionario.nome);                  //Dará erro
}

export default function App() {

  const funcionario: Pessoa = {
    idade: 33,                                      //chave do tipo string
    75: 22,                                         //chave do tipo number
    //nome: "Carlos",                               //Dará erro pois o valor precisa ser number
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

--------------------------- %%%

type Pessoa = {
  [chave: string]: number;                          
}

function Mostrar(funcionario: Pessoa): void {
  funcionario["idade"] = 18                      //Alterou o valor de idade
  console.log(funcionario.idade);                   
}

export default function App() {

  const funcionario: Pessoa = {
    idade: 33,  
    cpf: 12345678900,
    tel: 21998765432                                      
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

>>> 18

---------------------------------------------- ### &&&
RECORD UTILITY TYPE        Record<Key, Type>

Para poder adicionar quantas propriedades (key, valor) quiser em um type.

type Pessoa = Record<string, number>

É o mesmo que:

type Pessoa = {
  [chave: string]: number;                    //Dynamic key        
}

------------ %%%

type Pessoa = Record<string, number>

export default function App() {

  const funcionario: Pessoa = {
    "Carlos": 33,
    "Maria": 24,
    "Pedro": 19
  }

  funcionario["José"] = 41       //Adicionando um novo funcionario

  return (
    <div>
      {funcionario["Carlos"]}
    </div>
  );
}

>>> 33

-No exemplo acima, só aceitará o padrão <string, number> portanto não seria possível:
funcionario["José"] = "Casado"      // <string, string>

----------------- %%%

type Pessoa = Record<string, string>

function Mostrar(funcionario: Pessoa) {
  return funcionario.nome
}

export default function App() {

  const funcionario: Pessoa = {
    "nome": "Carlos",
    "idade": "24 anos",
    "status": "Casado"
  } 

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

>>> Carlos

------------------- %%%

type Nivel = 1 | 50 | 100 
type Status = Record<Nivel, string>

const alerta: Status = {
  1: "baixo",
  50: "médio",
  100: "alto"
}

------------------- %%% &&&

type HttpStatusCode = 200 | 201 | 400 | 401 | 403 | 404 | 500;

const statusMessage: Record<HttpStatusCode, string> = {
  200: "OK",
  201: "Created",
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  500: "Internal Server Error"
};

function getStatusMessage(code: HttpStatusCode): string {
  return statusMessages[code];
};

console.log(getStatusMessage(404));

>>> "Not Found"

------------------ %%%

type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette: Record<Colors, string | RGB> = {
    red: [255, 0, 0],
    green: "#00ff00",
    bleu: [0, 0, 255]
};


------------------------------------- ### &&&
OBJETOS
DYNAMIC DEFAULT PROPERTIES
(Utilize com cuidado este tipo de abordagem, pois provavelmente deve haver uma maneira melhor de lidar com este caso.)

Além de chaves dinâmicas, é possível incluir outros tipo de propriedades:

type Pessoa = {
  [campoextra: string]: string, 
  nome: string,
  idade: number,
}

-----

type FormData = {
  [field: string]: string, 
  email: string,
  password: string,
}

-----

type FormData = {
  [field: string]: string | number | boolean, 
  email: string,
  password: string,
  age: number
}

--------------------------------------------- ### &&&
OBJETOS
PROPERTY KEYS
(raramente usado)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

type PropertyKey = string | number | symbol

----

type Tags = {
  [key: string]: any,
}

const server: Tags = {
  name: "Jane's server",
  1: 420,
  [Symbol("role")]: "Admin"
}

----------------------------------------------- ### &&&
OBJETOS
READONLY MODIFIER

Parecido com const em Javascript, fazendo com que um objeto possa apenas ser lido e não alterado

type Pessoa = {
  readonly nome: string,      //Não pode ser modificado
  idade: number,              //Pode ser modificado
}

---------

type Pessoa = {
  readonly nome: string,      
  idade: number,              
}

function Mostrar(funcionario: Pessoa): void {
  funcionario.nome = "Maria";                                  //Typescript dará erro apontando que não pode modificar 
  funcionario.idade = 26;                                      //OK. Pode ser modificado
  console.log(funcionario.nome + " - " + funcionario.idade);                   
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "João",
    idade: 25
  }
  
  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------------------------------------- ### &&&
OBJETOS QUE NÃO MODEM SER MODIFICADOS
AS CONST 

Parecido com as const com arrays:

const cores = ["azul", "verde", "roxo"] as const             //cores passa a ser readonly e não pode ser modificado

cores.push("laranja")                                        //Mostrará erro no typescript

----------

Com objetos:

type Pessoa = {
  nome: string,
  idade: number,
} 

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)              
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 23,
  } as const;                             //objeto passa a ser readonly

  funcionario = {                         // ERRO!!! funcionario não pode ser modificado
    nome: "Carlos",
    idade: 51,
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------------------------------------- ### &&&
OBJETOS QUE NÃO MODEM SER MODIFICADOS
OBJECT.FREEZE

type Pessoa = {
  nome: string,
  idade: number,
  setor: {
    cargo: string,
    turno: string,
  }
} 

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.setor.cargo)              
}

export default function App() {

  const funcionario = Object.freeze({          //objeto passa a ser readonly
    nome: "Maria",
    idade: 23,
    setor: {
      cargo: "Auxiliar",
      turno: "Manhã",
    }
  });                                      

  funcionario = {                              // ERRO!!! funcionario não pode ser modificado
    nome: "Carlos",
    idade: 51,
    setor: {
      cargo: "Fiscal",
      turno: "Tarde",
    }
  }

  funcionario.setor.cargo = "Gerente"                 //OK, pois nested properties não são congelados

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

>>> Gerente

----------------

Object.freeze não permite modificar o objeto, mas é possível modificar ou incluir (com push) elementos aninhados dentro do objeto.

type Pessoa = {
  nomes: string[]
} 

function Mostrar(funcionario: Pessoa): void {
  funcionario.nomes.map((nome) => console.log(nome))         
}

export default function App() {

  const funcionario = Object.freeze({  
    nomes: ["Maria", "Carlos", "João"]
  });                                      

  funcionario.nomes.push("Pedro")                        

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

------------------------------------------------------------ ###
SATISFIES
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1


type Pessoa = {
  nome: string;
  idade: number;
};

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)        
}

export default function App() {

  const funcionario = {
    nome: "Maria",
    idade: 33
  } satisfies Pessoa

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

-----------------

type Pessoa = {
  [key: string]: string | number | boolean
};

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)        
}

export default function App() {

  const funcionario = {
    nome: "Maria",
    idade: 33,
    status: true
    10: "dez"
  } satisfies Pessoa

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

-----------------

type Pessoa = "nome" | "idade" | "status"; 

function Mostrar(nome: string, idade: string): void {
  console.log(`${nome} tem ${idade}`)        
}

export default function App() {

  const funcionario = {
    nome: "Maria",
    idade: "33 anos",
    status: "Casada"
  } satisfies Record<Pessoa, string>

  return (
    <div>
      <button onClick={() => Mostrar(funcionario.nome, funcionario.idade)}>CLIQUE</button>
    </div>
  );
}


-----------------

type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette = {
    red: [255, 0, 0],
    green: "#00ff00",
    bleu: [0, 0, 255]
} satisfies Record<Colors, string | RGB>;


---------------- %%%
Usando em conjunto com as const:

type Pessoa = {
  nome: string,
}

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)        
}

export default function App() {

  const funcionario = {
    nome: "Maria",
  } as const satisfies Pessoa   

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

Se tentar mudar o valor de nome, dará erro pois é apenas readonly. Ex:
funcionario.nome = "João"

---------------

O valor só pode ser o estabelecido (no caso, string). Ex:

type Pessoa = {
  nome: string,
}

const funcionario = {
  nome: 32,                       // ERRO!
} as const satisfies Pessoa  

---------------

type Pessoa = {
  nome: string,
  idade: number,
}

const funcionario = {
  nome: "Maria",                       // ERRO, pois estpa faltando o campo idade
} as const satisfies Pessoa  

------------------ %%%
Muito útil para quando quiser incluir novos campos em um objeto, usando em conjunto com dynamic keys:

type Pessoa = {
  nome: string,
  [key: string]: string | number
}

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.cargo)        
}

export default function App() {

  const funcionario = {
    nome: "Maria",
    idade: 29,
    salario: 10000,
    cargo: "Desenvolvedora"
  } as const satisfies Pessoa   

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

--------------------------------------------------- ### &&&
OBJETOS
FUNCTION OVERLOAD
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

type Pessoa = {
  nome: string;
  sobrenome: string;
}

function Mostrar(funcionario: Pessoa, idade?: number, status?: boolean): string {
  if (!status){
    return `${funcionario.nome} - ${idade} - ${status}`
  }   
  return funcionario.nome
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    sobrenome: "Silva"
  } 

  return (
    <div>
      {Mostrar(funcionario, 33, false)}
    </div>
  );
}

>>> Maria - 33 - false

No exemplo acima, só serão aceitos os 2 casos de parametros passados:
-Apenas o Nome+Sobrenome
-Nome+Sobrenome, idade, status

Caso queira passar apenas Nome+Sobrenome e idade OU Nome+Sobrenome e status, dará erro!
{Mostrar(funcionario, 33)}
OU
{Mostrar(funcionario, false)}

//////////////////////////////////////////////////////////////////////////&&&
TUPLES / TUPLAS

export default function App() {

  const pessoa: [string, number] = ["Maria", 33]

  return (
    <div>
      <button onClick={() => console.log(pessoa)}>CLIQUE</button>
    </div>
  );
}

>>> ["Maria", 33]

---------------------

export default function App() {

  let pessoa: [string, number] = ["Maria", 33]

  pessoa = ["Carlos", 28] 

  return (
    <div>
      <button onClick={() => console.log(pessoa)}>CLIQUE</button>
    </div>
  );
}

>>> ["Carlos", 28]

---------------------

export default function App() {

  const pessoa: [string, number] = ["Maria", 33]

  return (
    <div>
      {`${pessoa[0]} tem ${pessoa[1]} anos.`}
    </div>
  );
}

>>> Maria tem 33 anos.

------------------- 

function Mostrar(pessoa: [string, number]) {
  console.log(pessoa[0])
}

export default function App() {

  const pessoa: [string, number] = ["Maria", 33]

  return (
    <div>
      <button onClick={() => Mostrar(pessoa)}>CLIQUE</button>
    </div>
  );
}

>>> Maria

----------------------------------------- ###
READONLY TUPLES

export default function App() {

  const pessoa: [string, number] = ["Maria", 33]

  pessoa[0] = "Carlos"                                    //OU pessoa.push("Carlos") 

  return (
    <div>
      <button onClick={() => console.log(pessoa)}>CLIQUE</button>
    </div>
  );
}

>>> ["Carlos", 33]

Caso quísessemos não poder alterar o valor de uma tupla const, poderíamos usar o readonly:

export default function App() {

  const pessoa: readonly [string, number] = ["Maria", 33]

  pessoa.push("Carlos")                            //Erro!!! tupla não pode ser modificada

  return (
    <div>
      <button onClick={() => console.log(pessoa)}>CLIQUE</button>
    </div>
  );
}

-----------

type Pessoa = readonly [string, number, string, boolean]

function Mostrar(funcionario: Pessoa) {
  if (funcionario[3] === true) {
    return [funcionario[0], funcionario[1], funcionario[2]]
  }
}

export default function App() {

  const pessoa = ["Maria", 33, "Desenvolvedora", true] as const

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

>>> Maria33Desenvolvedora

-------------------------------------------------- ###
TUPLAS vs OBJETOS

Tuplas:
function Pessoa(): [string, number] {
  return ["Maria", 24]
}

Objetos:
function Pessoa(): {nome: string, idade: number} {
  return {nome: "Maria", idade: 24}
}

Tuplas são melhor usadas em casos em que a ordem dos elementos importa. 
Tuplas são semanticamente ordenadas, enquanto objetos não.

Com objetos você pode passar apenas os valores que quiser como parametros de uma função. Já tuplas, não

-------------

function fTupla(pessoa: [string, number, string])  {
  return pessoa[2]
}

function fObjeto(pessoa: {nome: string, idade: number, estado: string}): string  {
  return pessoa.estado
}

export default function App() {
  return (
    <div>
      {fTupla([ "Maria" , 33 , "Casada"])}
      <br></br>
      {fObjeto({nome: "Maria", idade: 33, estado: "Casada"})}
    </div>
  );
}

>>> Casada
>>> Casada

----------------------------------------------- ###
Desestruturando tuplas

export default function App() {

  const nomeCompleto: string = "Maria Silva"
  const partes: string[] = nomeCompleto.split(" ")
  
  return (
    <div>
      <p>{partes[0]}</p> 
      <p>{partes[1]}</p>
    </div>
  );
}

>>> Maria
>>> Silva

---------

function Mostrar(partes: string[]): [string, string] {
  return [partes[0], partes[1]]
}

export default function App() {

  const nomeCompleto: string = "Maria Silva"
  const partes: string[] = nomeCompleto.split(" ")
  
  return (
    <div>
      {Mostrar(partes)}
    </div>
  );
}

>>> MariaSilva

-----------

function Mostrar(nomeCompleto: string): string {
  const partes: string[] = nomeCompleto.split(" ")
  return `${partes[0]} ${partes[1]}`
}

export default function App() {

  const nomeCompleto: string = "Maria Silva"
  
  return (
    <div>
      {Mostrar(nomeCompleto)}
    </div>
  );
}

>>> Maria Silva

------------

function Mostrar(nomeCompleto: string): string {
  const partes: string[] = nomeCompleto.split(" ")
  const [nome, sobrenome]: string[] = partes
  return `${nome} ${sobrenome}`
}

export default function App() {

  const nomeCompleto: string = "Maria Silva"
  
  return (
    <div>
      {Mostrar(nomeCompleto)}
    </div>
  );
}

>>> Maria Silva

------------------------------------------ ###
DESESTRUTURAÇÃO ANINHADA DE TUPLAS
(objetos dentro de tuplas)

type Pessoa = [string, {nome: string, idade: number}]

function Mostrar(funcionario: Pessoa): string {
  const [cargo, {nome, idade}] = funcionario
  return `${nome} tem ${idade} anos e é ${cargo}`
}

export default function App() {

  const funcionario: Pessoa = [
    "Professora",
    {nome: "Maria", idade: 25}
  ]

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

------------------------------------------- ###
TUPLAS NOMEADAS


Para fins de documentação, ao invés de escrever:
type pessoa = [string, number, boolean]

Escreveria para deixar mais claro:
type pessoa = [nome: string, idade: number, status: boolean]

------------------------------------------- ###
Elementos opcionais em tuplas (?):

type Pessoa = [
  nome: string, 
  idade: number, 
  status?: boolean      //status é opcional
]

function Mostrar(funcionario: Pessoa) {
  return funcionario[0]
}

export default function App() {

  const funcionario: Pessoa = ["Maria", 33]

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

>>> Maria

OBS: Elementos opcionais devem vir por último!
type Pessoa = [
  nome?: string,       //ERRADO!!!
  idade: number      
]

----------------------- %%%
Também é possível deixar opcional um parametro sem nome:

type Pessoa = [
  nome: string, 
  idade: number, 
  string?      
]

function Mostrar(funcionario: Pessoa) {
  return funcionario[2]
}

export default function App() {

  const funcionario: Pessoa = ["Maria", 33, "Casada"]

  return (
    <div>
      {Mostrar(funcionario)}
    </div>
  );
}

>>> Casada

------------------------------------------------- ###
Elementos Rest (spread) em tuplas:

type Notas = [string, ...number[]]               //O elemento string é obrigatório e o number é opcional

const alunos: Notas = ["Pedro", 78, 91, 85]
const alunos: Notas = ["Maria", 82, 79]
const alunos: Notas = ["Ana", 92]
const alunos: Notas = ["Carlos"]

-------------------------------------------------- ### 
TUPLAS COM PROPS

-Arquivo Teste.tsx:

interface Pessoa {                        //OU type Pessoa = {nomes: [string, string]}          
  nomes: [string, string];
}

export default function Teste({nomes}: Pessoa) {
  return (
    <div>
      {nomes[0] + ", " + nomes[1]}
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nomes={["Maria", "Carlos"]} />
    </>
  )
}

>>> Maria, Carlos

-------------------------- %%%

-Arquivo Teste.tsx:

interface Pessoa {                             //OU type Pessoa = {nomes: [string, string, string, string]}          
  nomes: [string, string, string, string];
}

export default function Teste({nomes}: Pessoa) {
  return (
    <div>
      {nomes.map((nome) => (
        <div key={nome}>
          <p>{nome}</p>
        </div>
      ))}
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nomes={["Maria", "Carlos", "João", "Pedro"]} />
    </>
  )
}

>>> Maria
>>> Carlos
>>> João
>>> Pedro

---------------------------- %%%

-Arquivo Teste.tsx:

interface Pessoa {                             //OU type Pessoa = {nomes: [string, number, boolean]}          
  dados: [string, number, boolean];
}

export default function Teste({dados}: Pessoa) {
  return (
    <div>
      <p>{dados[0]} tem {dados[1]} anos e {dados[2] ? "é casado" : "é solteiro"}</p>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nomes={["Carlos", 31, true]} />
    </>
  )
}

>>> Carlos tem 31 anos e é casado

------------------------------ %%%

-Arquivo Teste.tsx:

interface Pessoa {                             //OU type Pessoa = {nomes: [string, number, boolean][]}          
  dados: [string, number, boolean][];
}

export default function Teste({dados}: Pessoa) {
  return (
    <div>
      <p>{dados[0][0]} tem {dados[0][1]} anos e {dados[0][2] ? "é casado" : "é solteiro"}</p>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste dados={[["Carlos", 31, true],["Maria", 25, false]]} />
    </>
  )
}

>>> Carlos tem 31 anos e é casado


//////////////////////////////////////////////////////////////////////////&&&  
CLASSES

export default function App() {

  class Pessoa {
    nome: string;
    idade: number;

    constructor(nome: string, idade: number) {
      this.nome = nome;
      this.idade = idade;
    }

    getNome() {
      return this.nome;
    }

    getIdade() {
      return this.idade;
    }

    getCidade(cidade: string): string {
      return `${this.nome} mora em ${cidade}`
    } 
  }

  const pessoa = new Pessoa("Carlos", 30);
  const cidade: string = "São Paulo";

  return (
    <div>
      {pessoa.getCidade(cidade)}
    </div>
  );
}

>>> Carlos mora em São Paulo

------------------------------------ ###
PRIVATE CLASS (#)

export default function App() {

  class Pessoa {
    #nome: string;                 //Propriedade privada na classe Pessoa

    constructor(nome: string) {
      this.#nome = nome;
    }

    getNome(): string {
      return this.#nome;            //Chamada dentro da classe
    }
  }

  let pessoa = new Pessoa("Carlos");
  pessoa = new Pessoa("João")          //Alterou o nome

  return (
    <div>
      {pessoa.getNome()}
    </div>
  );
}

>>> João

-Consegue acessar o valor quando está dentro da classe

----------------

export default function App() {

  class Pessoa {
    #nome: string;              //Propriedade privada na classe Pessoa

    constructor(nome: string) {
      this.#nome = nome;
    }

    getNome(): string {
      return this.#nome;
    }
  }

  let pessoa = new Pessoa("Carlos");

  return (
    <div>
      <button onClick={() => console.log(pessoa.#nome)}>CLIQUE</button>         //Chamada fora da classe
    </div>
  );
}

>>> ERRO!!! 
Property '#nome' is not accessible outside class 'Pessoa' because it has a private identifier.

--------------------
OUTRA FORMA DE DECLARAR PRIVATE CLASS:

export default function App() {

  class Pessoa {
    private nome: string;              //Propriedade privada na classe Pessoa

    constructor(nome: string) {
      this.nome = nome;
    }

    getNome(): string {
      return this.nome;
    }
  }

  let pessoa = new Pessoa("Carlos");

  return (
    <div>
      <button onClick={() => console.log(pessoa.nome)}>CLIQUE</button>        
    </div>
  );
}

OBS: Este modo é exclusivo do Typescript, portanto o Javascript não indicará o erro, apenas o Typescript.
O modo com # é o mais indicado pois é a forma natural do Javascript fazer isso.
Só é recomendado fazer o modo private acima se estiver mexendo com código antigo de Javascript que não suporta #.

---------------------------------------------- ###
HERANÇA COM CLASSES

export default function App() {

  class Pessoa {
    nome: string;              

    constructor(nome: string) {
      this.nome = nome;
    }
  }

  class Aluno extends Pessoa {
    idade: number;              

    constructor(nome: string, idade: number) {
      super(nome);
      this.idade = idade;
    }

    getNome(): string {
      return this.nome;
    }
  }

  let pessoa = new Aluno("Carlos", 15);

  return (
    <div>
      <p>{pessoa.getNome()}</p> 
      <p>{pessoa.nome}</p>
      <button onClick={() => console.log(pessoa.idade)}>CLIQUE</button>     
    </div>
  );
}

>>> Carlos

---------------------------- %%%
HERANÇA COM PRIVATE CLASS

export default function App() {

  class Pessoa {
    #nome: string;                   //Propriedade privada de classe 

    constructor(nome: string) {
      this.#nome = nome;
    }
  }

  class Aluno extends Pessoa {
    idade: number;              

    constructor(nome: string, idade: number) {
      super(nome);
      this.idade = idade;
    }

    getNome(): string {
      return this.#nome;
    }
  }

  let pessoa = new Aluno("Carlos", 15);

  return (
    <div>
      {pessoa.getNome()}       
    </div>
  );
}

>>> ERRO!!! Pois classes que herdam não podem usar propriedades privadas


--------------------------- %%%
HERANÇA COM PROTECTED CLASS

Diferentemente de classes privadas, classes que herdam de uma classe pai podem usar uma propriedade com protected.

export default function App() {

  class Pessoa {
    protected nome: string;              

    constructor(nome: string) {
      this.nome = nome;
    }
  }

  class Aluno extends Pessoa {
    idade: number;              

    constructor(nome: string, idade: number) {
      super(nome);
      this.idade = idade;
    }

    getNome(): string {
      return this.nome;
    }
  }

  let pessoa = new Aluno("Carlos", 15);

  return (
    <div>
      {pessoa.getNome()}      
    </div>
  );
}

-------------------------------------------- ###
CLASSES ABSTRATAS
(Não podem ser instanciadas diretamente. Classes abstratas são apenas templates para subclasses herdarem suas propriedades)

export default function App() {

  abstract class Formato {
    tamanho: "pequeno" | "medio" | "grande";

    constructor(tamanho: "pequeno" | "medio" | "grande") {
      this.tamanho = tamanho
    }

    abstract CalcularArea(): number {
      return Math.PI * this.raio * this.raio
    }

    MostrarArea(): void {
      console.log(this.CalcularArea())
    }
  }

  const formato = new Formato("pequeno")     //ERRO!!! Não pode ser instanciada diretamente

  return (
    <div>
      <p>{formato.MostrarArea()}</p>  
    </div>
  );
}

>>> ERRO!!!

-Para instanciar uma classe abstrata, é necessário fazer:

export default function App() {

  abstract class Formato {                                       //Classe Abstrata
    tamanho: "pequeno" | "medio" | "grande";

    constructor(tamanho: "pequeno" | "medio" | "grande") {
      this.tamanho = tamanho
    }
  }

  class Circulo extends Formato {                                //Classe Concreta
    raio: number;

    constructor(tamanho: "pequeno" | "medio" | "grande") {
      super(tamanho);
      if (this.tamanho === "pequeno") {
        this.raio = 5
      } 
      else if (this.tamanho === "medio") {
        this.raio = 10
      } 
      else {
        this.raio = 15
      } 
    }

    CalcularArea(): number {
      return Math.PI * this.raio * this.raio
    }
  }

  const circulo = new Circulo("grande")

  return (
    <div>
      <p>{circulo.CalcularArea()}</p>  
    </div>
  );
}

-------------------------------------------------------- ###
CLASSES IMPLEMENTANDO INTERFACES
(usar interfaces em classes)

export default function App() {

  interface Empregado {
    cargo: string;
  }

  interface Trabalho {
    trabalhar(horas: number): void;
  }

  class Pessoa implements Empregado, Trabalho {
    nome: string;
    idade: number;
    cargo: string;

    constructor (nome: string, idade: number, cargo: string) {
      this.nome = nome;
      this.idade = idade;
      this.cargo = cargo;
    }

    trabalhar(horas: number) {
      return `${this.nome} trabalha ${horas} horas por dia como ${this.cargo}`
    }
  }

  const pessoa = new Pessoa('João', 25, 'desenvolvedor');

  return (
    <div>
      <p>{pessoa.trabalhar(8)}</p>  
    </div>
  );
}

>>> João trabalha 8 horas por dia como desenvolvedor

-------------------------------------------------------- ###
CLASSES IMPLEMENTANDO TYPES
(usar type em classes)

export default function App() {

  type Empregado = {
    cargo: string;
  }

  type Trabalho = {
    trabalhar(horas: number): void;
  }

  class Pessoa implements Empregado, Trabalho {
    nome: string;
    idade: number;
    cargo: string;

    constructor (nome: string, idade: number, cargo: string) {
      this.nome = nome;
      this.idade = idade;
      this.cargo = cargo;
    }

    trabalhar(horas: number) {
      return `${this.nome} trabalha ${horas} horas por dia como ${this.cargo}`
    }
  }

  const pessoa = new Pessoa('João', 25, 'desenvolvedor');

  return (
    <div>
      <p>{pessoa.trabalhar(8)}</p>  
    </div>
  );
}

>>> João trabalha 8 horas por dia como desenvolvedor

----------------------------------------------- ###
CLASSES vs INTERFACES vs TYPES
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

class Pessoa {
  nome: string;
  idade: number;
}

interface Pessoa {
  nome: string;
  idade: number;
}

type Pessoa = {
  nome: string;
  idade: number;
}


Classes são uma feature do Javascript
Interfaces e Types são apenas do Typescript

//////////////////////////////////////////////////////////////////////////&&& 
ENUM
(não é muito usado)

enum Direction {
  Norte,   //0
  Sul,     //1
  Leste,   //2
  Oeste    //3
}

let caminho: Direction = Direction.Norte
console.log(caminho)

>>> 0

Quando não é passado nenhum valor para uma propriedade em enum, cada uma das propriedades terá como valor o seu indice

------------
Exemplo com string como valor:

enum MENSAGENS {
  msg1 = "TextoMsg1",
  msg2 = "TextoMsg2",
  msg3 = "TextoMsg3",
}

const showMsg = (mensagem: MENSAGENS) => {
  if (mensagem == MENSAGENS.msg1) {
    console.log("TEXTO 1")
  } else if (mensagem == MENSAGENS.msg2) {
    console.log("TEXTO 2")
  } else {
    console.log("TEXTO 3")
  }
}

showMsg(MENSAGENS.msg2)

>>> TEXTO 2

-----------

enum LoginError {
  Unauthorized = "unauthorized",
  NoUser = "nouser",
  WrongCredentials = "wrongcredentials",
  Internal = "internal",
}

const printErrorMsg = (error: LoginError) => {
  if (error == LoginError.Unauthorized) {
    console.log("User not authorized")
  } else if (error == LoginError.NoUser) {
    console.log("No user was found with that username")
  } else if (error == LoginError.WrongCredentials) {
    console.log("Wrong username/password")
  } else {
    console.log("Internal Error.")
  }
}

printErrorMsg(LoginError.NoUser)

>>> No user was found with that username

---------------------------------------- ###
ENUMS QUE NÃO PODEM SER MODIFICADOS

enum MENSAGENS {
  msg1,
  msg2,
  msg3,
}

console.log(MENSAGENS[MENSAGENS.msg1])

>>> msg1

-Porém, se usar const em um enum, não é possível fazer o mesmo:

const enum MENSAGENS {
  msg1,
  msg2,
  msg3,
}

console.log(MENSAGENS[MENSAGENS.msg1])

>>> ERRO! A const enum member can only be accessed using a string literal. 


-------------------------------------- ###
ENUM COM REACT

enum MENSAGENS {
  msg1 = "Texto da Mensagem1",
  msg2 = "Texto da Mensagem2",
  msg3 = "Texto da Mensagem3",
}
export default function App() {
  return (
    <>
      <h1>{MENSAGENS.msg1}</h1>
    </>
  );
}

------

Usando React.FC para tipar explicitamente o componente funcional:


import React from 'react';

enum MENSAGENS {
  msg1 = "Texto da Mensagem1",
  msg2 = "Texto da Mensagem2",
  msg3 = "Texto da Mensagem3",
}

const App: React.FC = () => {
  return (
    <>
      <h1>{MENSAGENS.msg1}</h1>
    </>
  );
};

export default App;

------------------ ###
Enum com props:

-Arquivo Teste.tsx:

interface EstadoInterface {
  estado: Estados;
}

export enum Estados {
  RJ = "Rio de Janeiro",
  SP = "São Paulo",
  MG = "Minas Gerais",
}

export const Teste = ({estado}: EstadoInterface) => {
  return (
    <div>
      <h1>{estado}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import React from 'react';
import {Teste, Estados} from './components/Teste'

const App: React.FC<Estados> = () => {
  return (
    <>
      <Teste estado={Estados.SP}/>
    </>
  );
};

export default App;

OU

import {Teste, Estados} from './components/Teste'

export default function App() {
  return (
    <>
      <Teste estado={Estados.MG}/>
    </>
  );
};

----------------------------------------------- ###
ENUM COMPILADO

enum Classe {
  mago,
  guerreiro,
  arqueiro
}

-Ao usar enum sem valores, ele compila para javascript o equivalente a:

var Classe;

(function (Classe) {
  Classe[(Classe["mago"] = 0)] = "mago";
  Classe[(Classe["guerreiro"] = 0)] = "guerreiro";
  Classe[(Classe["arqueiro"] = 0)] = "arqueiro";
})(Classe || (Classe = {}));

¨¨¨¨
-Usando strings como valores, o código fica mais claro:

enum Classe {
  mago = "Merlin",
  guerreiro = "Arthur",
  arqueiro = "Robin Hood"
}

var Classe;

(function (Classe) {
  Classe["mago"] = "Merlin";
  Classe["guerreiro"] = "Arthur";
  Classe["arqueiro"] = "Robin Hood";
})(Classe || (Classe = {}));

OBS: Enums geram código Javascript ao ser compilado, diferentemente de Unions que somem o código.

///////////////////////////////////////////////////////////////// &&&
TYPE NARROWING
(deixar um tipo ainda mais específico)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

type Casado = {
  nome: string,
  idade: number,
  status: "Casado"
}

type Solteiro = {
  nome: string,
  idade: number,
  status: "Solteiro"
}

type Ambos = Casado | Solteiro

function Pessoa(p1: Ambos, p2: Ambos): void {
  if(p1.status === "Casado" && p2.status === "Casado"){
    StatusCasado(p1, p2)
  } else if (p1.status === "Solteiro" && p2.status === "Solteiro"){
    StatusSolteiro(p1, p2)
  } else {
    throw new Error("Mensagem de erro")
  }
}

function StatusCasado(p1: Casado, p2: Casado): void{
  console.log(`${p1.nome} e ${p2.nome} são casados`)
}

function StatusSolteiro(p1: Solteiro, p2: Solteiro): void{
  console.log(`${p1.nome} e ${p2.nome} são solteiros`)
}

export default function App() {

  const pessoa1: Casado = {
    nome: "Carlos",
    idade: 33,
    status: "Casado"
  }

  const pessoa2: Casado = {
    nome: "Maria",
    idade: 31,
    status: "Casado"
  }
  
  return (
    <>
      <button onClick={() => Pessoa(pessoa1, pessoa2)}>CLIQUE</button>
    </>
  );
}

>>> Carlos e Maria são casados

/////////////////////////////////////////////////////////////////// &&&
Unknown Type

let x: unkown = "TEXTO"
let y: any = "TEXTO"

x.toLowerCase()      //ERRO
y.toLowerCase()      //Colocará o texto em letra minúscula

Para resolver isso:

if (typeof x === "string") {
  x.toLowerCase()
}

Tipo unkown força a especificar que tipo de variavel é, por isso é melhor de ser usado do que tipo any.

Unknown é útil para ser usado quando não sabemos que tipo de dados será recebido.

type Mensagem = {
  tipo: string;
  conteudo: string;
}

function handleInput(msg: unknown): Mensagem {
  if (typeof msg === "string") {
    return {
      tipo: "string de texto",
      conteudo: msg
    }
  }
  if (typeof msg === "number") {
    return {
      tipo: "numero",
      conteudo: msg
    }
  }
  if (Array.isArray(msg)) {
    return {
      tipo: "array",
      conteudo: msg.join("\n")
    }
  }
  return {
    tipo: "Desconhecido",
    conteudo: "Recebeu conteúdo desconhecido"
  }
}

------------

import React, { useState } from 'react';

type Mensagem = {
  tipo: string;
  conteudo: string;
}

export default function App() {

  const [msg, setMsg] = useState<Mensagem>({tipo: "", conteudo: ""});
  const [newMsg, setNewMsg] = useState('');

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setNewMsg(event.target.value);
  };

  function handleInput(msg: unknown): void {
    if (typeof msg === "string") {
      setMsg({
        tipo: "string de texto",
        conteudo: msg
      });
      setNewMsg("");
      return;
    }
    if (Array.isArray(msg)) {
      setMsg({
        tipo: "array",
        conteudo: msg.join("\n")
      });
      setNewMsg("");
      return;
    }
    setMsg({
      tipo: "Desconhecido",
      conteudo: "Recebeu conteúdo desconhecido"
    });
    setNewMsg("");
  }

  const array: string[] = ["a", "b", "c"];

  return (
    <div>
      <input
        type="text"
        value={newMsg}
        onChange={handleInputChange}
        placeholder="Digite uma mensagem"
      />

      <button onClick={() => handleInput(newMsg)}>Teste String</button>
      <button onClick={() => handleInput(array)}>Teste Array</button>

      {msg && (
        <div>
          <p>Tipo: {msg.tipo}</p>
          <p>Conteúdo: {msg.conteudo}</p>
        </div>
      )}

    </div>
  );
}

---------------------------------------- ###
NARROWING TYPES USANDO IN

import { chownSync } from "fs"

type Texto1 = {
  txt1: string
}

type Texto2 = {
  txt2: string
}

type Texto = Texto1 | Texto2

export default function App() {

  function Mostrar(msg: Texto){
    if ("txt1" in msg){
      return "Conteúdo de type Texto1: " + msg.txt1
    } else if ("txt2" in msg) {
      return "Conteúdo de type Texto2: " + msg.txt2
    } else {
      return "Conteúdo desconhecido"
    }
  }

  const msg: Texto = { txt1: "TEXTO DE EXEMPLO 1" }

  return (
    <div>
      {Mostrar(msg)}
    </div>
  );
}

-------------------------------------- ### &&&
TYPE UNKNOWN COM FETCH DE DADOS DE UMA API OU BANCO DE DADOS  ***
VIDEO: https://www.youtube.com/embed/TPACABQTHvM


import {useState, useEffect} from 'react'

type Post = {
  id: number;
  title: string;
}

export default function App() {

  const [posts, setPosts] = useState<Post[]>([])

  useEffect(() => {
    fetch('https://dummyjson.com/posts')
      .then((response) => response.json())
      .then((data: unknown) => {
        if (typeof data === 'object' && data !== null && 'posts' in data) {    
   //OU if (data && typeof data === 'object' && 'posts' in data) 
          setPosts(data.posts as Post[])
        }
      })}, [])

  return(
    <div>
      {posts.map((post: Post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}


---------------------------------------------------- ###

import {useState, useEffect} from 'react'

type Post = {
  id: number;
  title: string;
}

export default function App() {

  const [posts, setPosts] = useState<Post[]>([])

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/todos/')
      .then((response) => response.json())
      .then((data: unknown) => {
        if (Array.isArray(data)) {
          setPosts(data)
        }
      })}, [])

  return(
    <div>
      {posts.map((post: Post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}

--------------------------------------- ###
USANDO ZOD PARA CHECAR TYPE UNKNOWN:

import {useState, useEffect} from 'react'

export default function App() {

  const [posts, setPosts] = useState([])

  useEffect(() => {
    fetch('https://dummyjson.com/posts')
      .then((response) => response.json())
      .then((data: unknown) => {
          //passe pelo zod. Exemplo: const parsedData = postsDataSchema.parse(data);
          setPosts(data.posts)
      })}, [])

  return(
    <div>
      {posts.map((post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}

OU

import {useState, useEffect} from 'react'
import axios from 'axios'

export default function App() {

  const [posts, setPosts] = useState([])

  useEffect(() => {
    axios.get('https://dummyjson.com/posts')
      .then((response: unknown) => {
          //passe pelo zod. Exemplo: const parsedData = postsDataSchema.parse(data);
          setPosts(response.data.posts)
      })}, [])

  return(
    <div>
      {posts.map((post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}

-------------------- %%%
Exemplos:

import {useState, useEffect} from 'react'
import {z} from 'zod'

type Post = {
  id: number;
  title: string;
}

export default function App() {

  const [posts, setPosts] = useState<Post[]>([])

  const postsDataSchema = z.object({
    posts: z.array(z.object({
      id: z.number(),
      title: z.string(),
    })),
  });

  useEffect(() => {
    fetch('https://dummyjson.com/posts')
      .then((response) => response.json())
      .then((data: unknown) => {
        try {
          const parsedData = postsDataSchema.parse(data);
          setPosts(parsedData.posts);
        } catch (error) {
          console.error("Error parsing data:", error);
        }
      })
      .catch(error => console.error("Error fetching data:", error));
  }, []);

  return(
    <div>
      {posts.map((post: Post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}

-------------------------- %%%

import {useState, useEffect} from 'react'
import {z} from 'zod'

type Post = {
  id: number;
  title: string;
}

export default function App() {

  const [posts, setPosts] = useState<Post[]>([])

  const postsDataSchema = z.array(z.object({
    id: z.number(),
    title: z.string(),
  }));

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/todos/')
      .then((response) => response.json())
      .then((data: unknown) => {
        try {
          const parsedData = postsDataSchema.parse(data);
          setPosts(parsedData);
        } catch (error) {
          console.error("Error parsing data:", error);
        }
      })
      .catch(error => console.error("Error fetching data:", error));
      }, []);

  return(
    <div>
      {posts.map((post: Post) => (
        <div key={post.id}>
          <p>{post.title}</p>
        </div>
      ))}
    </div>
  )
}



////////////////////////////////////////////////////////////////// &&& ***
FETCH / AXIOS


--------------------------------- ###
USANDO FETCH:

import React, { useState, useEffect } from 'react';

interface Post {
  id: number;
  title: string;
}

interface IPosts {
  posts: Post[];
}

const App: React.FC = () => {
  
  const [posts, setPosts] = useState<Post[]>([]);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch('https://dummyjson.com/posts');
        if (!response.ok) {
          console.log(`HTTP error! status: ${response.status}`);
        }
        const data: IPosts = await response.json();
        setPosts(data.posts);
      } catch (err: any) {                             //É melhor type unknown
        console.log(err.message);
      } 
    };

    fetchPosts();
  }, []);

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;

--------------------
Adicionando Loading e Error:

import React, { useState, useEffect } from 'react';

interface Post {
  id: number;
  title: string;
}

interface IPosts {
  posts: Post[];
}

const App: React.FC = () => {

  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch('https://dummyjson.com/posts');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: IPosts = await response.json();
        setPosts(data.posts);
      } catch (err: unknown) {
        if (err instanceof Error) {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;

------------------------ %%%

import React, { useState, useEffect } from 'react';

interface Post {
  id: number;
  title: string;
}

const App: React.FC = () => {

  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos/');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data: Post[] = await response.json();
        setPosts(data);
      } catch (err: unknown) {
        if (err instanceof Error) {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;

---------------------------------------------------- ###
USANDO AXIOS:

import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface Post {
  id: number;
  title: string;
}

interface IPosts {
  posts: Post[];
}

const App: React.FC = () => {
  
  const [posts, setPosts] = useState<Post[]>([]);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await axios.get<IPosts>('https://dummyjson.com/posts');
        setPosts(response.data.posts);
      } catch (err: any) {
        console.log(err.message);
      } 
    };

    fetchPosts();
  }, []);

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;

--------------
Adicionando Loading e Error:

import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface Post {
  id: number;
  title: string;
}

interface IPosts {
  posts: Post[];
}

const App: React.FC = () => {

  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await axios.get<IPosts>('https://dummyjson.com/posts');
        setPosts(response.data.posts);
      } catch (err: unknown) {
        if (err instanceof Error) {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;

-------------------------------- %%%

import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface Post {
  id: number;
  title: string;
}

const App: React.FC = () => {

  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPosts = async () => {
      try {
        const response = await axios.get<Post[]>('https://jsonplaceholder.typicode.com/todos/');
        setPosts(response.data);
      } catch (err: unknown) {
        if (err instanceof Error) {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchPosts();
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <ul>
        {posts.map((post: Post) => (
          <li key={post.id}>
            <p>{post.title}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;



///////////////////////////////////////////////////////////////// &&&
GUARD CLAUSE

function proccessName(name: string | null | undefined) {
  if (name === null || name === undefined){                  //OU if (name == null){...}
    return ""
  }
  return name.toUpperCase()
}

-------

function proccessName(name: string | null | undefined) {
  if (name === null || name === undefined){
    throw new Error("Name is required")
  }
  return name.toUpperCase()
}

//////////////////////////////////////////////////////////////// &&&
CONDITIONAL TYPE
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

Sintaxe:
type NewType = SomeType extends OtherType ? TrueType : FalseType

Leia-se: Se SomeType extends (satisfies) OtherType, então NewType será TrueType. Se não for, será FalseType.

-------------- %%%
Geralmente usado com generics <T>:

type IsString<T> = T extends string ? true : false;

type Resultado1 = IsString<"Texto">    //true
type Resultado1 = IsString<42>         //false
type Resultado1 = IsString<string>     //true

--------------- %%%

type ClickEvent = {type: "click"; x: number; y: number}
type KeyEvent = {type: "key"; key: string}
type MouseMoveEvent = {type: "mousemove"; x: number; y: number}
type FormEvent = {type: "submit"; formId: string}

type Event = ClickEvent | KeyEvent | MouseMoveEvent | FormEvent

type Extract<T, U> = T entends U ? T : never;

type MouseRelatedEvents = Extract<Event, {x: number; y: number}>

-Agora MouseRelatedEvents é o mesmo que:
type MouseRelatedEvents = ClickEvent | MouseMoveEvent

---------------- %%%

type Sentimento<T> = T extends {nervoso: true} 
? "chateado" | "furioso" 
: "contente" | "feliz"

------------------------------------------- ###
INFER

type GetReturnType<T> = T extends (...arg: any[]) => infer R ? R : never

function greet() {return "Olá!"}
function soma(x: number, y: number) { return x + y }

type GreetReturnType = GetReturnType<typeof greet>    //string
type AddReturnType = GetReturnType<typeof soma>   //number

---------------- %%%

type Test<T> = T extends `${string}:${string}` ? true : false

type A = Test<"abc">          //false
type B = Test<"abc:def">      //true

Usando infer:

type Test<T> = T extends `${infer Key}:${string}` ? Key : false

type A = Test<"nome:Carlos">      //type A = "nome"

OU

type Test<T> = T extends `${infer Key}:${infer Value}` ? [Key, Value] : false

type A = Test<"nome:Carlos">      //type A = ["nome", "Carlos"]

----------------- %%%

type InputTypeOf<T> = T extends (arg1: infer Parametro, ...args: any[]) => any ? Parametro : unknown

////////////////////////////////////////////////////// &&&
MAPPED TYPES

Lembrando que dynamic keys é:

type User = {
  [key: string]: number;
}

Mapped Types servem para criar novos tipos usando dynamic keys em propriedades baseado em tipos ou interfaces existentes.

type Pessoa = {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

Para criar um novo tipo que possui as mesmas propriedades acima, mas todas elas são opcionais, usamos o mapped type:

type PessoaOpcional = {
  [K in keyof Pessoa]?: Pessoa[K]
}

-----
O mesmo exemplo usando interface:

interface Pessoa {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

type PessoaOpcional = {
  [K in keyof Pessoa]?: Pessoa[K]
}

--------- %%%

type Pessoa = {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

type PessoaOpcional = {
  [Dados in keyof Pessoa]?: Pessoa[Dados]
}

function Mostrar(pessoa: PessoaOpcional) {
  return pessoa.status
}

export default function App() {

  const pessoa: PessoaOpcional = {
    nome: "João",
    status: "Viúvo"          //Erro no Typescript
  }

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

------------------------------- ###
MUDANDO OS TIPOS OPCIONAIS

Pode-se usar o mapped types para mudar os tipos de propriedades:

type Pessoa = {
  idade: number;
  id: number;
  tel: number;
}

type PessoaStrings = {
  [Key in keyof Pessoa]?: string    //Só aceita strings agora
}

function Mostrar(pessoa: PessoaStrings) {
  return pessoa.idade
}

export default function App() {

  const pessoa: PessoaStrings = {
    idade: "20 anos",                //Tipo string
  }

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

--------
Usando interface:

interface Pessoa {
  idade: number;
  id: number;
  tel: number;
}

type PessoaStrings = {
  [Key in keyof Pessoa]?: string
}

----------------------------------- ###
MAPPED TYPES COM CONDICIONAIS

type Pessoa = {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

type FiltroPessoa = {
  [K in keyof Pessoa]: Pessoa[K] extends string ? Pessoa[K] : never;
}

Filtrou todos as propriedades que tem tipo string e removeu idade que não é string.
A propriedade idade passou a ser do tipo never.
Isso equivale a:

type Pessoa = {
  nome: string;
  status: "Casado" | "Solteiro" | "Divorciado"
  // idade: never  (Removida)
}

-----------

type Pessoa = {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

type FiltroPessoa = {
  [K in keyof Pessoa]: Pessoa[K] extends string ? Pessoa[K] : never;
}

function Mostrar(pessoa: FiltroPessoa) {
  return pessoa.status
}

export default function App() {

  const pessoa: FiltroPessoa = {
    nome: "João",
    idade: 0 as never,
    status: "Casado"
  }

  return (
    <div>
      {Mostrar(pessoa)}
    </div>
  );
}

---------------------------------- ###
EXTRAINDO KEYS DE MAPPED TYPES
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

type Pessoa = {
  nome: string;
  idade: number;
  status: "Casado" | "Solteiro" | "Divorciado"
}

type StringKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never
}

type Result = {
  name: "name";
  age: never;
  branch: "branch"
}

type StringKeyUnion<T> = StringKeys<T>[keyof T]

type Keys = StringKeyUnion<Pessoa>     // "name" | "branch"

---------------------- %%%
Entendendo keyof:

type A = ["a", "b", "c"];
type Union = A[number]                

//A[number] => type A = ["a", "b", "c"]         
//Union tem o valor de: type Union = "a" | "b" | "c"

----

type Pessoa = {nome: string, idade: number}
type Data = Pessoa[keyof Pessoa]   

//Pessoa[keyof Pessoa] => type Pessoa = {nome: string, idade: number}
//Data tem o valor de: type Data = string | number

////////////////////////////////////////////////////// &&&
PARAMETERS<typeof ... > 

Para pegar os tipos dos parametros de uma função.

function getPessoa(nome: string, idade: number) {console.log(nome)}

type A = Parameters<typeof getPessoa>      //type A = [nome:string,idade:number]

-Se quiser pegar apenas o primeiro parâmetro:
type A = Parameters<typeof getPessoa>[0]     //type A = string 

-------------- %%%

type Teste<T> = Parameters<T>[0]

//////////////////////////////////////////////////////////////// &&&
TYPESCRIPT COM VITE USANDO REACT
Iniciando

Instalação do Vite usando react na pasta do projeto:
npm create vite@latest     //Te pedirá o nome do projeto e pacote
ou
npm create vite@latest .   //Não te pedirá o nome do projeto e pacote (Instala na própria pasta)

Selecione React
Selecione Typescript

Serão criados os arquivos do projeto react:
pasta public
pasta src
.gitignore
eslint.config.js
index.html
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

Para instalar as dependencias (node_modules), digite no terminal:
npm install    

---------
Outras formas:

Instalação do Vite como modo desenvolvimento:
npm i -D vite

Se quiser instalar o Vite usando um template Typescript com framework Vanilla (Sem React e usando tsc):

npm create vite@latest . -- --template vanilla-ts

------------------ ###
Excluindo coisas desnecessárias:

-Arquivo App.tsx dentro da pasta src:

import './App.css'

function App() {

  return (
    <>
    
    </>
  )
}

export default App

¨¨¨
-Arquivo App.css:

#root {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box;
}

---------------- ###

Extensões de arquivos:

arquivo_com_componente.tsx
ou
arquivo_sem_componente.ts    (se não tiver html dentro)

------------------- ###

Rodando o arquivo:

Digite no terminal:
npm run dev

///////////////////////////////////////////////////////////////// &&&
Imprimindo resultados

export default function App() {

  const pessoa: string = "Carlos";

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

-------------- ###

export default function App() {

  function Pessoa(nome: string): string {
    return nome;
  }

  return (
    <>
      <h1>{Pessoa("Maria")}</h1>
    </>
  )
}

---------

export default function App() {

  function Pessoa(nome: string): void {
    console.log(nome);
  }

  return (
    <>
      <button onClick={() => Pessoa("Maria")}>CLIQUE</button>
    </>
  )
}

---------------- ###

export default function App() {

  const Pessoa = (dados: string | number): string => {
    return dados;
  }

  return (
    <>
      <h1>{Pessoa("Ana")} tem {Pessoa(33)} anos</h1>
    </>
  )
}

------------------ ###

export default function App() {

  const Pessoa = (nome: string, idade: number): string => {
    return `${nome} tem ${idade} anos`;
  }

  return (
    <>
      <h1>{Pessoa("Ana", 33)}</h1>
    </>
  )
}


//////////////////////////////////////////////////////////////// &&&
Criando componente

Exportando um componente sem default:

-Arquivo Teste.tsx:

export const Teste = () => {
  return (
    <div>
      <h1>TEXTO DE EXEMPLO</h1>
    </div>
  )
}

-Arquivo App.tsx:

import {Teste} from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste />
    </>
  )
}

---------

-Exportando um componente com default:

-Arquivo Teste.tsx:

export default function Teste() {
  return (
    <div>
      <h1>TEXTO DE EXEMPLO</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste />
    </>
  )
}


///////////////////////////////////////////////////////////////////// &&& 
PROPS NO TYPESCRIPT

-Arquivo Teste.tsx:

export default function Teste(props) {
  return (
    <div>
      <h1>{props.texto}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste texto={"TEXTO DE EXEMPLO"}/>              //OU  <Teste texto={23}/>
    </>
  )
}

OBS: O props aceitará qualquer tipo de variavel e mostrará o resultado na tela. 
Porém, podem ocorrer problemas em alguns casos, caso o tipo da variável não seja definido. 
Para isso é usada uma interface ou type para definir os tipos.

------------------- %%%
Outra forma sem usar interface ou type:

-Arquivo Teste.tsx:

export default function Button(props: {texto: string}) {

  const texto = props.texto

  return (
    <button>
      {texto}
    </button>
  )
}

OU

export default function Button(props: {texto: string}) {

  const {texto} = props

  return (
    <button>
      {texto}
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  return (
    <>
      <Button texto={"CLIQUE AQUI"} />
    </>
  )
}


------------------------------------------------------ ###
PROPS COM INTERFACES E TYPES

-Arquivo Teste.tsx:

interface TxtInterface {                             //OU type TxtInterface = {texto: string}
  texto: string;
}

export default function Teste(props: TxtInterface) {
  return (
    <div>
      <h1>{props.texto}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste texto={"TEXTO DE EXEMPLO"} />
    </>
  )
}

---------------------------- %%%

-Arquivo Teste.tsx:

interface PessoaInterface {                             //OU type PessoaInterface = { ... }
  nome: string;
  idade: number;
  estado: boolean;
}

export default function Teste(props: PessoaInterface) {
  return (
    <div>
      <h1>{props.nome}</h1>
      <h1>{props.idade}</h1>
      <h1>{props.estado ? "Casada" : "Solteira"}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={23} estado={true}/>
    </>
  )
}

----------------------------------------------------- ###
Desconstrução de props:

Sem usar interface ou type:

-Arquivo Teste.tsx:

export default function Teste({nome}: {nome: string}) {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} />
    </>
  )
}

------------------

-Arquivo Teste.tsx:

export default function Teste({nome, idade}: {nome: string, idade: number}) {
  return (
    <div>
      <h1>{nome} tem {idade} anos</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={33} />
    </>
  )
}

--------------------------------- %%%
Usando interface ou type:

-Arquivo Teste.tsx:

interface NomeInterface {                                 //OU  type NomeInterface = { nome: string }
  nome: string;
}

export default function Teste({nome}: NomeInterface) {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} />
    </>
  )
}

---------------

interface Pessoa {                                      //OU  type Pessoa = { nome: string, idade: number }
  nome: string;
  idade: number;
}

export default function Teste({nome, idade}: Pessoa) {
  return (
    <div>
      <h1>{nome} tem {idade} anos</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={33} />
    </>
  )
}


------------------------------- %%%

-Arquivo Button.tsx:

interface IButton {                                 //OU  type IButton = { texto: string }
  texto: string;
}

export default function Button({texto}: IButton ) {

  return (
    <button>
      {texto}
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  return (
    <>
      <Button texto={"CLIQUE AQUI"} />
    </>
  )
}


------------------- %%%

-Arquivo teste.tsx:

interface PessoaInterface {
  nome: string;
  idade: number;
  funcao: () => void;
}

export const Teste = ({ nome, idade, funcao } : PessoaInterface) => {
  return (
    <div>
      <h1>{nome}</h1>
      <p>{idade}</p>
      <button onClick={funcao}>Clique</button>
    </div>
  );
};

-Arquivo App.tsx:

import {Teste} from './components/Teste'

function show() {
  alert("Clicou!")
}

export default function App() {
  return (
    <>
      <Teste nome={"Ana"} idade={24} funcao={show}/>
    </>
  )
}

--------------------- ### 
Props sem campos:

interface ComponenteProps {}

export default function Componente({}: ComponenteProps){
	return (
		<>
      ...
    </>
	)
}

-------------------- ### 
Aceitando mais de um tipo de variavel:

-Arquivo teste.tsx:

interface PessoaInterface {
  nome: string;
  idade: number | null;
}

export default function Teste({nome, idade}: PessoaInterface) {

  return (
    <div>
      <h1>{nome}</h1>  
      <h1>{idade}</h1>                
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={null}/> 
    </>
  )
}

--------------------------------------- ###
Função como props:

Função sem retorno:

-Arquivo Button.tsx:

type ButtonProps = {
  Alerta: () => void;
}

export default function Button({Alerta}: ButtonProps) {
  
  return (
    <button onClick={Alerta}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  function Mensagem() {
    console.log("Texto de exemplo")
  }
  
  return (
    <>
      <Button Alerta={Mensagem} />
    </>
  )
}

------------------ %%%

Função com retorno:

-Arquivo Button.tsx:

type ButtonProps = {
  Alerta: (txt: string) => string;
  txt: string;
}

export default function Button({Alerta, txt}: ButtonProps) {

  return (
    <button onClick={() => Alerta(txt)}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"
import { useState } from "react"

export default function App() {

  const [nome, setNome] = useState("Ana")

  function Mensagem(nome: string) {
    setNome("Maria")
    return nome;
  }

  return (
    <>
      <Button Alerta={Mensagem} txt={nome} />
      <p>Nome: {nome}</p>
    </>
  )
}

------------------------- %%%

-Arquivo Button.tsx:

type ButtonProps = {
  Alerta: (num: number) => number;
  num: number;
}

export default function Button({Alerta, num}: ButtonProps) {

  return (
    <button onClick={() => Alerta(num)}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"
import { useState } from "react"

export default function App() {

  const [ano, setAno] = useState(0)

  function Mensagem(num: number) {
    num = 2025
    setAno(num)
    return ano;
  }

  return (
    <>
      <Button Alerta={Mensagem} num={ano} />
      <p>Ano: {ano}</p>
    </>
  )
}

----------------------------------------------- ### 
PROPS COM INTERSECTION

-Arquivo Button.tsx:

type ButtonProps = {                            
  type: "button" | "submit" | "reset";
}

type SuperButtonProps = ButtonProps & {
  style: {
    color: "red" | "blue" | "green";
    fontSize: "12px" | "14px" | "16px";
  }
}

export default function Button({type, style}: SuperButtonProps ) {

  return (
    <button type={type} style={style}>
      Clique aqui
    </button>
  )
}

OU

interface ButtonProps {                            
  type: "button" | "submit" | "reset";
}

interface SuperButtonProps extends ButtonProps {
  style: {
    color: "red" | "blue" | "green";
    fontSize: "12px" | "14px" | "16px";
  }
}

export default function Button({type, style}: SuperButtonProps ) {

  return (
    <button type={type} style={style}>
      Clique aqui
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  return (
    <>
      <Button type={"submit"} style={{color: "red", fontSize: "16px"}} />
    </>
  )
}


//////////////////////////////////////////////////////////////// &&&
CHILDREN / React.ReactNode

-Arquivo Button.tsx:

import React from 'react';                   //opcional

type ButtonProps = {
  children: React.ReactNode;
}

export default function Button({children}: ButtonProps) {

  return (
    <button>
      {children}
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  return (
    <>
      <Button>
        Clique aqui
      </Button>
    </>
  )
}

-O texto "Clique aqui" é o elemento children e será o texto que aparecerá dentro do botão.

---------------

Dentro do componente pode haver várias coisas como children:

<Button>{nome}</Button>                       //variavel
<Button>{true}</Button>                       //boolean
<Button><div><h1>Texto</h1></div></Button>    //tags com conteúdo
<Button><div></div></Button>                  //tags sem conteúdo

---------------------%%%

Atenção!!!
Deve-se usar o nome children para a variavel pra que o Typescript entenda que é o elemento filho.
Portanto, o exemplo abaixo não daria erro, mas o Typescript reclamaria:

-Arquivo Button.tsx:

import React from 'react';                   

type ButtonProps = {
  txt: React.ReactNode;                      //OU txt: string;                   
}

export default function Teste({txt}: ButtonProps) {

  return (
    <button>
      {txt}                                 //txt sendo usado como o elemento children
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {

  return (
    <>
      <Button>                               //Typescript apontará erro pois não está sendo passado a variavel children
        Clique aqui
      </Button>
    </>
  )
}

OU

import Button from "./components/Button"

export default function App() {

  const texto = "Clique aqui"

  return (
    <>
      <Button txt={texto}>                   //Typescript apontará erro pois não está sendo passado a variavel children
        {texto}
      </Button>
    </>
  )
}

--------------------------------------------------- ###
JSX.Element vs ReactNode

É possível usar elementos JSX como, por exemplo, tags HTML como conteúdo de children:

-Arquivo Teste.tsx:

import React from 'react';                 

type TextoProps = {
  children: React.ReactNode;                   //OU children: JSX.Element;                     
}

export default function Teste({children}: TextoProps) {

  return (
    <h1>
      {children}                                
    </h1>
  )
}

¨¨¨¨
-Arquivo Teste.tsx:

import Teste from "./components/Teste"

export default function App() {

  const texto = <span style={{color: "red"}}>Texto vermelho</span>

  return (
    <>
      <Teste>                   
        {texto}
      </Teste>
    </>
  )
}

------------

-Muito útil se quiser passar um ícone, por exemplo:

const icon = <i>...</i>

  <Icone>                   
    {icon}
  </Icone>

------------

Atenção!!
Se for usar JSX.Element, o tipo passado tem que possuir elementos JSX, como tags HTML, por exemplo. 
JSX.Element é mais restritivo do que React.ReactNode
Portanto, o exemplo abaixo daria erro no typescript:

-Arquivo Teste.tsx:

import React from 'react';                 

type TextoProps = {
  children: JSX.Element;                            //Tipo elemento JSX  
}

export default function Teste({children}: TextoProps) {

  return (
    <h1>
      {children}                                
    </h1>
  )
}

¨¨¨¨
-Arquivo Teste.tsx:

import Teste from "./components/Teste"

export default function App() {

  const texto = "Texto vermelho"                  //Não é elemento JSX

  return (
    <>
      <Teste>                   
        {texto}                                   //Typescript apontará o erro aqui
      </Teste>
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
USESTATE

Modo implícito: (pode dar problema)

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState("Maria")     //Typescript vai assumir que o tipo é string

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

---------

Modo explícito: (Não é necessário, mas pode evitar erros)

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState<string>("Maria")

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

--------------------------------------- ###
TIPOS COM USESTATE:

const [pessoa, setPessoa] = useState<string>("Maria")

const [numero, setNumero] = useState<number>(10)

const [status, setStatus] = useState<boolean>(true)

------------------ %%%
USANDO ARRAYS:

const [array, setArray] = useState<string[]>(["A", "B", "C"])

const [array, setArray] = useState<number[]>([0, 1, 2])

----------

export default function App() {

  const [count, setCount] = useState<number[]>([1, 2, 3])

  const handleClick = (): void => {
    setCount([...count, count[count.length - 1] + 1])
  }

  return (
    <>
      <button onClick={handleClick}>
        Clique aqui
      </button>
      
      {count.map((item) => (
        <p key={item}>
          {item}
        </p>
      ))}
    </>
  )
}

-----------

import {useState} from 'react'

export default function App() {

  const [nome, setNome] = useState<string[]>(["João", "Pedro"])

  const handleClick = (): void => {
    setNome([...nome, "Maria"])
  }

  return (
    <>
      <button onClick={handleClick}>
        Clique aqui
      </button>
      
      {nome.map((item, index) => (
        <p key={index}>
          {item}
        </p>
      ))}
    </>
  )
}

----------------- %%%
USANDO OBJETOS (sem usar interface ou type):

const [objeto, setObjeto] = useState<Array<{campo1: string, campo2: number, campo3: boolean}>>([{
  campo1: "",
  campo2: 0,
  campo3: false,
}])

OBS: Geralmente usa-se interface ou type para lidar com objetos

----------

import {useState} from 'react'

export default function App() {

  const [pessoa, setPessoa] = useState<Array<{nome: string, idade: number}>>([{
    nome: "Pedro",
    idade: 18
  }])

  const handleClick = (): void => {
    setPessoa([{nome: "Maria", idade: 20}])
  }

  return (
    <>
      <button onClick={handleClick}>
        Clique aqui
      </button>

      <p>{pessoa[0].nome} tem {pessoa[0].idade} anos.</p>
    </>
  )
}

----------

import {useState, ChangeEvent} from 'react'

export default function App() {

  const [pessoa, setPessoa] = useState<Array<{nome: string, idade: string}>>([])      //Ou useState(null)
  
  const [novapessoa, setNovaPessoa] = useState<{nome: string, idade: string}>({nome: '', idade: ''})

  const handleClick = (): void => {
    setPessoa([...pessoa, novapessoa])
    setNovaPessoa({nome: '', idade: ''})
  }

  const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
    setNovaPessoa({...novapessoa, [e.target.name]: e.target.value})
  }

  return (
    <>
      <input type="text" name="nome" value={novapessoa.nome} onChange={handleChange} placeholder="Digite o nome" />
      <input type="number" name="idade" value={novapessoa.idade} onChange={handleChange} placeholder="Digite a idade"/>
      
      <button onClick={handleClick}>
        Adicionar pessoa
      </button>
      
      {pessoa.map((item, index) => (
        <div key={index}>
          <p>{item.nome} tem {item.idade} anos.</p>
        </div>
      ))}
    </>
  )
}

---------------------------------------------- ###
USANDO OBJETOS (com interface ou type):

Usando type com useState:

import {useState} from 'react'

type User = {
  id: number;
  name: string;
  age: number;
}

export default function App() {

  const [user, setUser] = useState<User | null>(null);

  return (
    <>
      <button onClick={() => setUser({id: 1, name: "Maria", age: 23})}>Adicionar Usuário</button>

      {user && (
        <div key={user.id}>
          <p>Nome: {user.name}</p>
          <p>Idade: {user.age} anos</p>    
        </div>
      )}
    </>
  )
}

--------------------- %%%
Usando interfaces com useState:

interface NomeInterface {
  nome: string;
}

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState<NomeInterface>({nome: "Maria"})

  return (
    <>
      <h1>{pessoa.nome}</h1>
    </>
  )
}

---------------------------------------------- ### &&&
USESTATE COM OBJETOS COM VALOR NULL

Caso uma variavel useState tenha como valor inicial null, para acessar uma propriedade deste objeto, é necessario usar ? para não dar problema com o Typescript:

import {useState} from 'react'

type User = {
  id: number;
  name: string;
  age: number;
}

export default function App() {

  const [user, setUser] = useState<User | null>(null);

  const nome = user?.name                                  //OU const nome = user && user.name             

  return (
    <>
      ...
    </>
  )
}

OBS:  Se não colocar o ?, dará erro no Typescript

--------------------------- %%%

import {useState} from 'react'

type User = {
  name: string;
}

export default function App() {

   const [pessoa, setPessoa] = useState<User | null>(null)

  return (
    <>
      <button onClick={() => setPessoa({name: "Maria"})}>CLIQUE</button>

      {pessoa?.name}                           //OU {pessoa && pessoa.name}
    </>
  )
}

---------------------------------------------- ### &&&
PROPS COM USESTATE:

UseState com Props e interface/type: (exemplo 1)

-Arquivo teste.tsx:

interface NomeInterface {                             //OU type NomeInterface = {nome: string}
  nome: string;
}

export default function Teste({nome}:NomeInterface) {

  return (
    <div>
      <h1>{nome}</h1>                      
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {useState} from 'react'
import Teste from "./components/Teste"

export default function App() {

  const [pessoa, setPessoa] = useState("Ana")

  return (
    <>
      <Teste nome={pessoa} />
      <button onClick={() => setPessoa("Maria")}>Mudar</button>
    </>
  )
}

--------------------------- %%%
UseState com Props e interface/type: (exemplo 2)

-Arquivo teste.tsx:

import {useState} from 'react'

interface NomeInterface {
  nome: string;
}

export default function Teste({nome}: NomeInterface) {
  const [show, setShow] = useState<boolean>(true)

  return (
    <div>
      {show && <h1>{nome}</h1>}                      //OU   <h1>{show ? {nome} : "Sem nome"}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"}/>
    </>
  )
}

------------------------ %%%
UseState com Props e interface/type: (exemplo 3)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  estado: boolean;
}

export default function Teste(props: PessoaInterface) {
  const [show, setShow] = useState<boolean>(props.estado)

  return (
    <div>
      <h1>{props.nome}</h1>
      <h1>{show ? "É casado" : "Não é casado"}</h1>
    </div>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} estado={false}/>
    </>
  )
}

¨¨¨¨
Usando destruction no arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  estado: boolean;
}

export default function Teste({nome, estado}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(estado)

  return (
    <div>
      <h1>{nome}</h1>
      <h1>{show ? "É casado" : "Não é casado"}</h1>
    </div>
  )
}

---------------------------- %%%
UseState com props e interface/type: (exemplo 4)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  idade: number;
}

export default function Teste({nome, idade}: PessoaInterface) {
  const [show, setShow] = useState<boolean | null>(true)

  return (
    <>
      {show && <h1>{nome} tem {idade} anos</h1>}
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Ana"} idade={22} />
    </>
  )
}

----------------------- %%%

UseState com props com interface/type: (exemplo 5)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [info, setInfo] = useState<string | null>(null)

  return (
    <>
      <h1>{nome}</h1>
      <h1>{info === null ? "Sem info" : info}</h1>        //É o mesmo que {!info ? "Verdade" : "Falso"}      
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} />
    </>
  )
}

------------------------------------------- ### &&&
USESTATE COM PROPS E SETTERS
VIDEO: https://www.youtube.com/embed/TPACABQTHvM

-Arquivo Button.tsx:

import React from 'react';                 

type ButtonProps = {
  setTexto: React.Dispatch<React.SetStateAction<string>>;       //valor do tipo string
}

export default function Button({setTexto}: ButtonProps) {

  const handleClick = () => {
    setTexto("Novo texto");
  }

  return (
    <button onClick={handleClick}>
      Clique aqui
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"
import {useState} from 'react'

export default function App() {

  const [texto, setTexto] = useState("Texto inicial")

  return (
    <>
      <Button setTexto={setTexto} />
      <p>{texto}</p>
    </>
  )
}

--------------------------- %%%

-Arquivo Button.tsx:

import React from 'react';                 

type ButtonProps = {
  setCount: React.Dispatch<React.SetStateAction<number>>;       //valor do tipo number
}

export default function Button({setCount}: ButtonProps) {

  const Add = () => {
    setCount(prev => prev + 10);
  }

  return (
    <button onClick={Add}>
      Adicionar 10
    </button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"
import {useState} from 'react'

export default function App() {

  const [count, setCount] = useState(0)

  return (
    <>
      <Button setCount={setCount} />
      <p>Contagem: {count}</p>
    </>
  )
}

///////////////////////////////////////////////////////// &&&
TOGGLE

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(true)

  return (
    <>
      <button onClick={() => setShow(!show)}>Clique</button>

      {show && <h1>{nome}</h1>}
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Ana"} />
    </>
  )
}

--------------- ###

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(true)

  const toggle = () => {
    setShow((prev) => !prev)
  }

  return (
    <>
      <button onClick={toggle}>Clique</button>

      {show && <h1>{nome}</h1>}
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} />
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
EVENT HANDLERS

export default function App() {

  const handleClick = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
    console.log(event.currentTarget.innerHTML)
  }

  return (
    <>
      <button onClick={handleClick}>
        Clique aqui
      </button>
    </>
  )
}

>>> Clique aqui

----------------------- %%%

import {useState} from  'react'

export default function App() {

  const [valor, setValor] = useState<string>('')

  const handleChange = (event: React.ChangeEvent<HTMLInputElement> ): void => {
    setValor(event.target.value)
  }

  const handleSubmit = (valor: string): void => {
    console.log(valor)
  }

  return (
    <>
      <input type="text" onChange={handleChange} value={valor} />
      
      <button onClick={() => handleSubmit(valor)}>Enviar</button>
      
      <p>{valor}</p>
    </>
  )
}

------------------------- %%%

import React from "react"

export default function App() {

  const handleMouse = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
    if(event.currentTarget.style.color === 'black') {
      event.currentTarget.style.color='red'
    } else {
      event.currentTarget.style.color='black'
    }
  }

  return (
    <>
      <button onMouseEnter={handleMouse}>
        Passe o mouse
      </button>
    </>
  )
}

------------------------ %%%

export default function App() {

  const handleChange = (event: React.KeyboardEvent<HTMLInputElement>): void => {
    console.log(event.key)
  }

  return (
    <>
      <input type="text" onKeyDown={handleChange} />
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
ONCHANGE COM INPUT

import {useState} from 'react'

export default function App() {

  const [texto, setTexto] = useState<string | null>(null)

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setTexto(event.target.value)
  }

  return (
    <>
      <h1>{texto ? texto : "Sem texto"}</h1>
      <input onChange={handleChange} />
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
ONCHANGE COM SUBMIT

import {useState} from 'react'

interface FormInterface {
  email: string;
}

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados((prevData) => ({
      ...prevData,
      [event.target.name]: event.target.value
    }))
  }

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    alert(dados.email)
  }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input name="email" value={dados.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

--------- ###

Outra forma de lidar com o handleChange:

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados({
      ...dados,
      [event.target.name]: event.target.value
    })
  }
...
}

------------------- ###

import {useState} from 'react'

interface FormInterface {
  username: string;
  email: string;
}

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: "", username: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados((prevData) => ({
      ...prevData,
      [event.target.name]: event.target.value
    }))
  }

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    alert(dados.email)
    console.log(dados.username)
  }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input name="username" value={dados.username} onChange={handleChange} />
        <input name="email" value={dados.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

-------------------- ###

import React, { useState } from 'react';

interface FormData {
  username: string;
  email: string;
}

export default function App() {

  const [formData, setFormData] = useState<FormData>({
    username: '',
    email: '',
  });

  const handleChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();                                       
    alert(`
      ${formData.username} - ${formData.email}
    `);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" name="username" value={formData.username} onChange={handleChange} />
        <input type="email" name="email" value={formData.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

-------------------- ###
VIDEO: https://www.youtube.com/embed/665UnOGx3Pg?autoplay=1

import React, {useState} from 'react'

interface UserInterface {
  email: string;
}

interface Props {
  user: UserInterface;
  onUpdate: (user: UserInterface) => void 
}

function userUpdate({user, onUpdate}: Props) {
  const [name, setName] = useState<string>(user.name)
  const [email, setEmail] = useState<string>(user.email)

  const handleSubmit = (event: ReactFormEvent<HTMLFormElement>) => {
    event.preventDefault()
    onUpdate({
      ...user,
      name: name,
      email: email,
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Nome:</label>
        <input  
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div>
        <label>Email:</label>
        <input  
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      <button type="submit">Update</button>
    </form>
  )
}

export default userUpdate;


//////////////////////////////////////////////////////////////// &&&
USECONTEXT

Passando apenas o valor através do contexto:

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

export interface IContexto {
  txt: string;
}

export const Contexto = createContext<IContexto>({txt: "Texto de exemplo"});

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';
import {Contexto} from './components/ComponentePai'

export default function App(){

  const dados = useContext(Contexto);

  return (
    <>
      <h1>{dados.txt}</h1>
    </>
  )
};

-----------

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  nome: string;
  idade: string;
}

export const Contexto = createContext<IContexto>({
  nome: "Maria",
  idade: "22 anos",
});

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';
import { Contexto } from './components/ComponentePai';

export default function App() {
  const dados = useContext(Contexto);

  return (
    <>
      <h1>{dados.nome}</h1>
      <h2>{dados.idade}</h2>
    </>
  );
}


---------------------------- ###

import { createContext } from 'react';

interface IContexto {
  nome: string;
  idade: string;
}

export const Contexto = createContext<IContexto>({
  nome: "Sem nome",
  idade: "Sem idade",
});

interface ComponentePaiProps {
  children: React.ReactNode;
}

export default function ComponentePai({ children }: ComponentePaiProps) {
  return (
    <Contexto.Provider value={{nome: "Carlos", idade:"35 anos"}}>
      {children}
    </Contexto.Provider>
  )
}

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import { useContext } from 'react';
import { Contexto } from './ComponentePai';

interface IDados {
  nome: string;
  idade: string;
}

export default function ComponenteFilho() {
  const dados: IDados = useContext(Contexto);
  
  return (
    <>
      <h1>{dados.nome}</h1>
      <h2>{dados.idade}</h2>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import ComponenteFilho from './components/ComponenteFilho';
import ComponentePai from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

------------------ ###

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  nome: string | undefined;
  idade: string | undefined;
}

export const Contexto = createContext<IContexto>({
  nome: undefined,
  idade: undefined,
});

interface ComponentePaiProps {
  children: React.ReactNode;
}

export default function ComponentePai({ children }: ComponentePaiProps) {
  return (
    <Contexto.Provider value={{nome: "Sem nome", idade:"Sem idade"}}>
      {children}
    </Contexto.Provider>
  )
}

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import { useContext } from 'react';
import { Contexto } from './ComponentePai';

interface IDados {
  nome: string | undefined;
  idade: string | undefined;
}

export default function ComponenteFilho() {
  const dados: IDados = useContext(Contexto);
  
  return (
    <>
      <h1>{dados.nome = "Maria"}</h1>
      <h2>{dados.idade = "44 anos"}</h2>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import ComponenteFilho from './components/ComponenteFilho';
import ComponentePai from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

------------------- ###

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  txt: string;
}

export const Contexto = createContext<IContexto>({txt: "Texto inicial"});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  return (
    <div>
      <Contexto.Provider>
        {children}
      </Contexto.Provider>
    </div>
  );
};

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';

import {Contexto} from './components/ComponentePai'

export default function App(){
  const {txt} = useContext(Contexto);
  return (
    <>
      <h1>{txt}</h1>
    </>
  )
};

>>> Texto inicial

-------------------- ### 

-Arquivo ComponentePai.jsx:

import { createContext, useState } from 'react';

interface IContexto {
  txt: string | undefined;
  setTxt: (value: string) => void;
}

export const Contexto = createContext<IContexto>({
  txt: undefined,
  setTxt: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({ children }: Props) => {
  const [txt, setTxt] = useState<string>('Texto de exemplo');

  return (
    <>
      <Contexto.Provider value={{txt, setTxt}}>
        {children}
      </Contexto.Provider>
    </>
  );
}


¨¨¨¨
-Arquivo ComponenteFilho.jsx:

import { useContext } from 'react';
import {Contexto} from './ComponentePai'

export const ComponenteFilho = () => {
  const {txt} = useContext(Contexto)
  return (
    <>
    <h1>{txt}</h1>
    </>
  )
}

¨¨¨¨
-Arquivo App.jsx:

import {ComponenteFilho} from './components/ComponenteFilho';
import {ComponentePai} from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

-------------- ###

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  cor: string | undefined;
  txt: string | undefined;
}

export const Contexto = createContext<IContexto>({
  cor: undefined,
  txt: undefined,
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [cor, setCor] = useState<string | undefined>("blue");
  const [txt, setTxt] = useState<string | undefined>("Texto azul");
  
  return (
    <Contexto.Provider value={{ cor, txt }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {cor, txt} = useContext(Contexto);

  return (
    <>
      <div style={{color: cor}}>
        <h2>{txt}</h2>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

---------------- ###
Toggle com useContext e booleans:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: boolean;
  setTheme: (value: boolean) => void;
}

export const Contexto = createContext<IContexto>({
  theme: true,
  setTheme: (prevTheme) => !prevTheme,                //Ou setTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<boolean>(true);

  return (
    <Contexto.Provider value={{ theme, setTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {theme, setTheme} = useContext(Contexto)

  const themeStyles = {
    backgroundColor: theme ? 'white' : 'black',
    color: theme ? 'black' : 'white',    
  }
  
  const toggleTheme = () => {
    setTheme(!theme);
  }

  return (
    <>
      <button onClick={toggleTheme}>Toogle</button>
      <div style={themeStyles}>
        <h1>Texto de exemplo</h1>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

----------------

Outra forma:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: boolean;
  setTheme: (value: boolean) => void;
  toggleTheme: () => void;
}

export const Contexto = createContext<IContexto>({
  theme: true,
  setTheme: () => {},
  toggleTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<boolean>(true);

  const toggleTheme = () => {
    setTheme(!theme);
  }

  return (
    <Contexto.Provider value={{ theme , setTheme, toggleTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {theme, toggleTheme} = useContext(Contexto)

  const themeStyles = {
    backgroundColor: theme ? 'white' : 'black',
    color: theme ? 'black' : 'white',    
  }

  return (
    <>
      <button onClick={toggleTheme}>Toogle</button>
      <div style={themeStyles}>
        <h1>Texto de exemplo</h1>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

--------------------- ###
Toggle com useContext e strings:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: string | null;
  setTheme: (value: string) => void;
  toggleTheme: () => void;
}

export const Contexto = createContext<IContexto>({
  theme: "light",
  setTheme: () => {},
  toggleTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<string | null>("light");

  const toggleTheme = () => {
    if (theme === "light") {
      return setTheme("dark");
    }
    return setTheme("light");
  };

  return (
    <Contexto.Provider value={{ theme, setTheme, toggleTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "../components/ComponentePai";

export const ComponenteFilho = () => {
  const {theme, toggleTheme} = useContext(Contexto);

  return (
    <>
      <div
        style={{
          backgroundColor: theme === "light" ? "#eee" : "#333",
          color: theme === "dark" ? "#eee" : "#333",
        }}
      >
        <h1>Tema atual: {theme}</h1>
        <button onClick={toggleTheme}>Toggle Theme</button>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

--------------------- ###
VIDEO: https://www.youtube.com/embed/665UnOGx3Pg?autoplay=1

CRUD com useContext:

-Arquivo UserContextProvider.tsx:

import {createContext, useState, useEffect} from 'react'

export interface User {
  nome: string;
  estado: boolean;
}

interface UserContextType {
  getUsers: User[] | null;
  addUser: {user: User} => void;
  updateUser: {id: string} => void;
  deleteUser: {id: string} => void;
}

const contextInitialValues = {
  getUsers: null,
  addUser: () => null,
  updateUser: () => null,
  deleteUser: () => null,
}

export const UserContext = createContext<UserContextType>(contextInitialValues);

interface Props {
  children: React.ReactNode;
}

export const UserProvider = (props: Props) => {
  const [users, setUsers] = useState<User[] | null>(null)

  useEffect(() => {
    setUsers([{nome: "Maria", estado: "Casada"}])    //aqui teria um fetch
  }, [])

  const addUser = (user: User) => null
  const updateUser = (id: string) => null
  const deleteUser = (id: string) => null

  return (
    <UserContext.Provider value={{getUsers, addUser, updateUser, deleteUser}}>
      {props.children}
    </UserContext.Provider>
  )
}

-Arquivo User.tsx:

import {useContext} from 'react'
import {UserContext} from './UserContextProvider'


interface Props {
  nome: string;
  estado: boolean;
}

export default function User ({nome}: Props) {

  const {getUsers, addUser, updateUser, deleteUser} = useContext(UserContext)

  return (
    <div>
      <h1>{nome}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import User from "./User"
import {UserProvider} from "./UserContextProvider"

export default function App() {
  return (
    <UserProvider>
      <User nome={"Bruno"} estado={true} />
    </UserProvider>
  )
}

////////////////////////////////////////////////////////////////// &&&
JSX.Element

export default function Componente() {
  return (
    <>
      <div>
        <h1>Texto</h1>
      </div>
    </>
  )
}

O tipo de saída de uma função de Componente é React.JSX.Element pois dentro do return há elementos de JSX (nas tags HTML).
Mas não é preciso especificá-lo pois o Typescript já assume o tipo.
Portanto o código acima é o mesmo que:

export default function Componente(): React.JSX.Element {
  return (
    <>
      <div>
        <h1>Texto</h1>
      </div>
    </>
  )
}

Se remover os elementos JSX dentro da função, o tipo de saída passará a ser any:

export default function Teste(): any {
  return ()
}

//////////////////////////////////////////////////////////////// &&&
REACT.FC COM PROPS E INTERFACES

React.FC is a type that stands for "Function Component" in React. 
It is a generic type that allows you to specify the props that a function component will accept.

Using React.FC can be helpful for a number of reasons:

It provides type safety for the props that a component expects to receive. 
This can help catch bugs early on and make your code easier to understand.

It makes it easier to refactor your component's props. 
For example, if you want to rename a prop, the TypeScript compiler will catch any places where that prop is used and help you update them.

It makes it easier to see the expected shape of a component's props just by looking at its type definition.

------------ ###

import React from 'react';

const App: React.FC = () => {
  return (
    <>
      ...
    </>
  );
};

export default App;

------------ ###

-Arquivo App.tsx:

import {Teste} from './components/Teste'

export default function App() {
  return (
    <>
      <Teste nome={"Maria"} />
    </>
  )
}

-Arquivo Teste.tsx:  (SEM REACT.FC)

interface Props {
  nome: string;
}

export const Teste = ({nome}: Props) => {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  );
};

-Arquivo Teste.tsx:  (COM REACT.FC)

import React from 'react';

interface Props {
  nome: string;
}

export const Teste: React.FC<Props> = ({nome}) => {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  );
};

OBS: Não é possível usar desta forma como função:

export function Teste({nome}: React.FC<Props>) {
  ...
}

//////////////////////////////////////////////////////////////// &&& 
STYLES CSS COM PROPS EM TYPESCRIPT

-Arquivo Teste.tsx:

interface TextoProps {
  txt: {
    fontSize: number;
    textColor: string;
  }
}

export default function Button({txt}: TextoProps) {
  return (
    <h1 style={txt}>TEXTO VERMELHO</h1>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {
  return (
    <>
      <Teste txt={{fontSize: 18, textColor: "red"}} />
    </>
  )
}

--------------------------- ###

-Arquivo Button.tsx:

type ButtonProps = {
  estilo: {
    backgroundColor: string;
    fontSize: number;
    textColor: string;
  }
}

export default function Button({estilo}: ButtonProps) {
  return (
    <button style={estilo}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {
  return (
    <>
      <Button 
        estilo={{
          backgroundColor: "red",
          fontSize: 24,
          textColor: "white",         
        }}
      />
    </>
  )
}

------------------------------------------ ### &&&
React.CSSProperties 

Serve para passar propriedades CSS. Utiliza o mesmo linguajar do CSS, portanto possui algumas mudanças, como:
color: "red";                     (e não textColor: "red";) 
borderColor: "black";       (só aceita strings e não numbers)

---------------- %%%

-Arquivo Button.tsx:

type ButtonProps = {
  estilo: React.CSSProperties;
}

export default function Button({estilo}: ButtonProps) {
  return (
    <button style={estilo}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {
  return (
    <>
      <Button 
        estilo={{
          backgroundColor: "red",
          fontSize: 24,
          color: "white",  
          padding: "1rem 2rem",
          borderRadius: 8,
          borderColor: "transparent", 
        }}
      />
    </>
  )
}

------------------------------------------ ###

-Arquivo Button.tsx:

type ButtonProps = {
  borderRadius: Record<string, number>
}

export default function Button({borderRadius}: ButtonProps) {
  return (
    <button style={borderRadius}>CLIQUE</button>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App() {
  return (
    <>
      <Button 
        borderRadius={{                //Só aceita padrão <string, number>
          topLeft: 5,                  
          topRight: 5,
          bottomLeft: 10,
          bottomRight: 10,
          fontSize: 19,
        }}
      />
    </>
  )
}

------------------------------------- ### &&&
EXPORTANDO E IMPORTANDO TYPES 

Colocando estilos em um arquivo separado:
VIDEO: https://www.youtube.com/embed/TPACABQTHvM


-Arquivo types.ts dentro de uma pasta chamada lib:

export type Cores = "red" | "blue" | "green";

¨¨¨¨
-Arquivo Button.tsx:

import {type Cores} from "../lib/types";

type ButtonProps = {
  cor: Cores;
}

export default function Button({cor}: ButtonProps){
  return (
    <>
      <button style={{color: cor}}>CLIQUE</button>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import Button from "./components/Button"

export default function App(){
  return (
    <>
      <Button cor={"red"} />
    </>
  )
}

OBS: Não é obrigatório colocar a palavra type dentro dos colchetes:
import {Cores} from "../lib/types";

Porém, é recomendado deixar mais explícito que é um type e não uma variável:
import {type Cores} from "../lib/types";

//////////////////////////////////////////////////////////////// &&& 
TAILWIND

Instalação:
npm install tailwindcss @tailwindcss/vite

¨¨¨¨
No arquivo vite.config.ts adicione o tailwind:

import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'
export default defineConfig({
  plugins: [
    react(),                //opcional
    tailwindcss(),
  ],
})

¨¨¨¨

Importação:
@import "tailwindcss";

¨¨¨¨
Remova o css de App.css e index.css se necessário.

//////////////////////////////////////////////////////////// &&&
TODO LIST NO TYPESCRIPT

Exemplo simples no Replit:

import React, { useState } from 'react';

export default function App() {
  
  const [todos, setTodos] = useState<string[]>([]);
  const [newTodo, setNewTodo] = useState('');

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setNewTodo(event.target.value);
  };

  const addTodo = () => {
    if (newTodo.trim() !== '') {
      setTodos([...todos, newTodo]);
      setNewTodo('');
    }
  };

  const removeTodo = (index: number) => {
    const newTodos = [...todos];
    newTodos.splice(index, 1);
    setTodos(newTodos);
  };

  return (
    <div>
      <input
        type="text"
        value={newTodo}
        onChange={handleInputChange}
        placeholder="Add new todo"
      />
      
      <button onClick={addTodo}>Add</button>
      
      <ul>
        {todos.map((todo, index) => (
          <li key={index}>
            {todo}
            <button onClick={() => removeTodo(index)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

------------------------------------------------ ###





