 
////////////////////////////////////////////////////////// &&& ###
TYPESCRIPT SOZINHO (SEM REACT OU NEXTJS)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4

instalação do Typescript
npm install -g typescript

Na pasta do projeto, digite:
tsc --init

Será gerado o arquivo tsconfig.json

//////////////////////////////////////////////// &&& ###
Rodando o arquivo:

Na pasta do arquivo, digite no terminal:
tsc

Será gerado o arquivo teste.js que compilará o arquivo typescript em javascript

-------

-Arquivo teste.ts:

let name: string = "Carlos";

console.log(name);

Para rodar o codigo javascript compilado:
-No terminal, dentro da pasta do arquivo, digite:
node teste.js

-------------------

Então, sempre antes de rodar o arquivo, digite tsc para atualizar o arquivo .js 
Depois rode o arquivo com: node nome_do_arquivo.js

////////////////////////////////////////////////////////// &&& ###
VARIAVEIS

Modo javascript:
let id = 5;

Modo typescript:
let id: number = 5;

É preciso especificar o tipo de variavel.

let name: string = "Carlos";
let isPublished: boolean = true;

//////////////////////////////////////////////// &&& ###
TIPOS DE VARIÁVEIS

const nome: string = "Carlos";
const idade: number = 30;
const status: boolean = true;
const vazio: null = null;
const indefinido: undefined = undefined;

Caso o tipo errado seja atribuído, o typescript mostrará o erro, mas o código rodará normalmente no browser:

const nome: number = "Carlos"

/////////////////////////////////////////////////////////////// &&&
TIPO ANY

Para aceitar qualquer tipo de variavel: (Use apenas se não souber o tipo da variavel!)
let x: any = "pedro";
let x: any = 40;
let x: any = true;
let x: any = [];

//////////////////////////////////////////////// &&& ###
FUNÇÕES
Tipos de variaveis em funções:

Strings:

Forma errada:

const juntarValores = (a, b) => {
  return a + b;
}

console.log(juntarValores("Ana ", "Maria"))
>>> Ana Maria

---------
Forma correta:

const juntarValores = (a: string, b: string) => {
  return a + b;
}

console.log(juntarValores("Ana ", "Maria"))
>>> Ana Maria

------------------ ###
Números:

const juntarValores = (a: string , b: string) => {
  return a + b;
}

console.log(juntarValores("10", "5"))      //Soma de strings
>>> 105

-------

const juntarValores = (a: number, b: number) => {
  return a + b;
}

console.log(juntarValores(10, 5))       //Soma de números
>>> 15

------------------- ###

Definindo o valor de saída:

const juntarValores = (a: number, b: number):number => {
  return a + b;
}

console.log(juntarValores(10, 5))
>>> 15

---------

const juntarValores = (a: string, b: string):string  => {
  return a + b;
}

console.log(juntarValores("10", "5"))
>>> 105

---------

const juntarValores = (a: number, b: number, c: string):string  => {
  return a + b + c;
}

console.log(juntarValores(10, 5, " anos"))
>>> 15 anos

----------------------- ###

function funcao(mensagem: string) {
  return mensagem
}

export default function App() {
  return (
    <>
      <h1>{funcao("Texto da mensagem")}</h1>
    </>
  )
}

----------------------------- ###
O valor de saída não precisa necessariamente ser um tipo (string, number, etc.):

function Maioridade(idade: any): "Maior de idade" | "Menor de idade" | "Não sei" {
  if (idade >= 18) {
    return "Maior de idade"
  } else if (idade <18) {
    return "Menor de idade"
  } else {
    return "Não sei"
  }
}

export default function App() {
  return (
    <div>
      <h1>{Maioridade(20)}</h1>
    </div>
  );
}

-------------------------------------- ###
TIPO VOID

Para funções que não possuem um valor de retorno, o seu será void:

function Pessoa(nome: string): void {
  alert(`Olá, ${nome}`);                  //OU console.log(`Olá, ${nome}`);
}

export default function App() {
  return (
    <>
      <button onClick={() => Pessoa("João")}>Clique aqui</button>
    </>
  );
}

//////////////////////////////////////////////// &&& ###
TYPE ALIAS 

É possível criar um tipo persolnalizado em funções:

Exemplos:
type UserName = string;
type Point = { x: number; y: number; };
type Status = "success" | "error" | "pending";

------------------ ###

type Ano = number

const carYear: Ano = 2001

export default function App() {
  return (
    <>
      <h1>{carYear}</h1>
    </>
  );
}

-------

type Ano = number
type Tipo = string
type Modelo = string
type Carro = {
  year: Ano,
  type: Tipo,
  model: Modelo
}

const carYear: Ano = 2001
const carType: Tipo = "Toyota"
const carModel: Modelo = "Corolla"
const car: Carro = {
  year: carYear,
  type: carType,
  model: carModel
};

export default function App() {
  return (
    <>
      <h1>{carYear}</h1>
      <h1>{carType}</h1>
      <h1>{carModel}</h1>
      <p>{car.year} - {car.type} - {car.model}</p>
    </>
  );
}

-------------- ###
Type alias em funções:

type Soma = (a: number, b: number) => number;

const add: Soma = (a, b) => {
  return a + b;
};

export default function App() {
  return (
    <div>
      <h1>{add(5, 3)}</h1>
    </div>
  )
}

------------- ###

type Pessoa = {
  nome: string;
};

function Hello(pessoa: Pessoa) {
  return `Olá, ${pessoa.nome}`;
}

function Goodbye(pessoa: Pessoa) {
  return `Adeus, ${pessoa.nome}`;
}

export default function App() {
  return (
    <>
      <h1>{Hello({ nome: "João" })}</h1>
      <p>{Goodbye({ nome: "João" })}</p>
    </>
  );
}

--------------- ###

type TiposDeID = string | number;

const printID = (id: TiposDeID) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");
>>> ID: 123

---------
Interfaces are similar to type aliases, except they only apply to object types.

Example
interface Rectangle {
  height: number,
  width: number
}

const rectangle: Rectangle = {
  height: 20,
  width: 10
};

--------------------------------------- ###
IMPORTANDO TYPE ALIAS 

-Arquivo models.ts:

export type Soma = (a: number, b: number) => number;
export type Nome = (nome: string, sobrenome: string) => string;

¨¨¨¨
-Arquivo App.tsx:

import type {Soma, Nome} from "./models"
// ou import {type Soma, type Nome} from "./models"

const add: Soma = (a, b) => {
  return a + b;
};

const pessoa: Nome = (nome, sobrenome) => {
  return `${nome} ${sobrenome}`;
};

export default function App() {
  return (
    <div>
      <h1>{add(5, 3)}</h1>
      <h1>{pessoa("João", "Silva")}</h1>
    </div>
  )
}

/////////////////////////////////////////////////////// &&&
INTERFACE

Modo javascript:

const User = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = 40                 //tipo number

console.log(User.age)
>>> 40

Se aplicasse esse código no typescript, ele até funcionaria, mas não é o ideal.
Teríamos problemas com o código abaixo, por exemplo:

const User = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = "40"                //tipo string

console.log(User.age)
>>> ERRO!!!

--------- ###

Modo typescript usando interface:

interface UserInterface {
  id: number;
  name: string;
  age: number;
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
  age: 22,
}

User.age = 40           //tipo number

console.log(User.age)
>>> 40

------------------------- ### &&&
Interface com campos faltando: (campo opcional)

interface UserInterface {
  id: number;
  name: string;
  age?: number;       //adicione uma ? para o campo ser opcional
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
}

console.log(User.age)
>>> undefined

------
Adicionando uma condicional:

interface UserInterface {
  id: number;
  name: string;
  age?: number;       
}

const User: UserInterface = {
  id: 2,
  name: "Pedro",
}

if (!User.age){
  console.log("Idade não foi informada")
} else {
  console.log(User.age)
}

>>> Idade não foi informada

--------------------------- ###

Interface com funções:

Modo javascript:

const User = {
    funcao(mensagem) {
        console.log(mensagem);
    }
};
User.funcao("Texto da mensagem");
>>> Texto da mensagem

----

Modo typescript:

interface UserInterface {
  funcao(mensagem: string): void;     
}

const User: UserInterface = {
  funcao(mensagem) {
    console.log(mensagem);
  }
}

User.funcao("Texto da mensagem")
>>> Texto da mensagem

----

Os nomes dos parametros na interface não precisam ser exatamente os mesmos:

interface UserInterface {
  funcao(mensagem: string): void;  
}

const User: UserInterface = {
  funcao(msg) {
    console.log(msg);
  }
}

User.funcao("Texto da mensagem")

------

interface SomaInterface {
  Somar(a: number, b: number): void;     
}

const Adicao: SomaInterface = {
  Somar(a, b) {
    console.log(a + b);
  }
}

Adicao.Somar(2, 5)
>>> 7

----------

É possível colocar os tipos dentro da função também:

interface UserInterface {
  funcao(mensagem: string): void;  
}

const User: UserInterface = {
  funcao(mensagem: string): void {
    console.log(mensagem);
  }
}

User.funcao("Texto da mensagem")
>>> Texto da mensagem

////////////////////////////////////////// &&& ###
LIDANDO COM TIPOS DE VARIAVEIS INCERTAS EM FUNÇÕES

Modo javascript:

const printID = (id) => {
  console.log("ID: " + id);
};

printID("123");        //OU printID(123);   
>>> ID: 123

-----

Modo typescript:

const printID = (id: number) => {      
  console.log("ID: " + id);
};

printID(123);   
>>> ID: 123

OU

const printID = (id: string) => {      
  console.log("ID: " + id);
};

printID("123");   
>>> ID: 123

//////////////////////////////////////////////// &&& ###
UNION
Aceita um tipo ou outro tipo

Porém, e se não souber qual tipo de dados virá para o parâmetro?
É possível usar o | (significa ou) para resolver o problema:

const printID = (id: string | number) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");       
>>> ID: 123

------
Colocando as opções de tipos em uma variavel: (type alias)

type TiposDeID = string | number;

const printID = (id: TiposDeID) => {      
  console.log("ID: " + id);
};

printID(123);       //OU printID("123");
>>> ID: 123

///////////////////////////////////////////////// &&&
INTERSECTIONS 
Juntar os campos de mais de uma interface

interface Dados1 {
  nome: string;
}

interface Dados2 {
  idade: number;
}

type TodosDados = Dados1 & Dados2;

const InfoPessoa = (pessoa: TodosDados):void => {
  console.log(`${pessoa.nome} tem ${pessoa.idade} anos`)
}

InfoPessoa({
  nome: "Carlos", 
  idade: 32
})

///////////////////////////////////////////////&&&
PARAMETROS OPCIONAIS (?) EM FUNÇÕES

Ao colocar ? no parametro, ele automaticamente passa a aceitar o tipo undefined também.

function pessoa(nome: string, sobrenome?: string): string {
  if (sobrenome) {
    return `Olá, ${nome} ${sobrenome}.`;
  }
  return `Olá, ${nome}.`
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("João")}</h1>
    </div>
  )
}

Atenção!!!
O parâmetro opcional NUNCA pode ser o primeiro a ser passado! Por exemplo:

function pessoa(sobrenome?: string, nome: string): string {
  ...
}

Os parâmetros opcionais serão sempre os últimos a serem passados.

/////////////////////////////////////////////////////// ### &&&
DEFAULT PARAMS (PARAMETROS INICIAIS) EM FUNÇÕES

function pessoa(nome: string, sobrenome: string = "Sem nome"): string {
  return `Nome: ${nome} - Sobrenome: ${sobrenome}.`;
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("João")}</h1>
    </div>
  )
}

---------
Não é necessário especificar o tipo da variavel se declarar um valor inicial para ela

function Texto (txt = "Texto de exemplo"): void {
  alert(txt)
}

export default function App() {
  return (
    <div>
      <button onClick={() => Texto()}>Clique aqui</button>
    </div>
  )
}

/////////////////////////////////////////////// &&&
PARAMETROS LITERAIS EM FUNÇÕES

function pessoa(nome: "João") {
  if(nome === "João") {
    return `Olá, ${nome}.`;
  }
  return "Nome inválido!"
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("Carlos")}</h1>
    </div>
  )
}

Dará Nome inválido pois foi especificado que a variavel nome só pode aceitar o valor João.
O typescript apresentará um erro sinalizando que o valor passado é diferente do especificado.

É possível declarar mais de um tipo de valor para o parametro:

function pessoa(nome: "João" | "Carlos") {
  if(nome === "João") {
    return `Olá, ${nome}.`;
  }
  return "Nome inválido!"
}

export default function App() {
  return (
    <div>
      <h1>{pessoa("Carlos")}</h1>
    </div>
  )
}

>>> Olá, Carlos.

------------------------ ###
Armazenando em um type alias:

type Direction = "norte" | "sul" | "leste" | "oeste"

function Mover(caminho: Direction) {
  alert(`Foi para a direção ${caminho}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => Mover("norte")}>Mover</button>  
    </div>
  )
}

---------

type Prioridade = 1 | 2 | 3

function setPrioridade (nivel: Prioridade) {
  switch(nivel) {
    case 1 : {
      return alert("Prioridade baixa")
    }
    case 2 : {
      return alert("Prioridade média")
    }
    case 3 : {
      return alert("Prioridade alta")
    }
    default:
      return alert("Prioridade não estabelecida")
  }
}

export default function App() {
  return (
    <div>
      <button onClick={() => setPrioridade(3)}>Enviar</button>  
    </div>
  )
}

---------------------------- ###
SUPER UNION TYPE ALIAS

type estadoCivil = "casado" | "solteiro" | "divorciado" | string

function handleClick(status: estadoCivil) {
  alert(`Fulano é ${status}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick("viúvo")}>Enviar</button>  
    </div>
  )
}

------------------------------- ###
TEMPLATE LITERAL UNIONS
juntar mais de 1 type alias

type Sobrenome = "Silva" | "Souza" | "Costa"
type Nome = `Carlos ${Sobrenome}`

function handleClick(username: Nome) {
  alert(`Olá, ${username}`)
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick("Carlos Silva")}>Enviar</button>  
    </div>
  )
}

OBS: Cuidado com muitos tipos de template unions pois pode causar erro devido a quantidade gigante de variações que o sistema terá que guardar.

//////////////////////////////////////////////// &&& ###
ARRAYS

Criando variaveis:

let ids: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Ana", "Bruno", "Carlos"];
let ArrayVariado: any[] = ["pedro", 0, true];

-----
O tipo any evolve com o passar de informações em arrays:

let lista = []      // lista: any[]
lista.push(3)       // lista: number[]
lista.push("A")     // lista: (number | string)[]

/////////////////////////////////////////////// &&&
ARRAYS HETEROGENEOS

function handleClick(elementos: string | number) {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista = [1, 2, "A", "B"]       //Typescript irá inferir que é um tipo (string | number)[]
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}


¨¨¨¨ //Forma correta

function handleClick(elementos: (string | number)[]) {         
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista = [1, 2, "A", "B"]       
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}

OU

function handleClick(elementos: (string | number)[]) {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const lista: (string | number)[] = [1, 2, "A", "B"]     
  
  return (
    <div>
      <button onClick={() => handleClick(lista)}>Enviar</button>  
    </div>
  )
}

/////////////////////////////////////////////// &&&
ARRAYS EM PARAMETROS DE FUNÇÕES

Recebendo um array como parametro de uma função:

const printID = (id: number[]): void => {      
  console.log("IDs: " + id);
};

printID([1, 2, 3]); 
>>> IDs: 1,2,3

---------------- ###

function handleClick(frutas: string[]): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}

export default function App() {
  const frutas = ["Banana", "Uva", "Morango"]

  return (
    <div>
      <button onClick={() => handleClick(frutas)}>Enviar</button>  
    </div>
  )
}

--------------- ###

Arrays dentro de arrays também é válido:

function handleClick(cidades: string[][]): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

export default function App() {
  const cidades = [["RJ", "Rio de Janeiro"], ["SP", "São Paulo"], ["MG", "Belo Horizonte"]]

  return (
    <div>
      <button onClick={() => handleClick(cidades)}>Enviar</button>  
    </div>
  )
}

-------------------- ###
Usando junto com UNION:

function handleClick(elementos: (string | number)[]): void {
  elementos.map(elemento => {
    console.log(elemento)
  })
}

export default function App() {
  const elementos = ["Casa", 18, "Morango", 13]

  return (
    <div>
      <button onClick={() => handleClick(elementos)}>Enviar</button>  
    </div>
  )
}

--------------------- ###

function averageScore(ratings: number[]): void {
  if (ratings.length === 0) return 0
  const soma: number = ratings.reduce((sum, rating) => sum + rating, 0) 
  alert(soma / ratings.length)
}

export default function App() {
  const ratings = [7, 11, 42]

  return (
    <div>
      <button onClick={() => averageScore(ratings)}>Enviar</button>  
    </div>
  )
}

>>> 20       (7 + 11 + 42 dividido por 3)

//////////////////////////////////////////////////// &&&
READONLY ARRAYS (NÃO PODEM SER MODIFICADOS)

const cores = ["azul", "verde", "roxo"] as const             //cores passa a ser readonly e não pode ser modificado

cores.push("laranja")                                        //Mostrará erro no typescript

/////////////////////////////////////////////// &&&
TYPE PARAMETERS PARA ARRAYS COMO PARAMETROS EM FUNÇÔES

É um modo genérico de indicar o tipo de um array em uma função

function handleClick(frutas: Array<string>): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}

export default function App() {
  const frutas = ["Banana", "Uva", "Morango"]

  return (
    <div>
      <button onClick={() => handleClick(frutas)}>Enviar</button>  
    </div>
  )
}


É o mesmo que:

function handleClick(frutas: string[]): void {
  frutas.map(fruta => {
    console.log(fruta)
  })
}
...

------------- ###

Arrays dentro de arrays também é válido:

function handleClick(cidades: Array<Array<string>>): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

É o mesmo que:

function handleClick(cidades: string[][]): void {
  cidades.map(cidade => {
    console.log(`${cidade[0]} - ${cidade[1]}`)
  })
}

const cidades = [["RJ", "Rio de Janeiro"], ["SP", "São Paulo"], ["MG", "Belo Horizonte"]]

handleClick(cidades)

///////////////////////////////////////////////&&&
REST PARAMETERS EM FUNÇÕES (PARÂMETROS REST) ...REST

Permite um número indefinido de argumentos:

function Mostrar(...pessoas: string[]) {
  return `${pessoas.join(", ")}`;
}

export default function App() {
  return (
    <div>
      <p>{Mostrar("Maria", "Carlos", "Ana")}</p>
    </div>
  )
}

OU

function Mostrar(...pessoas: string[]) {
  pessoas.map(pessoa => {
    console.log(pessoa)
  })
}

export default function App() {
  return (
    <div>
      <button onClick={() => Mostrar("Maria", "Carlos", "Ana")}>Mostrar</button>
    </div>
  )
}

¨¨¨¨

function Mostrar(empresa: string, ...funcionario: string[]) {
  return `Empresa: ${empresa} - Funcionarios: ${funcionario.join(", ")}`;
}

export default function App() {
  return (
    <div>
      <p>{Mostrar("Santander", "Maria", "Carlos", "Ana")}</p>
    </div>
  )
}

///////////////////////////////////////////////&&& 
OBJETOS EM FUNÇÕES

Type alias para objetos literais:

type Pessoa = {
  nome: string;
  idade: number;
}

OU

type Pessoa = {
  nome: string,
  idade: number,
}

OU

type Pessoa = {
  nome: string
  idade: number
}

¨¨¨¨
Atenção!!! 
Não pode:

type Pessoa = {
  nome: string idade: number      //ERRADO!
}

type Pessoa = {
  nome: string , idade: number      //CORRETO!
}

type Pessoa = {
  nome: string ; idade: number      //CORRETO!
}

type Pessoa = {
  nome: string ; idade: number , status: boolean      //CORRETO!
}

------------------------ ###

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.nome);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "João", 
    idade: 33
  };
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

------------------------ ###
Propriedades/Campos extras em objetos como parametros:

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 33, 
    status: "Casada",
  }
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

-Irá imprimir o resultado, mas o typescript apontará erro pois não existe status no type Pessoa

--------

type Pessoa = {
  nome: string;
  idade: number;
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  return (
    <div>
      <button onClick={() => handleClick({nome: "Maria", idade: 33, status: "Casada" })}>CLIQUE</button>
    </div>
  );
}

-Irá imprimir o resultado, mas o typescript apontará erro pois não existe status no type Pessoa
(NO TYPESCRIPT PURO DARÁ ERRO!!!)

-------------------------------------------- ###
PARAMETROS OPCIONAIS (?) EM OBJETOS EM FUNÇÕES

type Pessoa = {
  nome: string;
  idade: number;
  status?: string;           //Parametro opcional. É o equivalente a:    string | undefined
}

function handleClick(funcionario: Pessoa) {
  console.log(funcionario.status);
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 33, 
  }
  
  return (
    <div>
      <button onClick={() => handleClick(funcionario)}>CLIQUE</button>
    </div>
  );
}

-Se pedisse para mostrar funcionario.status, daria undefined

--------------------------------------- ###
Type Alias em objetos vazios:

const pessoa = {}
pessoa.nome = "Maria"     // Dará erro

let pessoa = {}
pessoa = "Maria"          // OK

----------

function handleClick() {
  let pessoa = {};
  pessoa = "João";
  console.log(pessoa);
}

export default function App() {
  return (
    <div>
      <button onClick={() => handleClick()}>CLIQUE</button>
    </div>
  );
}

------------------------------------------- ###
DISCRINATED UNIONS EM OBJETOS

type RJ = {
  ddd: 21;
  sigla: string;
  capital: string;
}

type SP = {
  ddd: 11;
  sigla: string;
  capital: string;
}

type Estados = RJ | SP;

function handleClick(estado: Estados): void {
  console.log(estado.capital);
}

export default function App() {

  const rio: Estados = {
    ddd: 21,                       //Só aceitará 11 ou 21
    sigla: "RJ",
    capital: "Rio de Janeiro"
  }

  return (
    <div>
      <button onClick={() => handleClick(rio)}>CLIQUE</button>
    </div>
  );
}

---------------- %%%

type RJ = {
  ddd: 21;
  sigla: string;
  capital: string;
}

type SP = {
  ddd: 11;
  sigla: string;
  capital: string;
}

type Estados = RJ | SP;

function Mostrar(estado: Estados): string {
  switch (estado.ddd){
    case (11):
      return "São Paulo"
    case (21):
      return "Rio de Janeiro"
    default:
      return "Outro estado"
  }
}

export default function App() {

  const rio: Estados = {
    ddd: 21,                       
    sigla: "RJ",
    capital: "Rio de Janeiro"
  }

  return (
    <div>
      <h1>{Mostrar(rio)}</h1>
    </div>
  );
}

------------------ %%%

Union em objetos pode ser usado ao tratar reultados de busca de dados de uma API, por exemplo:

type Loading = {status: "loading"}
type Error = {status: "loading"; error: number}
type Success = {status: "loading"; data: string}

type Result = Loading | Error | Success;

------------------------------------------------- ### &&&
SETS EM OBJETOS
Sets = coleção de valores únicos


function Mostrar(): string {
  const pessoa = new Set<string>(["Maria", "João"]);
  pessoa.add("Pedro");
  pessoa.delete("João");
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Maria, Pedro

---------------- %%%

function Mostrar(): string {
  const pessoa = new Set<string>();               //Set vazio
  pessoa.add("Pedro");                            
  pessoa.add("Maria");
  pessoa.add("Pedro");                              //O Set ignora objetos já existentes
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Pedro, Maria

---------------- %%%

Com Set, usamos:

objeto.add() = para adicionar
objeto.delete() = para remover
objeto.size = para saber o tamanho

---------------- %%%

Não consegui fazer funcionar passando o set como parâmetro.
Então faria da forma normal mesmo:

function Mostrar(pessoas: string[]): void {
  pessoas.forEach((pessoa: string) => {
    console.log(pessoa)
  })
}

export default function App() {

  const pessoas: Pessoas = ["Maria", "João"];
  pessoas.push("Pedro");
  pessoas.splice(pessoas.indexOf("João"), 1);

  return (
    <div>
      <button onClick={() => Mostrar(pessoas)}>CLIQUE</button>
    </div>
  );
}

OU

function Mostrar(pessoas: string[]): void {
  pessoas.forEach((pessoa: string) => {
    console.log(pessoa)
  })
}

export default function App() {

  const pessoas = ["Maria", "João"];
  pessoas.push("Pedro");
  pessoas.splice(pessoas.indexOf("João"), 1);

  return (
    <div>
      <button onClick={() => Mostrar(pessoas)}>CLIQUE</button>
    </div>
  );
}

--------------- %%%
Set aceitando mais de 1 tipo:

function Mostrar(): string {
  const pessoa = new Set<string | number>();
  pessoa.add("Pedro");
  pessoa.add(13);
  return `Nomes: ${Array.from(pessoa).join(', ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Nomes: Pedro, 13


--------------------------------------------------- ### &&&
MAPS COM OBJETOS

const objeto = new Map<string, number>(key, value)

objeto.set("Chave", 1)

Obs: A key é usada para identificar o objeto. É com ela que deletamos um objeto.

------------- %%%

Caso seja informado um valor inicial para o map, não é preciso especificar o tipo da key e do value:

const objeto = new Map([["Chave1", "Valor1"]])            //Typescript entendeu que o tipo será <string, string>

------------ %%%

function Mostrar(): string {
  const pessoa = new Map<string, string>();
  pessoa.set("Pedro", " 20 anos");
  pessoa.set("Maria", " 25 anos");
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Pedro, 20 anos - Maria, 25 anos

-------------- %%%

function Mostrar(): string {
  const pessoa = new Map([["João", 15]]);             //Typescript entende que será <string, number>
  pessoa.set("Pedro", 13);
  pessoa.set("Maria", 19);
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> João,15 - Pedro,13 - Maria,19

---------------- %%%

function Mostrar(): string {
  const pessoa = new Map([["Carlos", "18 anos"]]);             //tipo <string, string>
  pessoa.set("Pedro", " 20 anos");
  pessoa.set("Maria", " 25 anos");
  pessoa.set("Carlos", " 18 anos");                  //O Map ignora objetos já existentes
  pessoa.delete("Pedro")
  return `${Array.from(pessoa).join(' - ')}`
}

export default function App() {

  return (
    <div>
      <h1>{Mostrar()}</h1>
    </div>
  );
}

>>> Carlos, 18 anos - Maria, 25 anos

-------------------------------------------- ### &&&
DYNAMIC KEYS COM OBJETOS 
(Chaves dinâmicas que podem ser strings ou numeros)

type Pessoa = {
  [chave: string]: number;                          //chave de qualquer tipo e valor do tipo number
}

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.idade);                   //imprime a chave do tipo string
  console.log(funcionario[75]);                     //imprime a chave do tipo number
  //console.log(funcionario.nome);                  //Dará erro
}

export default function App() {

  const funcionario: Pessoa = {
    idade: 33,                                      //chave do tipo string
    75: 22,                                         //chave do tipo number
    //nome: "Carlos",                               //Dará erro pois o valor precisa ser number
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

--------------------------- %%%

type Pessoa = {
  [chave: string]: number;                          
}

function Mostrar(funcionario: Pessoa): void {
  funcionario["idade"] = 18                      //Alterou o valor de idade
  console.log(funcionario.idade);                   
}

export default function App() {

  const funcionario: Pessoa = {
    idade: 33,  
    cpf: 12345678900,
    tel: 21998765432                                      
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

>>> 18

-------------------------------- ### &&&
OBJETOS
RECORD

type Pessoa = Record<string, number>

É o mesmo que:

type Pessoa = {
  [chave: string]: number;                          
}

------------------------------------- ### &&&
OBJETOS
DYNAMIC DEFAULT PROPERTIES
(Utilize com cuidado este tipo de abordagem, pois provavelmente deve haver uma maneira melhor de lidar com este caso.)

Além de chaves dinâmicas, é possível incluir outros tipo de propriedades:

type Pessoa = {
  [campoextra: string]: string, 
  nome: string,
  idade: number,
}

-----

type FormData = {
  [field: string]: string, 
  email: string,
  password: string,
}

-----

type FormData = {
  [field: string]: string | number | boolean, 
  email: string,
  password: string,
  age: number
}

--------------------------------------------- ### &&&
OBJETOS
PROPERTY KEYS
(raramente usado)
VIDEO: https://www.youtube.com/embed/K01hLNDdqg4?autoplay=1

type PropertyKey = string | number | symbol

----

type Tags = {
  [key: string]: any,
}

const server: Tags = {
  name: "Jane's server",
  1: 420,
  [Symbol("role")]: "Admin"
}

----------------------------------------------- ### &&&
OBJETOS
READONLY MODIFIER

Parecido com const em Javascript, fazendo com que um objeto possa apenas ser lido e não alterado

type Pessoa = {
  readonly nome: string,      //Não pode ser modificado
  idade: number,              //Pode ser modificado
}

---------

type Pessoa = {
  readonly nome: string,      
  idade: number,              
}

function Mostrar(funcionario: Pessoa): void {
  funcionario.nome = "Maria";                                  //Typescript dará erro apontando que não pode modificar 
  funcionario.idade = 26;                                      //OK. Pode ser modificado
  console.log(funcionario.nome + " - " + funcionario.idade);                   
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "João",
    idade: 25
  }
  
  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------------------------------------- ### &&&
OBJETOS QUE NÃO MODEM SER MODIFICADOS
AS CONST 

Parecido com as const com arrays:

const cores = ["azul", "verde", "roxo"] as const             //cores passa a ser readonly e não pode ser modificado

cores.push("laranja")                                        //Mostrará erro no typescript

----------

Com objetos:

type Pessoa = {
  nome: string,
  idade: number,
} 

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.nome)              
}

export default function App() {

  const funcionario: Pessoa = {
    nome: "Maria",
    idade: 23,
  } as const;                             //objeto passa a ser readonly

  funcionario = {                         // ERRO!!! funcionario não pode ser modificado
    nome: "Carlos",
    idade: 51,
  }

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

---------------------------------------------------- ### &&&
OBJETOS QUE NÃO MODEM SER MODIFICADOS
OBJECT.FREEZE

type Pessoa = {
  nome: string,
  idade: number,
  setor: {
    cargo: string,
    turno: string,
  }
} 

function Mostrar(funcionario: Pessoa): void {
  console.log(funcionario.setor.cargo)              
}

export default function App() {

  const funcionario = Object.freeze({          //objeto passa a ser readonly
    nome: "Maria",
    idade: 23,
    setor: {
      cargo: "Auxiliar",
      turno: "Manhã",
    }
  });                                      

  funcionario = {                              // ERRO!!! funcionario não pode ser modificado
    nome: "Carlos",
    idade: 51,
    setor: {
      cargo: "Fiscal",
      turno: "Tarde",
    }
  }

  funcionario.setor.cargo = "Gerente"                 //OK, pois nested properties não são congelados

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

>>> Gerente

----------------

Object.freeze não permite modificar o objeto, mas é possível modificar ou incluir (com push) elementos aninhados dentro do objeto.

type Pessoa = {
  nomes: string[]
} 

function Mostrar(funcionario: Pessoa): void {
  funcionario.nomes.map((nome) => console.log(nome))         
}

export default function App() {

  const funcionario = Object.freeze({  
    nomes: ["Maria", "Carlos", "João"]
  });                                      

  funcionario.nomes.push("Pedro")                        

  return (
    <div>
      <button onClick={() => Mostrar(funcionario)}>CLIQUE</button>
    </div>
  );
}

------------------------------------------------------------ ###
SATISFIES

1:32:29




//////////////////////////////////////////////////////////////////////////&&& ***
ENUM

enum MENSAGENS {
  msg1 = "TextoMsg1",
  msg2 = "TextoMsg2",
  msg3 = "TextoMsg3",
}

const showMsg = (mensagem: MENSAGENS) => {
  if (mensagem == MENSAGENS.msg1) {
    console.log("TEXTO 1")
  } else if (mensagem == MENSAGENS.msg2) {
    console.log("TEXTO 2")
  } else {
    console.log("TEXTO 3")
  }
}

showMsg(MENSAGENS.msg2)

>>> TEXTO 2

-----------

enum LoginError {
  Unauthorized = "unauthorized",
  NoUser = "nouser",
  WrongCredentials = "wrongcredentials",
  Internal = "internal",
}

const printErrorMsg = (error: LoginError) => {
  if (error == LoginError.Unauthorized) {
    console.log("User not authorized")
  } else if (error == LoginError.NoUser) {
    console.log("No user was found with that username")
  } else if (error == LoginError.WrongCredentials) {
    console.log("Wrong username/password")
  } else {
    console.log("Internal Error.")
  }
}

printErrorMsg(LoginError.NoUser)

>>> No user was found with that username

-------------------------------------- ###
ENUM COM REACT

enum MENSAGENS {
  msg1 = "Texto da Mensagem1",
  msg2 = "Texto da Mensagem2",
  msg3 = "Texto da Mensagem3",
}
export default function App() {
  return (
    <>
      <h1>{MENSAGENS.msg1}</h1>
    </>
  );
}

------

Usando React.FC para tipar explicitamente o componente funcional:


import React from 'react';

enum MENSAGENS {
  msg1 = "Texto da Mensagem1",
  msg2 = "Texto da Mensagem2",
  msg3 = "Texto da Mensagem3",
}

const App: React.FC = () => {
  return (
    <>
      <h1>{MENSAGENS.msg1}</h1>
    </>
  );
};

export default App;

------------------ ###
Enum com props:

-Arquivo Teste.tsx:

interface EstadoInterface {
  estado: Estados;
}

export enum Estados {
  RJ = "Rio de Janeiro",
  SP = "São Paulo",
  MG = "Minas Gerais",
}

export const Teste = ({estado}: EstadoInterface) => {
  return (
    <div>
      <h1>{estado}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import React from 'react';
import {Teste, Estados} from './components/Teste'

const App: React.FC<Estados> = () => {
  return (
    <>
      <Teste estado={Estados.SP}/>
    </>
  );
};

export default App;

OU

import {Teste, Estados} from './components/Teste'

export default function App() {
  return (
    <>
      <Teste estado={Estados.MG}/>
    </>
  );
};


///////////////////////////////////////////// &&&
INTERFACE GENÉRICA (CONTAINER)

Uma interface pode ser passada para uma classe:

interface UserInterface {
  ...
}

class Pessoa <UserInterface> {
  ...
} 

-------- ###

Criando uma interface genérica que aceite vários tipos de dados:

class Container <T> {
  private contents: T[]

  constructor() {
    this.contents = []
  }

  addItem(item: T):void {
    this.contents.push(item)
  }

  getItem(indice: number):T | undefined {
    return this.contents[indice]
  }
}

const pessoas = new Container <string> () 
pessoas.addItem("Maria")
const p1 = pessoas.getItem(0)
console.log(p1)                    // >>> Maria

const numeros = new Container <number> ()
numeros.addItem(1)
const num1 = numeros.getItem(0)
console.log(num1)                  // >>> 1

/////////////////////////////////////////////// &&&
CAMPOS IMUTÁVEIS EM UMA INTERFACE

Para proibir que valores de certos campos de uma interface possam ser alterados:

interface PessoaInterface {
  readonly id: number;            //Não pode ser alterado
  readonly nome: string;          //Não pode ser alterado
  readonly dataInicio: Date;       //Não pode ser alterado
  idade: number;                    //Pode ser alterado
}

const funcionario: PessoaInterface = {
  id: 12345,
  nome: "Maria",
  dataInicio: new Date(),
  idade: 20,
}

funcionario.idade = 33

console.log(funcionario)

//////////////////////////////////////////////////////////////// &&&
TYPESCRIPT COM REACT
Iniciando

Instalação do react na pasta do projeto:
npm create vite@latest     //Te pedirá o nome do projeto e pacote
ou
npm create vite@latest .   //Não te pedirá o nome do projeto e pacote

Selecione React
Selecione Typescript

Serão criados os arquivos do projeto react:
pasta public
pasta src
.gitignore
eslint.config.js
index.html
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

Para instalar as dependencias (node_modules), digite no terminal:
npm install    

------------------ ###
Excluindo coisas desnecessárias:

-Arquivo App.tsx dentro da pasta src:

import './App.css'

function App() {

  return (
    <>
    
    </>
  )
}

export default App

¨¨¨
-Arquivo App.css:

#root {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box;
}

---------------- ###

Extensões de arquivos:

arquivo_com_componente.tsx
ou
arquivo_sem_componente.ts

------------------- ###

Rodando o arquivo:

Digite no terminal:
npm run dev

///////////////////////////////////////////////////////////////// &&&
Imprimindo resultados

export default function App() {

  const pessoa: string = "Carlos";

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

-------------- ###

export default function App() {

  function Pessoa(nome: string) {
    return nome;
  }

  return (
    <>
      <h1>{Pessoa("Maria")}</h1>
    </>
  )
}

---------------- ###

export default function App() {

  const Pessoa = (dados: string | number) => {
    return dados;
  }

  return (
    <>
      <h1>{Pessoa("Ana")} tem {Pessoa(33)} anos</h1>
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
Criando componente

Exportando um componente sem default:

-Arquivo Teste.tsx:

export const Teste = () => {
  return (
    <div>
      <h1>TEXTO DE EXEMPLO</h1>
    </div>
  )
}

-Arquivo App.tsx:

import {Teste} from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste />
    </>
  )
}

---------

-Exportando um componente com default:

-Arquivo Teste.tsx:

export default function Teste() {
  return (
    <div>
      <h1>TEXTO DE EXEMPLO</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste />
    </>
  )
}


///////////////////////////////////////////////////////////// &&&
PROPS E INTERFACES

-Arquivo Teste.tsx:

export default function Teste(props) {
  return (
    <div>
      <h1>{props.texto}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import "./App.css"

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste texto={"TEXTO DE EXEMPLO"}/>
      <Teste texto={23}/>
    </>
  )
}

OBS: O props aceitará qualquer tipo de variavel e mostrará o resultado na tela. 
Porém, podem ocorrer problemas em alguns casos, caso o tipo da variável não seja definido. 
Para isso é usada uma interface para definir os tipos.

---------- ###
PROPS COM INTERFACES

-Arquivo Teste.tsx:

interface TxtInterface {
  texto: string;
}

export default function Teste(props: TxtInterface) {
  return (
    <div>
      <h1>{props.texto}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste texto={"TEXTO DE EXEMPLO"} />
    </>
  )
}

------------ ###

-Arquivo Teste.tsx:

interface PessoaInterface {
  nome: string;
  idade: number;
  estado: boolean;
}

export default function Teste(props: PessoaInterface) {
  return (
    <div>
      <h1>{props.nome}</h1>
      <h1>{props.idade}</h1>
      <h1>{props.estado ? "Casada" : "Solteira"}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={23} estado={true}/>
    </>
  )
}

------------ ###

Desconstrução de props:

-Arquivo Teste.tsx:

interface NomeInterface {
  nome: string;
}

export default function Teste({nome}: NomeInterface) {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} />
    </>
  )
}

-------------------

-Arquivo teste.tsx:

interface PessoaInterface {
  nome: string;
  idade: number;
  funcao: () => void;
}

export const Teste = ({ nome, idade, funcao } : PessoaInterface) => {
  return (
    <div>
      <h1>{nome}</h1>
      <p>{idade}</p>
      <button onClick={funcao}>Clique</button>
    </div>
  );
};

-Arquivo App.tsx:

import {Teste} from './components/Teste'

function show() {
  alert("Clicou!")
}

export default function App() {
  return (
    <>
      <Teste nome={"Ana"} idade={24} funcao={show}/>
    </>
  )
}

--------------------- ### 
Props sem campos:

interface ComponenteProps {}

export default function Componente({}: ComponenteProps){
	return (
		<>
      ...
    </>
	)
}

-------------------- ### 
Aceitando mais de um tipo de variavel:

-Arquivo teste.tsx:

interface PessoaInterface {
  nome: string;
  idade: number | null;
}

export default function Teste({nome, idade}: PessoaInterface) {

  return (
    <div>
      <h1>{nome}</h1>  
      <h1>{idade}</h1>                
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"} idade={null}/> 
    </>
  )
}


//////////////////////////////////////////////////////////////// &&&
USESTATE

Modo implícito: (pode dar problema)

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState("Maria")     //Typescript vai assumir que o tipo é string

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

---------

Modo explícito: (Mais correto)

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState<string>("Maria")

  return (
    <>
      <h1>{pessoa}</h1>
    </>
  )
}

--------------- ###

Usando interfaces com useState:

interface NomeInterface {
  nome: string;
}

import {useState} from 'react'

export default function App() {
  const [pessoa, setPessoa] = useState<NomeInterface>({nome: "Maria"})

  return (
    <>
      <h1>{pessoa.nome}</h1>
    </>
  )
}


-------------- ###
UseState com Props: (exemplo 1)

-Arquivo teste.tsx:

interface NomeInterface {
  nome: string;
}

export default function Teste({nome}:NomeInterface) {

  return (
    <div>
      <h1>{nome}</h1>                      
    </div>
  )
}

-Arquivo App.tsx:

import {useState} from 'react'

import Teste from "./components/Teste"

export default function App() {

  const [pessoa, setPessoa] = useState("Ana")

  return (
    <>
      <Teste nome={pessoa} />
      <button onClick={() => setPessoa("Maria")}>Mudar</button>
    </>
  )
}

------------ ###
UseState com Props: (exemplo 2)

-Arquivo teste.tsx:

import {useState} from 'react'

interface NomeInterface {
  nome: string;
}

export default function Teste({nome}: NomeInterface) {
  const [show, setShow] = useState<boolean>(true)

  return (
    <div>
      {show && <h1>{nome}</h1>}                      //OU   <h1>{show ? {nome} : "Sem nome"}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Maria"}/>
    </>
  )
}

------------------------ ###
UseState com Props: (exemplo 3)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  estado: boolean;
}

export default function Teste(props: PessoaInterface) {
  const [show, setShow] = useState<boolean>(props.estado)

  return (
    <div>
      <h1>{props.nome}</h1>
      <h1>{show ? "É casado" : "Não é casado"}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} estado={false}/>
    </>
  )
}

¨¨¨¨
Usando destruction no arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  estado: boolean;
}

export default function Teste({nome, estado}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(estado)

  return (
    <div>
      <h1>{nome}</h1>
      <h1>{show ? "É casado" : "Não é casado"}</h1>
    </div>
  )
}

------------------------- ###
UseState com props: (exemplo 4)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
  idade: number;
}

export default function Teste({nome, idade}: PessoaInterface) {
  const [show, setShow] = useState<boolean | null>(true)

  return (
    <>
      {show && <h1>{nome} tem {idade} anos</h1>}
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Ana"} idade={22} />
    </>
  )
}

----------------------- ###

UseState com props: (exemplo 5)

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [info, setInfo] = useState<string | null>(null)

  return (
    <>
      <h1>{nome}</h1>
      <h1>{info === null ? "Sem info" : info}</h1>        //É o mesmo que {!info ? "Verdade" : "Falso"}      
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} />
    </>
  )
}

///////////////////////////////////////////////////////// &&&
TOGGLE

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(true)

  return (
    <>
      <button onClick={() => setShow(!show)}>Clique</button>

      {show && <h1>{nome}</h1>}
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Ana"} />
    </>
  )
}

--------------- ###

-Arquivo teste.tsx:

import {useState} from 'react'

interface PessoaInterface {
  nome: string;
}

export default function Teste({nome}: PessoaInterface) {
  const [show, setShow] = useState<boolean>(true)

  const toggle = () => {
    setShow((prev) => !prev)
  }

  return (
    <>
      <button onClick={toggle}>Clique</button>

      {show && <h1>{nome}</h1>}
    </>
  )
}

-Arquivo App.tsx:

import Teste from "./components/Teste"

export default function App() {

  return (
    <>
      <Teste nome={"Carlos"} />
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
ONCHANGE COM INPUT

import {useState} from 'react'

export default function App() {

  const [texto, setTexto] = useState<string | null>(null)

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setTexto(event.target.value)
  }

  return (
    <>
      <h1>{texto ? texto : "Sem texto"}</h1>
      <input onChange={handleChange} />
    </>
  )
}

//////////////////////////////////////////////////////////////// &&&
ONCHANGE COM SUBMIT

import {useState} from 'react'

interface FormInterface {
  email: string;
}

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados((prevData) => ({
      ...prevData,
      [event.target.name]: event.target.value
    }))
  }

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    alert(dados.email)
  }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input name="email" value={dados.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

--------- ###

Outra forma de lidar com o handleChange:

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados({
      ...dados,
      [event.target.name]: event.target.value
    })
  }
...
}

------------------- ###

import {useState} from 'react'

interface FormInterface {
  username: string;
  email: string;
}

export default function App() {

  const [dados, setDados] = useState<FormInterface>({email: "", username: ""})

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDados((prevData) => ({
      ...prevData,
      [event.target.name]: event.target.value
    }))
  }

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault()
    alert(dados.email)
    console.log(dados.username)
  }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input name="username" value={dados.username} onChange={handleChange} />
        <input name="email" value={dados.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

-------------------- ###

import React, { useState } from 'react';

interface FormData {
  username: string;
  email: string;
}

export default function App() {

  const [formData, setFormData] = useState<FormData>({
    username: '',
    email: '',
  });

  const handleChange = (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = event.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: value,
    }));
  };

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();                                       
    alert(`
      ${formData.username} - ${formData.email}
    `);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" name="username" value={formData.username} onChange={handleChange} />
        <input type="email" name="email" value={formData.email} onChange={handleChange} />
        <button type="submit">ENVIAR</button>
      </form>
    </>
  )
}

-------------------- ###
VIDEO: https://www.youtube.com/embed/665UnOGx3Pg?autoplay=1

import React, {useState} from 'react'

interface UserInterface {
  email: string;
}

interface Props {
  user: UserInterface;
  onUpdate: (user: UserInterface) => void 
}

function userUpdate({user, onUpdate}: Props) {
  const [name, setName] = useState<string>(user.name)
  const [email, setEmail] = useState<string>(user.email)

  const handleSubmit = (event: ReactFormEvent<HTMLFormElement>) => {
    event.preventDefault()
    onUpdate({
      ...user,
      name: name,
      email: email,
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Nome:</label>
        <input  
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div>
        <label>Email:</label>
        <input  
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      <button type="submit">Update</button>
    </form>
  )
}

export default userUpdate;


//////////////////////////////////////////////////////////////// &&&
USECONTEXT

Passando apenas o valor através do contexto:

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

export interface IContexto {
  txt: string;
}

export const Contexto = createContext<IContexto>({txt: "Texto de exemplo"});

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';
import {Contexto} from './components/ComponentePai'

export default function App(){

  const dados = useContext(Contexto);

  return (
    <>
      <h1>{dados.txt}</h1>
    </>
  )
};

-----------

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  nome: string;
  idade: string;
}

export const Contexto = createContext<IContexto>({
  nome: "Maria",
  idade: "22 anos",
});

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';
import { Contexto } from './components/ComponentePai';

export default function App() {
  const dados = useContext(Contexto);

  return (
    <>
      <h1>{dados.nome}</h1>
      <h2>{dados.idade}</h2>
    </>
  );
}

-----------------



---------------------------- ###

import { createContext } from 'react';

interface IContexto {
  nome: string;
  idade: string;
}

export const Contexto = createContext<IContexto>({
  nome: "Sem nome",
  idade: "Sem idade",
});

interface ComponentePaiProps {
  children: React.ReactNode;
}

export default function ComponentePai({ children }: ComponentePaiProps) {
  return (
    <Contexto.Provider value={{nome: "Carlos", idade:"35 anos"}}>
      {children}
    </Contexto.Provider>
  )
}

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import { useContext } from 'react';
import { Contexto } from './ComponentePai';

interface IDados {
  nome: string;
  idade: string;
}

export default function ComponenteFilho() {
  const dados: IDados = useContext(Contexto);
  
  return (
    <>
      <h1>{dados.nome}</h1>
      <h2>{dados.idade}</h2>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import ComponenteFilho from './components/ComponenteFilho';
import ComponentePai from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

------------------ ###

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  nome: string | undefined;
  idade: string | undefined;
}

export const Contexto = createContext<IContexto>({
  nome: undefined,
  idade: undefined,
});

interface ComponentePaiProps {
  children: React.ReactNode;
}

export default function ComponentePai({ children }: ComponentePaiProps) {
  return (
    <Contexto.Provider value={{nome: "Sem nome", idade:"Sem idade"}}>
      {children}
    </Contexto.Provider>
  )
}

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import { useContext } from 'react';
import { Contexto } from './ComponentePai';

interface IDados {
  nome: string | undefined;
  idade: string | undefined;
}

export default function ComponenteFilho() {
  const dados: IDados = useContext(Contexto);
  
  return (
    <>
      <h1>{dados.nome = "Maria"}</h1>
      <h2>{dados.idade = "44 anos"}</h2>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import ComponenteFilho from './components/ComponenteFilho';
import ComponentePai from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

------------------- ###

-Arquivo ComponentePai.tsx:

import { createContext } from 'react';

interface IContexto {
  txt: string;
}

export const Contexto = createContext<IContexto>({txt: "Texto inicial"});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  return (
    <div>
      <Contexto.Provider>
        {children}
      </Contexto.Provider>
    </div>
  );
};

¨¨¨¨
-Arquivo App.tsx:

import { useContext } from 'react';

import {Contexto} from './components/ComponentePai'

export default function App(){
  const {txt} = useContext(Contexto);
  return (
    <>
      <h1>{txt}</h1>
    </>
  )
};

>>> Texto inicial

-------------------- ### 

-Arquivo ComponentePai.jsx:

import { createContext, useState } from 'react';

interface IContexto {
  txt: string | undefined;
  setTxt: (value: string) => void;
}

export const Contexto = createContext<IContexto>({
  txt: undefined,
  setTxt: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({ children }: Props) => {
  const [txt, setTxt] = useState<string>('Texto de exemplo');

  return (
    <>
      <Contexto.Provider value={{txt, setTxt}}>
        {children}
      </Contexto.Provider>
    </>
  );
}


¨¨¨¨
-Arquivo ComponenteFilho.jsx:

import { useContext } from 'react';
import {Contexto} from './ComponentePai'

export const ComponenteFilho = () => {
  const {txt} = useContext(Contexto)
  return (
    <>
    <h1>{txt}</h1>
    </>
  )
}

¨¨¨¨
-Arquivo App.jsx:

import {ComponenteFilho} from './components/ComponenteFilho';
import {ComponentePai} from './components/ComponentePai';

export default function App() {
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  );
}

-------------- ###

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  cor: string | undefined;
  txt: string | undefined;
}

export const Contexto = createContext<IContexto>({
  cor: undefined,
  txt: undefined,
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [cor, setCor] = useState<string | undefined>("blue");
  const [txt, setTxt] = useState<string | undefined>("Texto azul");
  
  return (
    <Contexto.Provider value={{ cor, txt }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {cor, txt} = useContext(Contexto);

  return (
    <>
      <div style={{color: cor}}>
        <h2>{txt}</h2>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

---------------- ###
Toggle com useContext e booleans:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: boolean;
  setTheme: (value: boolean) => void;
}

export const Contexto = createContext<IContexto>({
  theme: true,
  setTheme: (prevTheme) => !prevTheme,                //Ou setTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<boolean>(true);

  return (
    <Contexto.Provider value={{ theme, setTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {theme, setTheme} = useContext(Contexto)

  const themeStyles = {
    backgroundColor: theme ? 'white' : 'black',
    color: theme ? 'black' : 'white',    
  }
  
  const toggleTheme = () => {
    setTheme(!theme);
  }

  return (
    <>
      <button onClick={toggleTheme}>Toogle</button>
      <div style={themeStyles}>
        <h1>Texto de exemplo</h1>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

----------------

Outra forma:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: boolean;
  setTheme: (value: boolean) => void;
  toggleTheme: () => void;
}

export const Contexto = createContext<IContexto>({
  theme: true,
  setTheme: () => {},
  toggleTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<boolean>(true);

  const toggleTheme = () => {
    setTheme(!theme);
  }

  return (
    <Contexto.Provider value={{ theme , setTheme, toggleTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "./ComponentePai";

export const ComponenteFilho = () => {
  const {theme, toggleTheme} = useContext(Contexto)

  const themeStyles = {
    backgroundColor: theme ? 'white' : 'black',
    color: theme ? 'black' : 'white',    
  }

  return (
    <>
      <button onClick={toggleTheme}>Toogle</button>
      <div style={themeStyles}>
        <h1>Texto de exemplo</h1>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

--------------------- ###
Toggle com useContext e strings:

-Arquivo ComponentePai.tsx:

import { createContext, useState } from 'react';

interface IContexto {
  theme: string | null;
  setTheme: (value: string) => void;
  toggleTheme: () => void;
}

export const Contexto = createContext<IContexto>({
  theme: "light",
  setTheme: () => {},
  toggleTheme: () => {},
});

interface Props {
  children: React.ReactNode;
}

export const ComponentePai = ({children}: Props) => {
  const [theme, setTheme] = useState<string | null>("light");

  const toggleTheme = () => {
    if (theme === "light") {
      return setTheme("dark");
    }
    return setTheme("light");
  };

  return (
    <Contexto.Provider value={{ theme, setTheme, toggleTheme }}>
      {children}
    </Contexto.Provider>
  );
};

¨¨¨¨
-Arquivo ComponenteFilho.tsx:

import {useContext} from "react";
import {Contexto} from "../components/ComponentePai";

export const ComponenteFilho = () => {
  const {theme, toggleTheme} = useContext(Contexto);

  return (
    <>
      <div
        style={{
          backgroundColor: theme === "light" ? "#eee" : "#333",
          color: theme === "dark" ? "#eee" : "#333",
        }}
      >
        <h1>Tema atual: {theme}</h1>
        <button onClick={toggleTheme}>Toggle Theme</button>
      </div>
    </>
  )
}

¨¨¨¨
-Arquivo App.tsx:

import {ComponentePai} from './components/ComponentePai'
import {ComponenteFilho} from './components/ComponenteFilho'

export default function App(){
  return (
    <>
      <ComponentePai>
        <ComponenteFilho />
      </ComponentePai>
    </>
  )
};

--------------------- ###
VIDEO: https://www.youtube.com/embed/665UnOGx3Pg?autoplay=1

CRUD com useContext:

-Arquivo UserContextProvider.tsx:

import {createContext, useState, useEffect} from 'react'

export interface User {
  nome: string;
  estado: boolean;
}

interface UserContextType {
  getUsers: User[] | null;
  addUser: {user: User} => void;
  updateUser: {id: string} => void;
  deleteUser: {id: string} => void;
}

const contextInitialValues = {
  getUsers: null,
  addUser: () => null,
  updateUser: () => null,
  deleteUser: () => null,
}

export const UserContext = createContext<UserContextType>(contextInitialValues);

interface Props {
  children: React.ReactNode;
}

export const UserProvider = (props: Props) => {
  const [users, setUsers] = useState<User[] | null>(null)

  useEffect(() => {
    setUsers([{nome: "Maria", estado: "Casada"}])    //aqui teria um fetch
  }, [])

  const addUser = (user: User) => null
  const updateUser = (id: string) => null
  const deleteUser = (id: string) => null

  return (
    <UserContext.Provider value={{getUsers, addUser, updateUser, deleteUser}}>
      {props.children}
    </UserContext.Provider>
  )
}

-Arquivo User.tsx:

import {useContext} from 'react'
import {UserContext} from './UserContextProvider'


interface Props {
  nome: string;
  estado: boolean;
}

export default function User ({nome}: Props) {

  const {getUsers, addUser, updateUser, deleteUser} = useContext(UserContext)

  return (
    <div>
      <h1>{nome}</h1>
    </div>
  )
}

-Arquivo App.tsx:

import User from "./User"
import {UserProvider} from "./UserContextProvider"

export default function App() {
  return (
    <UserProvider>
      <User nome={"Bruno"} estado={true} />
    </UserProvider>
  )
}


//////////////////////////////////////////////////////////////// &&&
REACT.FC COM PROPS E INTERFACES

React.FC is a type that stands for "Function Component" in React. 
It is a generic type that allows you to specify the props that a function component will accept.

Using React.FC can be helpful for a number of reasons:

It provides type safety for the props that a component expects to receive. 
This can help catch bugs early on and make your code easier to understand.

It makes it easier to refactor your component's props. 
For example, if you want to rename a prop, the TypeScript compiler will catch any places where that prop is used and help you update them.

It makes it easier to see the expected shape of a component's props just by looking at its type definition.

------------ ###

import React from 'react';

const App: React.FC = () => {
  return (
    <>
      ...
    </>
  );
};

export default App;

------------ ###

-Arquivo App.tsx:

import {Teste} from './components/Teste'

export default function App() {
  return (
    <>
      <Teste nome={"Maria"} />
    </>
  )
}

-Arquivo Teste.tsx:  (SEM REACT.FC)

interface Props {
  nome: string;
}

export const Teste = ({nome}: Props) => {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  );
};

-Arquivo Teste.tsx:  (COM REACT.FC)

import React from 'react';

interface Props {
  nome: string;
}

export const Teste: React.FC<Props> = ({nome}) => {
  return (
    <div>
      <h1>{nome}</h1>
    </div>
  );
};

OBS: Não é possível usar desta forma como função:

export function Teste({nome}: React.FC<Props>) {
  ...
}

















//////////////////////////////////////////////////////////////// &&&
TYPESCRIPT COM REACT
TAILWIND

Instalação:
npm install tailwindcss @tailwindcss/vite

¨¨¨¨
No arquivo vite.config.ts adicione o tailwind:

import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'
export default defineConfig({
  plugins: [
    react(),                //opcional
    tailwindcss(),
  ],
})

¨¨¨¨

Importação:
@import "tailwindcss";

¨¨¨¨
Remova o css de App.css e index.css se necessário.

//////////////////////////////////////////////////////////// &&&
TYPESCRIPT COM REACT

