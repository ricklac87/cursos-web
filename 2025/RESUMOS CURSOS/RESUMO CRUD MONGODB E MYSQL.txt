////////////////////////////////////////////////////////////////&&&
CRUD USANDO MONGOOSE e POSTMAN
VIDEO: https://www.youtube.com/embed/K5QaTfE5ylk

No terminal, digite:
npm init -y

instale as dependencias:
npm install express nodemon mongoose

Crie o arquivo index.js:     (ou server.js)

No arquivo package.json adicione o script:
"start": "nodemon ./index.js localhost:3000"

¨¨¨¨¨¨
-Arquivo index.js:

const express = require('express')
const app = express()

app.use(                              //Aparentemente não é necessário
  express.urlencoded({
    extended: true,
  }),
)

app.use(express.json())

app.get('/', (req, res) => {
  res.json({message: "Mensagem"})
})

app.listen(3000)

¨¨¨¨¨¨
No Postman, crie uma collection e faça uma nova request
No GET, coloque a url http://localhost:3000

Ao clicar em SEND a mensagem será recebida

Como a url pode mudar ao longo da vida, é necessário fazer uma mudança.
Clique na API criada e vá em variables. Adicione uma variavel chamada URL. 
Inicial value = http://localhost:3000
Current value = http://localhost:3000
Salve as alterações.

Agora em New Request a url será {{URL}}

Atenção!!!
Tenha cuidado ao adicionar uma variavel.
Se a url salva na variavel for http://localhost:3000 então ficará {{URL}}/api/usuarios
Se a url salva na variavel for http://localhost:3000/ então ficará {{URL}}api/usuarios

---------------------
Conectando ao MongoDB

No Atlas, crie o Cluster e o database (collection)
Para fins didaticos, coloque Network Acess para a url 0.0.0.0/0 para que qualquer um consiga acessar

Copie a url de conexão
mongodb+srv://root:senha@curso.l1xujce.mongodb.net/?retryWrites=true&w=majority&appName=curso

Padrão:
mongodb+srv://NOME_DO_USUARIO:SENHA_DO_USUARIO@NOME_DO_CLUSTER.l1xujce.mongodb.net/NOME_DA_COLLECTION?retryWrites=true&w=majority&appName=NOME_DO_CLUSTER

Instale o dotenv:
npm i dotenv

Crie o arquivo .env na pasta root e adicione a url de conexão:

DB_CONNECTION = mongodb+srv://NOME_DO_USUARIO:SENHA_DO_USUARIO@NOME_DO_CLUSTER.l1xujce.mongodb.net/NOME_DA_COLLECTION?retryWrites=true&w=majority&appName=NOME_DO_CLUSTER

¨¨¨¨
Outra forma também seria separar o nome do usuario, senha, cluster e collection. 

-No arquivo .env:

DB_PORT = 3000
DB_USER = root
DB_PASSWORD = senha
DB_CLUSTER = curso                        //opcional
DB_COLLECTION = person                    //opcional

-No arquivo de conexão ao banco de dados:

const express = require('express')
const app = express()
app.use(express.json())

const mongoose = require('mongoose')
require("dotenv").config();

const DB_USER = process.env.DB_USER
const DB_PASSWORD = encodeURIComponent(process.env.DB_PASSWORD)
const DB_CLUSTER = process.env.DB_CLUSTER
const DB_COLLECTION = process.env.DB_COLLECTION
const DB_PORT = process.env.DB_PORT

const DB_CONNECTION = `mongodb+srv://${DB_USER}:${DB_PASSWORD}@${DB_CLUSTER}.l1xujce.mongodb.net/${DB_COLLECTION}?retryWrites=true&w=majority&appName=${DB_CLUSTER}`

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(3000, () => {
      console.log(`Servidor conectado na porta ${DB_PORT}`);
    });
  })
  .catch((err) => console.log('Erro ao conectar no MongoDB:', err))

--------

Conectando usando async/await:

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.DB_CONNECTION);
    console.log("Conectado ao MongoDB");
  } catch (err) {
    console.log('Erro ao conectar no MongoDB:', err);
  }
};

connectDB();

-------------

Crie uma pasta chamada models. Dentro crie o arquivo Person.js:

const mongoose = require('mongoose')

const Person = mongoose.model('Person', {
  name: String,
  age: Number
})

module.exports = Person

------------

Conectando usando o mongoose:

const express = require('express')
const app = express()
app.use(express.json())

const mongoose = require('mongoose')
require("dotenv").config();

const DB_USER = process.env.DB_USER
const DB_PASSWORD = encodeURIComponent(process.env.DB_PASSWORD)
const DB_CLUSTER = process.env.DB_CLUSTER
const DB_COLLECTION = process.env.DB_COLLECTION
const DB_PORT = process.env.DB_PORT

const DB_CONNECTION = `mongodb+srv://${DB_USER}:${DB_PASSWORD}@${DB_CLUSTER}.l1xujce.mongodb.net/${DB_COLLECTION}?retryWrites=true&w=majority&appName=${DB_CLUSTER}`

const Person = require('./models/Person')

app.post('/person', async (req, res) => {

  const {name, age} = req.body

  if(!name || !age) {
    res.status(422).json({error: "O nome e idade são obrigatórios"})
  }

  const person = {
    name, 
    age
  }

  try {
    const newPerson = await Person.create(person)
    res.status(201).json({
      message: "Pessoa inserida no sistema com sucesso",
      data: newPerson
    })
  } catch (err) {
    res.status(500).json({error: err})
  }
})

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(DB_PORT)
  })
  .catch((err) => console.log(err))

----------

Forma simples do post:

app.post('/person', async (req, res) => {
  try {
    const newPerson = await Person.create(req.body);
    res.status(201).json({
      message: "Pessoa inserida no sistema com sucesso",
      data: newPerson
    })
  } catch (err) {
    res.status(500).json({error: err})
  }
})

------------

No postman, crie um requisição POST e adicione a url {{URL}}/person  

Selecione Body. 
Selecione Raw.
Ao invés de Text, selecione JSON.

Digite o codigo JSON:

{
  "name": "Carlos",
  "age": 30
}

Digite Send para enviar os dados

---------------

Separando a camada de rotas:

Crie um arquivo chamado personRoutes.js dentro da pasta routes. 
Usando o Router do express, mova a rota de GET, POST, PUT e DELETE para lá.
Importe o models também (Person.js).

-Arquivo personRoutes.js:

const router = require('express').Router()

const Person = require('../models/Person')

router.post('/', async (req, res) => {                   //o caminho passa a ser '/' ao invés de '/person'

  const {name, age} = req.body

  if(!name) {
    res.status(422).json({error: "O nome é obrigatório"})           // Ou status 400
    return
  }

  const person = {
    name, 
    age
  }

  try {
    await Person.create(person)
    res.status(201).json({message: "Pessoa inserida no sistema com sucesso"})
  } catch (err) {
    res.status(500).json({error: err})
  }
})

module.exports = router

------

Importando o modulo de rotas no arquivo de conexão ao banco de dados: (index.js ou server.js)

const express = require('express')
const app = express()
const mongoose = require('mongoose')
require('dotenv').config();
app.use(express.json())

const personRoutes = require('./routes/personRoutes')

app.use('/person', personRoutes)

mongoose.connect(process.env.DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(3000)
  })
  .catch((err) => console.log(err))

-------

Adicionando uma requisição GET para obter os dados cadastrados:

-Arquivo personRoutes.js:

const router = require('express').Router()

const Person = require('../models/Person')

router.post('/', async (req, res) => {                   
  ...
})

router.get('/', async (req, res) => {
  try {
    const people = await Person.find()
    res.status(200).json(people)
  } catch (err) {
    res.status(500).json({error: err})
  }
})

module.exports = router

--------

Criando uma rota dinamica com GET:

-Arquivo personRoutes.js:

const router = require('express').Router()

const Person = require('../models/Person')

router.post('/', async (req, res) => {                   
  ...
})

router.get('/', async (req, res) => {
  ...
})

router.get('/:id', async (req, res) => {
  const id = req.params.id                              //OU const {id} = req.params

  try {
    const person = await Person.findById(id)           //OU const person = await Person.findOne({ _id: id })

    if(!person){
      res.status(422).json({message: "O usuário não foi encontrado"})      //Ou status 404
      return
    }

    res.status(200).json(person)
  } catch (err) {
    res.status(500).json({error: err})
  }
})

module.exports = router

-----------

PUT ou PATCH?
Escolha o PUT se o que você pretende é fazer uma atualização completa do seu recurso ou o PATCH se você quiser atualizar apenas um subconjunto dos dados do seu recurso.

import axios from 'axios'

axios.patch('/users/1', {
  phone: '(81) 98116-9490'
})

axios.put('/users/1', {
  name: 'Gabriel Rufino',
  email: 'contato@gabrielrufino.com',
  phone: '(81) 98116-9490'
})

-----------

Adicionando um metodo PATCH para atualizar dados:

-Arquivo personRoutes.js:

const router = require('express').Router()

const Person = require('../models/Person')

router.post('/', async (req, res) => {                   
  ...
})

router.get('/', async (req, res) => {
  ...
})

router.get('/:id', async (req, res) => {
  ...
})

router.patch('/:id', async (req, res) => {
  const id = req.params.id                              //OU const {id} = req.params

  const {name, age} = req.body

  const person = {name, age}

  try {
    const updatedPerson = await Person.updateOne({ _id: id}, person)           

    if(updatedPerson.matchedCount === 0){                                  //OU if(!updatedPerson)
      res.status(422).json({message: "O usuário não foi encontrado"})      //Ou status 404
      return
    }

    res.status(200).json({message: "Dados atualizados"})                   //OU res.status(200).json(person)  
  } catch (err) {
    res.status(500).json({error: err})
  }
})

module.exports = router

--------------

Forma simples do PUT:

app.put('/person/:id', async (req, res) => {
  try {
    const updatePerson = await Person.findByIdAndUpdate(
      req.params.id,
      req.body,
      {new: true}           //para que updatePerson mostre o dado atualizado
    );
    res.status(201).json({
      message: "Pessoa atualizada no sistema com sucesso",
      data: updatePerson
    })
  } catch (err) {
    res.status(500).json({error: err})
  }
})

-----------------

Adicionando o método DELETE:

-Arquivo personRoutes.js:

const router = require('express').Router()

const Person = require('../models/Person')

router.post('/', async (req, res) => {                   
  ...
})

router.get('/', async (req, res) => {
  ...
})

router.get('/:id', async (req, res) => {
  ...
})

router.patch('/:id', async (req, res) => {
  ...
})

router.delete('/:id', async (req, res) => {

  const id = req.params.id                              //OU const {id} = req.params

  const person = await Person.findOne({ _id: id })

  if (!person) {
    res.status(422).json({ message: "Usuário não encontrado"})
    return
  }

  try {
    const deletedPerson = await Person.deleteOne({ _id: id })                //OU  await Person.findByIdAndDelete(id)

    if (!deletedPerson) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }

    res.status(200).json({ 
      message: 'Pessoa deletada com sucesso',
      person: deletedPerson 
    })                  
  } catch (err) {
    res.status(500).json({error: err})
  }
})

module.exports = router

---------------

Forma simples do DELETE:

app.delete('/person/:id', async (req, res) => {
  try {
    const deletedPerson = await Person.findByIdAndDelete(
      req.params.id
    );
    res.status(201).json({
      message: "Pessoa removida no sistema com sucesso",
      data: deletedPerson
    })
  } catch (err) {
    res.status(500).json({error: err})
  }
})

///////////////////////////////////////////////// &&&

CRUD com mongoose e postman 2
VIDEO: https://www.youtube.com/embed/ygVP3ItS8AE?autoplay=1

Forma simples:

const express = require('express')
const app = express()
require("dotenv").config();
const mongoose = require('mongoose')
const DB_CONNECTION = process.env.DB_CONNECTION

app.use(express.json())

const PersonSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true
    },
    age: {
      type: Number,
      required: true,
      min: 0
    },
  },
  {
    timestamps: true,
  }
)

const Person = mongoose.model('Person', PersonSchema)

app.get('/api/person', async (req, res) => {
  try {
    const people = await Person.find({})
    res.status(200).json(people)
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar pessoas' })
  }
})

app.post('/api/person', async (req, res) => {
  try {
    const { name, age } = req.body
    const person = new Person({ name, age })
    await person.save()
    res.status(201).json(person)
  } catch (error) {
    res.status(400).json({ error: 'Erro ao criar pessoa' })
  }
})

app.put('/api/person/:id', async (req, res) => {
  try {
    const {id} = req.params
    const person = await Person.findByIdAndUpdate(id, req.body)
    const UpdatedPerson = await Person.findById(id)
    res.status(200).json(UpdatedPerson)
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({ error: 'Dados inválidos', details: error.message })
    } else {
      res.status(500).json({ error: 'Erro ao atualizar pessoa' })
    }
  }
})

app.delete('/api/person/:id', async (req, res) => {
  try {
    const {id} = req.params
    const person = await Person.findByIdAndDelete(id)
    res.status(200).json(person)
  } catch (error) {
    res.status(500).json({ error: 'Erro ao deletar pessoa' })
  }
})

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(3000, () => {
      console.log('Servidor conectado na porta 3000');
    });
  })
  .catch((err) => console.log('Erro ao conectar no MongoDB:', err))

-------------------- 

Forma mais completa:

const express = require('express')
const app = express()
require("dotenv").config();
const mongoose = require('mongoose')
const DB_CONNECTION = process.env.DB_CONNECTION

app.use(express.json())

// Schema com validações
const PersonSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true
    },
    age: {
      type: Number,
      required: true,
      min: 0,
      max: 150
    },
  },
  {
    timestamps: true,            //cria timestamps de quando foi criado ou atualizado
  }
)

const Person = mongoose.model('Person', PersonSchema)

// GET - Buscar todas as pessoas
app.get('/api/person', async (req, res) => {
  try {
    const people = await Person.find({})
    res.status(200).json(people)
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar pessoas' })
  }
})

// GET - Buscar pessoa por ID
app.get('/api/person/:id', async (req, res) => {
  try {
    const { id } = req.params
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inválido' })
    }
    
    const person = await Person.findById(id)
    
    if (!person) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }
    
    res.status(200).json(person)
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar pessoa' })
  }
})

// POST - Criar nova pessoa
app.post('/api/person', async (req, res) => {
  try {
    const { name, age } = req.body
    
    // Validação básica
    if (!name || !age) {
      return res.status(400).json({ error: 'Nome e idade são obrigatórios' })
    }
    
    const person = new Person({ name, age })
    await person.save()                                
    res.status(201).json(person)
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({ error: 'Dados inválidos', details: error.message })
    } else {
      res.status(500).json({ error: 'Erro ao criar pessoa' })
    }
  }
})

// PUT - Atualizar pessoa por ID
app.put('/api/person/:id', async (req, res) => {
  try {
    const { id } = req.params
    const { name, age } = req.body
    
    // Validar ID
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inválido' })
    }
    
    // Validação básica dos dados
    if (!name || !age) {
      return res.status(400).json({ error: 'Nome e idade são obrigatórios' })
    }
    
    const updatedPerson = await Person.findByIdAndUpdate(
      id,
      { name, age },
      { 
        new: true, // Retorna o documento atualizado
        runValidators: true // Executa as validações do schema
      }
    )
    
    if (!updatedPerson) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }
    
    res.status(200).json(updatedPerson)
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({ error: 'Dados inválidos', details: error.message })
    } else {
      res.status(500).json({ error: 'Erro ao atualizar pessoa' })
    }
  }
})

// DELETE - Deletar pessoa por ID
app.delete('/api/person/:id', async (req, res) => {
  try {
    const { id } = req.params
    
    // Validar ID
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inválido' })
    }
    
    const deletedPerson = await Person.findByIdAndDelete(id)
    
    if (!deletedPerson) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }
    
    res.status(200).json({ 
      message: 'Pessoa deletada com sucesso',
      person: deletedPerson 
    })
  } catch (error) {
    res.status(500).json({ error: 'Erro ao deletar pessoa' })
  }
})

// Middleware para rotas não encontradas
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Rota não encontrada' })
})

// Conectar ao MongoDB e iniciar servidor
mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(3000, () => {
      console.log('Servidor conectado na porta 3000');
    });
  })
  .catch((err) => console.log('Erro ao conectar no MongoDB:', err))

------------------- 

POST create() vs save()
The main difference between using the create and save methods in Mongoose is that create is a convenience method that automatically calls new Model() and save() for you, while save is a method that is called on a Mongoose document instance.

app.post('/api/person', async (req, res) => {
  try {
    const { name, age } = req.body
    ...
    const person = new Person({ name, age })
    await person.save()                                 
    res.status(201).json(person)              //OU res.status(201).json({message: "Pessoa criada com sucesso!"})
  } catch (error) {
    ...
  }
})

OU

app.post('/api/person', async (req, res) => {
  try {
    const { name, age } = req.body
    ...
    const person = { name, age }
    await Person.create(person)                                 
    res.status(201).json(person)            //OU res.status(201).json({message: "Pessoa criada com sucesso!"})
  } catch (error) {
    ...
  }
})


-----------------------

Fazendo teste no POSTMAN:

Criando a variavel:
variavel = URL
initial value = http://localhost:3000/
current value = http://localhost:3000/

Add request:

GET:
{{URL}}api/person

¨¨¨¨
POST:
{{URL}}api/person

Body -> Raw -> JSON
{
    "name":"Carlos",
    "age": 30
}

Será gerado o JSON:
[
    {
        "_id": "68862f3c63d28bb0abbc3e90",
        "name": "Carlos",
        "age": 30,
        "createdAt": "2025-07-27T13:53:00.471Z",
        "updatedAt": "2025-07-27T13:53:00.471Z",
        "__v": 0
    }
]¨

¨¨¨¨¨¨
PUT:
{{URL}}api/person/68862f3c63d28bb0abbc3e90

Body -> Raw -> JSON
{
    "name":"Pedro",
}

Atualizará o JSON:
{
    "_id": "68862f3c63d28bb0abbc3e90",
    "name": "Pedro",
    "age": 30,
    "createdAt": "2025-07-27T13:53:00.471Z",
    "updatedAt": "2025-07-27T14:34:13.466Z",
    "__v": 0
}

¨¨¨¨¨¨
DELETE:
{{URL}}api/person/68862f3c63d28bb0abbc3e90

----------------------------
Separando o parte Model:

-Arquivo Person_Model.js dentro da pasta model:

const mongoose = require('mongoose')

const PersonSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true
    },
    age: {
      type: Number,
      required: true,
      min: 0,
      max: 150
    },
  },
  {
    timestamps: true,            
  }
)

const Person = mongoose.model('Person', PersonSchema)

module.exports = Person

-É necessário importar o modulo Person no arquivo com conexão ao banco de dados:

const Person = require('./model/Person_Model')

-----

Outra forma de criar o schema e modelo:

const mongoose = require('mongoose')

const Person = mongoose.model('Person', {
  {
    name: {
      type: String,
      required: true,
      trim: true
    },
    age: {
      type: Number,
      required: true,
      min: 0,
      max: 150
    },
  },
  {
    timestamps: true,            
  }
})

module.exports = Person


----------------------------
Separando o parte Controller:

-Arquivo Person_Controller.js dentro da pasta controller:

const Person = require('../model/Person_Model')

const findPerson = async (req, res) => {
  try {
    const people = await Person.find({})
    res.status(200).json(people)
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar pessoas' })
  }
}

const createPerson = async (req, res) => {
  try {
    const { name, age } = req.body

    if (!name || !age) {
      return res.status(400).json({ error: 'Nome e idade são obrigatórios' })
    }
    
    const person = new Person({ name, age })
    await person.save()
    res.status(201).json(person)
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({ error: 'Dados inválidos', details: error.message })
    } else {
      res.status(500).json({ error: 'Erro ao criar pessoa' })
    }
  }
}

const updatePerson = async (req, res) => {
  try {
    const { id } = req.params
    const { name, age } = req.body

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inválido' })
    }

    if (!name || !age) {
      return res.status(400).json({ error: 'Nome e idade são obrigatórios' })
    }
    
    const updatedPerson = await Person.findByIdAndUpdate(
      id,
      { name, age },
      { 
        new: true, 
        runValidators: true 
      }
    )
    
    if (!updatedPerson) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }
    
    res.status(200).json(updatedPerson)
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({ error: 'Dados inválidos', details: error.message })
    } else {
      res.status(500).json({ error: 'Erro ao atualizar pessoa' })
    }
  }
}

const deletePerson = async (req, res) => {
  try {
    const { id } = req.params

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'ID inválido' })
    }
    
    const deletedPerson = await Person.findByIdAndDelete(id)
    
    if (!deletedPerson) {
      return res.status(404).json({ error: 'Pessoa não encontrada' })
    }
    
    res.status(200).json({ 
      message: 'Pessoa deletada com sucesso',
      person: deletedPerson 
    })
  } catch (error) {
    res.status(500).json({ error: 'Erro ao deletar pessoa' })
  }
}

module.exports = {
  findPerson,
  createPerson,
  updatePerson,
  deletePerson
}

-----
E dentro do arquivo com conexão ao banco de dados ficaria:

const {findPerson, createPerson, updatePerson, deletePerson} = require('./controller/Person_Controller')

app.get('/api/person', findPerson)

app.post('/api/person', createPerson)

app.put('/api/person/:id', updatePerson)

app.delete('/api/person/:id', deletePerson)

-------
Seria possível também criar rotas:

-Arquivo Person_Routes.js dentro da pasta routes:

const {findPerson, createPerson, updatePerson, deletePerson} = require('../controller/Person_Controller')

const express = require('express')

const Person_router = express.Router()

Person_router.get("", findPerson)

Person_router.post("", createPerson)

Person_router.put("/:id", updatePerson)

Person_router.delete(":id", deletePerson)

module.exports = Person_router

¨¨¨¨ 
-E no arquivo com conexão ao banco de dados:

const express = require('express')
const app = express()
app.use(express.json())

const DB_CONNECTION = process.env.DB_PERSON
require("dotenv").config();

const mongoose = require('mongoose')

const Person_router = require('./routes/Person_router')
app.use("/api/person", Person_router)

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log("Conectado ao MongoDB")
    app.listen(3000, () => {
      console.log('Servidor conectado na porta 3000');
    });
  })
  .catch((err) => console.log('Erro ao conectar no MongoDB:', err))

////////////////////////////////////////////////////////////////////// &&&
SIMPLE CRUD COM MONGOOSE

const express = require('express');
const mongoose = require('mongoose'); 
const app = express();
const port = 3000;

mongoose.connect('mongodb://localhost/your_database', { 
  useNewUrlParser: true, 
  useUnifiedTopology: true 
});

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const ItemSchema = new mongoose.Schema({
    name: String,
    age: Number
});
const Item = mongoose.model('Item', ItemSchema);

app.get('/items', async (req, res) => {
    const items = await Item.find();
    res.send(items);
});

app.get('/items/:id', async (req, res) => {
    const item = await Item.findById(req.params.id);
    res.send(item);
});

app.post('/items', async (req, res) => {
    const newItem = new Item(req.body);
    await newItem.save();
    res.status(201).send(newItem);
});

app.put('/items/:id', async (req, res) => {
    const updatedItem = await Item.findByIdAndUpdate(req.params.id, req.body, { new: true });
    res.send(updatedItem);
});

app.delete('/items/:id', async (req, res) => {
    await Item.findByIdAndDelete(req.params.id);
    res.status(204).send();
});

app.listen(port, () => {
    console.log(`Server running on http://localhost:${port}`);
});

-------------------

const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, param, validationResult } = require('express-validator');

const app = express();
const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/your_database';

// Middleware de segurança
app.use(helmet());
app.use(cors());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // máximo 100 requests por IP
  message: 'Muitas requisições deste IP, tente novamente em 15 minutos.'
});
app.use(limiter);

// Middleware para parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Conexão com MongoDB com tratamento de erro
const connectDB = async () => {
  try {
    await mongoose.connect(MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('Conectado ao MongoDB com sucesso');
  } catch (error) {
    console.error('Erro ao conectar ao MongoDB:', error.message);
    process.exit(1);
  }
};

// Schema com validações
const ItemSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Nome é obrigatório'],
    trim: true,
    minlength: [2, 'Nome deve ter pelo menos 2 caracteres'],
    maxlength: [100, 'Nome não pode ter mais de 100 caracteres']
  },
  age: {
    type: Number,
    required: [true, 'Idade é obrigatória'],
    min: [0, 'Idade não pode ser negativa'],
    max: [150, 'Idade não pode ser maior que 150']
  }
}, {
  timestamps: true // Adiciona createdAt e updatedAt automaticamente
});

const Item = mongoose.model('Item', ItemSchema);

// Middleware para tratamento de erros de validação
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Dados inválidos',
      errors: errors.array()
    });
  }
  next();
};

// Middleware para capturar erros assíncronos
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Validações
const itemValidation = [
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Nome deve ter entre 2 e 100 caracteres'),
  body('age')
    .isInt({ min: 0, max: 150 })
    .withMessage('Idade deve ser um número entre 0 e 150')
];

const idValidation = [
  param('id')
    .isMongoId()
    .withMessage('ID inválido')
];

// Rotas

// GET /items - Listar todos os itens com paginação
app.get('/items', asyncHandler(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;

  const items = await Item.find()
    .sort({ createdAt: -1 })
    .skip(skip)
    .limit(limit);
  
  const total = await Item.countDocuments();

  res.json({
    success: true,
    data: items,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  });
}));

// GET /items/:id - Buscar item por ID
app.get('/items/:id', 
  idValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const item = await Item.findById(req.params.id);
    
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      data: item
    });
  })
);

// POST /items - Criar novo item
app.post('/items',
  itemValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const newItem = new Item(req.body);
    const savedItem = await newItem.save();
    
    res.status(201).json({
      success: true,
      message: 'Item criado com sucesso',
      data: savedItem
    });
  })
);

// PUT /items/:id - Atualizar item
app.put('/items/:id',
  idValidation,
  itemValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const updatedItem = await Item.findByIdAndUpdate(
      req.params.id,
      req.body,
      { 
        new: true,
        runValidators: true
      }
    );

    if (!updatedItem) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Item atualizado com sucesso',
      data: updatedItem
    });
  })
);

// DELETE /items/:id - Deletar item
app.delete('/items/:id',
  idValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const deletedItem = await Item.findByIdAndDelete(req.params.id);

    if (!deletedItem) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Item deletado com sucesso'
    });
  })
);

// Middleware de tratamento de erros
app.use((err, req, res, next) => {
  console.error(err.stack);

  // Erro de validação do Mongoose
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: 'Erro de validação',
      errors
    });
  }

  // Erro de cast (ID inválido)
  if (err.name === 'CastError') {
    return res.status(400).json({
      success: false,
      message: 'ID inválido'
    });
  }

  // Erro genérico
  res.status(500).json({
    success: false,
    message: 'Erro interno do servidor'
  });
});

// Rota 404
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'Rota não encontrada'
  });
});

// Inicializar servidor
const startServer = async () => {
  try {
    await connectDB();
    app.listen(PORT, () => {
      console.log(`Servidor rodando em http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('Erro ao iniciar servidor:', error);
    process.exit(1);
  }
};

// Tratamento de sinais de processo
process.on('SIGTERM', async () => {
  console.log('Recebido SIGTERM, fechando servidor graciosamente...');
  await mongoose.connection.close();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('Recebido SIGINT, fechando servidor graciosamente...');
  await mongoose.connection.close();
  process.exit(0);
});

startServer();


--------

Codigo usando MySQL:

const express = require('express');
const mysql = require('mysql2/promise');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const { body, param, validationResult } = require('express-validator');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Configuração do pool de conexões MySQL
const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_NAME || 'your_database',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  acquireTimeout: 60000,
  timeout: 60000,
  reconnect: true
};

let pool;

// Middleware de segurança
app.use(helmet());
app.use(cors());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // máximo 100 requests por IP
  message: 'Muitas requisições deste IP, tente novamente em 15 minutos.'
});
app.use(limiter);

// Middleware para parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Conexão com MySQL
const connectDB = async () => {
  try {
    pool = mysql.createPool(dbConfig);
    
    // Testar conexão
    const connection = await pool.getConnection();
    console.log('Conectado ao MySQL com sucesso');
    connection.release();
    
    // Criar tabela se não existir
    await createItemsTable();
  } catch (error) {
    console.error('Erro ao conectar ao MySQL:', error.message);
    process.exit(1);
  }
};

// Criar tabela items
const createItemsTable = async () => {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS items (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        age INT NOT NULL CHECK (age >= 0 AND age <= 150),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_name (name),
        INDEX idx_created_at (created_at)
      ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
    `;
    
    await pool.execute(createTableQuery);
    console.log('Tabela items criada/verificada com sucesso');
  } catch (error) {
    console.error('Erro ao criar tabela:', error.message);
    throw error;
  }
};

// Middleware para tratamento de erros de validação
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Dados inválidos',
      errors: errors.array()
    });
  }
  next();
};

// Middleware para capturar erros assíncronos
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Validações
const itemValidation = [
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Nome deve ter entre 2 e 100 caracteres')
    .matches(/^[a-zA-ZÀ-ÿ\s]+$/)
    .withMessage('Nome deve conter apenas letras e espaços'),
  body('age')
    .isInt({ min: 0, max: 150 })
    .withMessage('Idade deve ser um número entre 0 e 150')
];

const idValidation = [
  param('id')
    .isInt({ min: 1 })
    .withMessage('ID deve ser um número inteiro positivo')
];

// Funções de banco de dados
const itemQueries = {
  // Buscar todos com paginação
  findAll: async (offset, limit) => {
    const [rows] = await pool.execute(
      'SELECT id, name, age, created_at, updated_at FROM items ORDER BY created_at DESC LIMIT ? OFFSET ?',
      [limit, offset]
    );
    return rows;
  },

  // Contar total de registros
  count: async () => {
    const [rows] = await pool.execute('SELECT COUNT(*) as total FROM items');
    return rows[0].total;
  },

  // Buscar por ID
  findById: async (id) => {
    const [rows] = await pool.execute(
      'SELECT id, name, age, created_at, updated_at FROM items WHERE id = ?',
      [id]
    );
    return rows[0] || null;
  },

  // Criar novo item
  create: async (name, age) => {
    const [result] = await pool.execute(
      'INSERT INTO items (name, age) VALUES (?, ?)',
      [name, age]
    );
    return await itemQueries.findById(result.insertId);
  },

  // Atualizar item
  update: async (id, name, age) => {
    const [result] = await pool.execute(
      'UPDATE items SET name = ?, age = ? WHERE id = ?',
      [name, age, id]
    );
    
    if (result.affectedRows === 0) {
      return null;
    }
    
    return await itemQueries.findById(id);
  },

  // Deletar item
  delete: async (id) => {
    const item = await itemQueries.findById(id);
    if (!item) {
      return null;
    }
    
    const [result] = await pool.execute('DELETE FROM items WHERE id = ?', [id]);
    return result.affectedRows > 0 ? item : null;
  }
};

// Rotas

// GET /items - Listar todos os itens com paginação
app.get('/items', asyncHandler(async (req, res) => {
  const page = Math.max(1, parseInt(req.query.page) || 1);
  const limit = Math.min(100, Math.max(1, parseInt(req.query.limit) || 10));
  const offset = (page - 1) * limit;

  const [items, total] = await Promise.all([
    itemQueries.findAll(offset, limit),
    itemQueries.count()
  ]);

  res.json({
    success: true,
    data: items,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  });
}));

// GET /items/:id - Buscar item por ID
app.get('/items/:id', 
  idValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const item = await itemQueries.findById(req.params.id);
    
    if (!item) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      data: item
    });
  })
);

// POST /items - Criar novo item
app.post('/items',
  itemValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const { name, age } = req.body;
    const newItem = await itemQueries.create(name.trim(), parseInt(age));
    
    res.status(201).json({
      success: true,
      message: 'Item criado com sucesso',
      data: newItem
    });
  })
);

// PUT /items/:id - Atualizar item
app.put('/items/:id',
  idValidation,
  itemValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const { name, age } = req.body;
    const updatedItem = await itemQueries.update(
      req.params.id, 
      name.trim(), 
      parseInt(age)
    );

    if (!updatedItem) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Item atualizado com sucesso',
      data: updatedItem
    });
  })
);

// DELETE /items/:id - Deletar item
app.delete('/items/:id',
  idValidation,
  handleValidationErrors,
  asyncHandler(async (req, res) => {
    const deletedItem = await itemQueries.delete(req.params.id);

    if (!deletedItem) {
      return res.status(404).json({
        success: false,
        message: 'Item não encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Item deletado com sucesso',
      data: deletedItem
    });
  })
);

// Middleware de tratamento de erros
app.use((err, req, res, next) => {
  console.error('Erro:', err);

  // Erro de conexão MySQL
  if (err.code === 'PROTOCOL_CONNECTION_LOST') {
    return res.status(503).json({
      success: false,
      message: 'Conexão com banco de dados perdida'
    });
  }

  // Erro de sintaxe SQL
  if (err.code && err.code.startsWith('ER_')) {
    return res.status(400).json({
      success: false,
      message: 'Erro na operação do banco de dados'
    });
  }

  // Erro de constraint (chave estrangeira, unique, etc.)
  if (err.code === 'ER_DUP_ENTRY') {
    return res.status(409).json({
      success: false,
      message: 'Registro duplicado'
    });
  }

  // Erro genérico
  res.status(500).json({
    success: false,
    message: 'Erro interno do servidor'
  });
});

// Rota 404
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'Rota não encontrada'
  });
});

// Inicializar servidor
const startServer = async () => {
  try {
    await connectDB();
    app.listen(PORT, () => {
      console.log(`Servidor rodando em http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error('Erro ao iniciar servidor:', error);
    process.exit(1);
  }
};

// Tratamento de sinais de processo
const gracefulShutdown = async (signal) => {
  console.log(`Recebido ${signal}, fechando servidor graciosamente...`);
  
  if (pool) {
    await pool.end();
    console.log('Pool de conexões MySQL fechado');
  }
  
  process.exit(0);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Tratamento de erros não capturados
process.on('unhandledRejection', (err) => {
  console.error('Erro não tratado:', err);
  gracefulShutdown('unhandledRejection');
});

process.on('uncaughtException', (err) => {
  console.error('Exceção não capturada:', err);
  gracefulShutdown('uncaughtException');
});

startServer();

///////////////////////////////////////////////////////////////////// &&&
AUTENTICAÇÃO COM MONGOOSE E JWT E BCRYPT (SEM REFRESH TOKEN)
VIDEO: https://www.youtube.com/embed/qEBoZ8lJR3k

instalação:
npm i dotenv bcrypt express jsonwebtoken mongoose

------
Conectando ao banco de dados:

-Arquivo server.js: (ou index.js)

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
    app.listen(PORT)
  })
  .catch((err) => console.log(err))

---------------

Crie um arquivo User.js dentro da pasta models:

const mongoose = require('mongoose')

const User = mongoose.model('User', {
  name: String,
  email: String,
  password: String
})

export.modules = User

---------------

Adicionando um metodo POST para registrar usuario.

-Arquivo server.js:

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

const User = require('./models/User')

app.post('/auth/register', async (req, res) => {

  const {name, email, password, confirmpassword} = req.body;

  if(!name) {
    return res.status(422).json({msg: "O nome é obrigatório!"})
  }

  if(!email) {
    return res.status(422).json({msg: "O email é obrigatório!"})
  }

  if(!password) {
    return res.status(422).json({msg: "A senha é obrigatória!"})
  }

  if(password !== confirmpassword) {
    return res.status(422).json({msg: "As senhas não conferem!"})
  }

  //Check if user exists
  const userExists = await User.findOne({ email: email})

  if(userExists){
    return res.status(422).json({msg: "Usuário já cadastrado com este email!"})
  }

  //create password
  const salt = await bcrypt.genSalt(12)
  const passwordHash = await bcrypt.hash(password, salt)

  //create user
  const user = new User({
    name,
    email,
    password: passwordHash,
  })

  try {
    const newUser = await user.save();
    res.status(201).json({
      message: "Usuário criado com sucesso!",
      data: newUser
    })
  } catch (err) {
    console.log(err)
    res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
  }

})

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
    app.listen(PORT)
  })
  .catch((err) => console.log(err))

---------------

Adicionando um metodo POST para login usuario.

-Arquivo server.js:

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

const User = require('./models/User')

app.post('/auth/register', async (req, res) => {   
  ...
})

app.post('/auth/login', async (req, res) => {   

  const {email, password} = req.body;

  if(!email) {
    return res.status(422).json({msg: "O email é obrigatório!"})
  }

  if(!password) {
    return res.status(422).json({msg: "A senha é obrigatória!"})
  }

  //Check if user exists
  const user = await User.findOne({ email: email})
  if(!user){
    return res.status(404).json({msg: "Usuário não encontrado!"})
  }

  //Check if password match
  const checkPassword = await bcrypt.compare(password, user.password)
  if(!checkPassword) {
    return res.status(422).json({msg: "Senha inválida!"})
  }

  //Authentication
  try{
    const jwt_secret = process.env.JWT_SECRET

    const token = jwt.sign(
      {
        id: user._id,
      },
      jwt_secret,
    )

    res.status(200).json({
      msg: "Autenticação realizada com sucesso!", token
    })
  } catch (err){
    console.log(err)
    res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
  }

})

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
    app.listen(PORT)
  })
  .catch((err) => console.log(err))

-------------

Criando uma rota protegida:

-Arquivo server.js:

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

const User = require('./models/User')

//Private Route
app.get('/user/:id', checkToken, async (req, res) => {
  const id = req.params.id

  //Check if user exists
  const user = await User.findById(id, '-password')
  if(!user){
    return res.status(404).json({msg: "Usuário não encontrado!"})
  }

  res.status(200).json({user})
})

function checkToken(req, res, next){
  const authHeader = req.headers['authorization']

  const token = authHeader && authHeader.split(" ")[1]

  if (!token) {
    return res.status(401).json({msg: "Acesso negado!"})
  }

  try {
    const jwt_secret = process.env.JWT_SECRET
    jwt.verify(token, jwt_secret)
    next()
  } catch(err) {
    res.status(400).json({msg: "Token inválido!"})
  }
}


app.post('/auth/register', async (req, res) => {   
  ...
})

app.post('/auth/login', async (req, res) => {   
  ...
})

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
    app.listen(PORT)
  })
  .catch((err) => console.log(err))

------------------------

Metodo GET caso necessário:

app.get('/user', async (req, res) => {
  try {
    const users = await User.find()
    res.status(200).json({msg: users})
  } catch (err) {
    res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
  }
})

------------------------

Para testar a rota privada e o token no Postman ou Reqbin:

Copie o token gerado ao fazer login com algum usuario teste.

Salve esse token em uma variavel chamada TOKEN

No GET, faça uma requisição para a url {{URL}}/user/yfiyf89w9923u900     (esse é o id do usuario teste)

Clique em Authorization.
Em Type, escolha Bearer Token.
Coloque a variavel {{TOKEN}}

Clique em SEND

-------------------------

Adicionando refresh token: (ClaudeAI) MAIS SIMPLES

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

// Modelo do usuário com refresh token
const User = mongoose.model('User', {
    name: String,
    email: String,
    password: String,
    refreshToken: String                   // Adicionar campo para refresh token
})

// Private Route
app.get('/user/:id', checkToken, async (req, res) => {
    const id = req.params.id
    
    // Check if user exists
    const user = await User.findById(id, '-password -refreshToken')
    if(!user){
        return res.status(404).json({msg: "Usuário não encontrado!"})
    }
    
    res.status(200).json({user})
})

function checkToken(req, res, next){
    const authHeader = req.headers['authorization']
    const token = authHeader && authHeader.split(' ')[1]
    
    if (!token) {
        return res.status(401).json({msg: "Acesso negado!"})
    }
    
    try {
        const jwt_secret = process.env.JWT_SECRET
        const decoded = jwt.verify(token, jwt_secret)           //ADD CODE
        req.userId = decoded.id                                 //ADD CODE
        next()
    } catch(err) {
        res.status(401).json({msg: "Token inválido!"})
    }
}

app.post('/auth/register', async (req, res) => {
    const {name, email, password, confirmpassword} = req.body;
    
    if(!name) {
        return res.status(422).json({msg: "O nome é obrigatório!"})
    }
    if(!email) {
        return res.status(422).json({msg: "O email é obrigatório!"})
    }
    if(!password) {
        return res.status(422).json({msg: "A senha é obrigatória!"})
    }
    if(password !== confirmpassword) {
        return res.status(422).json({msg: "As senhas não conferem!"})
    }
    
    // Check if user exists
    const userExists = await User.findOne({ email: email})
    if(userExists){
        return res.status(422).json({msg: "Usuário já cadastrado com este email!"})
    }
    
    // Create password
    const salt = await bcrypt.genSalt(12)
    const passwordHash = await bcrypt.hash(password, salt)
    
    // Create user
    const user = new User({
        name,
        email,
        password: passwordHash,
    })
    
    try {
        const newUser = await user.save();
        res.status(201).json({ 
            message: "Usuário criado com sucesso!", 
            data: { id: newUser._id, name: newUser.name, email: newUser.email }          //OU data: newUser
        })
    } catch (err) {
        console.log(err)
        res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
    }
})

app.post('/auth/login', async (req, res) => {
    const {email, password} = req.body;
    
    if(!email) {
        return res.status(422).json({msg: "O email é obrigatório!"})
    }
    if(!password) {
        return res.status(422).json({msg: "A senha é obrigatória!"})
    }
    
    // Check if user exists
    const user = await User.findOne({ email: email})
    if(!user){
        return res.status(404).json({msg: "Usuário não encontrado!"})
    }
    
    // Check if password match
    const checkPassword = await bcrypt.compare(password, user.password)
    if(!checkPassword) {
        return res.status(422).json({msg: "Senha inválida!"})
    }
    
    // Authentication
    try{
        const jwt_secret = process.env.JWT_SECRET
        const jwt_refresh_secret = process.env.JWT_REFRESH_SECRET              //ADD CODE
        
        // Access token (curta duração - 15 minutos)                           //ADD BLOCK CODE
        const accessToken = jwt.sign(
            { id: user._id },
            jwt_secret,
            { expiresIn: '15m' }
        )
        
        // Refresh token (longa duração - 7 dias)                             //ADD BLOCK CODE
        const refreshToken = jwt.sign(
            { id: user._id },
            jwt_refresh_secret,
            { expiresIn: '7d' }
        )
        
        // Salvar refresh token no banco                   
        await User.findByIdAndUpdate(user._id, { refreshToken })             //ADD CODE  
        
        res.status(200).json({
            msg: "Autenticação realizada com sucesso!",
            accessToken,                                                     //ADD CODE
            refreshToken,                                                    //ADD CODE
            user: {                                                          //ADD CODE
                id: user._id,
                name: user.name,
                email: user.email
            }
        })
    } catch (err){
        console.log(err)
        res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
    }
})

// Rota para renovar access token
app.post('/auth/refresh', async (req, res) => {                                //ADD BLOCK CODE
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
        return res.status(401).json({msg: "Refresh token é obrigatório!"})
    }
    
    try {
        const jwt_refresh_secret = process.env.JWT_REFRESH_SECRET
        const decoded = jwt.verify(refreshToken, jwt_refresh_secret)
        
        // Verificar se o refresh token existe no banco
        const user = await User.findOne({ 
            _id: decoded.id, 
            refreshToken: refreshToken 
        })
        
        if (!user) {
            return res.status(403).json({msg: "Refresh token inválido!"})
        }
        
        // Gerar novo access token
        const jwt_secret = process.env.JWT_SECRET
        const newAccessToken = jwt.sign(
            { id: user._id },
            jwt_secret,
            { expiresIn: '15m' }
        )
        
        res.status(200).json({
            accessToken: newAccessToken,
            user: {
                id: user._id,
                name: user.name,
                email: user.email
            }
        })
        
    } catch (err) {
        res.status(403).json({msg: "Refresh token inválido!"})
    }
})

// Rota para logout                                           //ADD BLOCK CODE
app.post('/auth/logout', async (req, res) => {
    const { refreshToken } = req.body;
    
    if (refreshToken) {
        // Remover refresh token do banco
        await User.updateOne(
            { refreshToken: refreshToken },
            { $unset: { refreshToken: 1 } }
        )
    }
    
    res.status(200).json({msg: "Logout realizado com sucesso!"})
})

app.get('/user', async (req, res) => {
    try {
        const findUser = await User.find({}, '-password -refreshToken')            //ADD CODE
        res.status(200).json({msg: findUser})
    } catch (err) {
        res.status(500).json({msg: "Usuário não encontrado"})
    }
})

mongoose.connect(DB_CONNECTION)
    .then(() => {
        console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
        app.listen(PORT)
    })
    .catch((err) => console.log(err))

----------

Exemplo de form de login no front-end com ReactJS:

import React, { useState, useEffect, useCallback } from 'react';

const AuthSystem = () => {
  const [currentView, setCurrentView] = useState('login');
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState({});
  const [alerts, setAlerts] = useState({});
  const [tokenStatus, setTokenStatus] = useState('Token válido');

  const baseURL = 'http://localhost:3000';

  // Estados dos formulários
  const [loginForm, setLoginForm] = useState({ email: '', password: '' });
  const [registerForm, setRegisterForm] = useState({
    name: '',
    email: '',
    password: '',
    confirmpassword: ''
  });

  // Carregar tokens do localStorage
  useEffect(() => {
    const savedAccessToken = localStorage.getItem('accessToken');
    const savedRefreshToken = localStorage.getItem('refreshToken');
    const savedUser = localStorage.getItem('user');

    if (savedAccessToken && savedRefreshToken) {
      setAccessToken(savedAccessToken);
      setRefreshToken(savedRefreshToken);
      if (savedUser) {
        setUser(JSON.parse(savedUser));
      }
      setCurrentView('userArea');
    }
  }, []);

  // Salvar tokens no localStorage
  const saveTokensToStorage = useCallback((access, refresh, userData) => {
    if (access) localStorage.setItem('accessToken', access);
    if (refresh) localStorage.setItem('refreshToken', refresh);
    if (userData) localStorage.setItem('user', JSON.stringify(userData));
  }, []);

  // Limpar tokens do localStorage
  const clearTokensFromStorage = useCallback(() => {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    localStorage.removeItem('user');
  }, []);

  // Mostrar alerta
  const showAlert = useCallback((type, message, alertType) => {
    setAlerts(prev => ({ ...prev, [type]: { message, type: alertType } }));
    setTimeout(() => {
      setAlerts(prev => ({ ...prev, [type]: null }));
    }, 5000);
  }, []);

  // Definir loading
  const setLoadingState = useCallback((key, isLoading) => {
    setLoading(prev => ({ ...prev, [key]: isLoading }));
  }, []);

  // Renovar access token
  const refreshAccessToken = useCallback(async () => {
    try {
      const response = await fetch(`${baseURL}/auth/refresh`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken })
      });

      const data = await response.json();

      if (response.ok) {
        setAccessToken(data.accessToken);
        setUser(data.user);
        saveTokensToStorage(data.accessToken, refreshToken, data.user);
        setTokenStatus('Token renovado automaticamente');
        return data.accessToken;
      } else {
        setTokenStatus('Erro ao renovar token');
        handleLogout();
        return null;
      }
    } catch (error) {
      console.error('Erro ao renovar token:', error);
      setTokenStatus('Erro de conexão');
      return null;
    }
  }, [refreshToken, saveTokensToStorage]);

  // Fazer requisição autenticada
  const makeAuthenticatedRequest = useCallback(async (url, options = {}) => {
    let currentAccessToken = accessToken;

    const requestOptions = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${currentAccessToken}`,
        ...options.headers
      }
    };

    let response = await fetch(url, requestOptions);

    if (response.status === 401) {
      const newToken = await refreshAccessToken();
      if (newToken) {
        currentAccessToken = newToken;
        requestOptions.headers['Authorization'] = `Bearer ${currentAccessToken}`;
        response = await fetch(url, requestOptions);
      }
    }

    return response;
  }, [accessToken, refreshAccessToken]);

  // Auto refresh do token
  useEffect(() => {
    if (accessToken && refreshToken) {
      const interval = setInterval(() => {
        refreshAccessToken();
      }, 10 * 60 * 1000); // 10 minutos

      return () => clearInterval(interval);
    }
  }, [accessToken, refreshToken, refreshAccessToken]);

  // Handler do login
  const handleLogin = async (e) => {
    e.preventDefault();
    setLoadingState('login', true);

    try {
      const response = await fetch(`${baseURL}/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(loginForm)
      });

      const data = await response.json();

      if (response.ok) {
        setAccessToken(data.accessToken);
        setRefreshToken(data.refreshToken);
        setUser(data.user);
        saveTokensToStorage(data.accessToken, data.refreshToken, data.user);
        showAlert('login', 'Login realizado com sucesso!', 'success');
        
        setTimeout(() => {
          setCurrentView('userArea');
        }, 1000);
      } else {
        showAlert('login', data.msg, 'danger');
      }
    } catch (error) {
      showAlert('login', 'Erro de conexão com o servidor', 'danger');
    } finally {
      setLoadingState('login', false);
    }
  };

  // Handler do registro
  const handleRegister = async (e) => {
    e.preventDefault();
    setLoadingState('register', true);

    try {
      const response = await fetch(`${baseURL}/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(registerForm)
      });

      const data = await response.json();

      if (response.ok) {
        showAlert('register', 'Cadastro realizado com sucesso! Faça login.', 'success');
        setTimeout(() => {
          setCurrentView('login');
        }, 2000);
      } else {
        showAlert('register', data.msg, 'danger');
      }
    } catch (error) {
      showAlert('register', 'Erro de conexão com o servidor', 'danger');
    } finally {
      setLoadingState('register', false);
    }
  };

  // Handler do logout
  const handleLogout = async () => {
    try {
      await fetch(`${baseURL}/auth/logout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken })
      });
    } catch (error) {
      console.error('Erro no logout:', error);
    }

    setAccessToken(null);
    setRefreshToken(null);
    setUser(null);
    clearTokensFromStorage();
    setCurrentView('login');
  };

  // Carregar dados do usuário
  const loadUserData = async () => {
    if (!user || !user.id) {
      showAlert('user', 'ID do usuário não encontrado', 'danger');
      return;
    }

    setLoadingState('loadUser', true);

    try {
      const response = await makeAuthenticatedRequest(`${baseURL}/user/${user.id}`);
      const data = await response.json();

      if (response.ok) {
        showAlert('user', 'Dados carregados com sucesso!', 'success');
        console.log('Dados do usuário:', data.user);
      } else {
        showAlert('user', data.msg, 'danger');
      }
    } catch (error) {
      showAlert('user', 'Erro de conexão com o servidor', 'danger');
    } finally {
      setLoadingState('loadUser', false);
    }
  };

  // Listar todos os usuários
  const listAllUsers = async () => {
    setLoadingState('listUsers', true);

    try {
      const response = await makeAuthenticatedRequest(`${baseURL}/user`);
      const data = await response.json();

      if (response.ok) {
        showAlert('user', `${data.msg.length} usuários encontrados!`, 'success');
        console.log('Lista de usuários:', data.msg);
      } else {
        showAlert('user', data.msg, 'danger');
      }
    } catch (error) {
      showAlert('user', 'Erro de conexão com o servidor', 'danger');
    } finally {
      setLoadingState('listUsers', false);
    }
  };

  // Componente de alerta
  const Alert = ({ alert }) => {
    if (!alert) return null;
    
    return (
      <div style={{ 
        padding: '10px', 
        margin: '10px 0', 
        border: '1px solid',
        borderRadius: '4px',
        backgroundColor: alert.type === 'success' ? '#d4edda' : '#f8d7da',
        color: alert.type === 'success' ? '#155724' : '#721c24',
        borderColor: alert.type === 'success' ? '#c3e6cb' : '#f5c6cb'
      }}>
        {alert.message}
      </div>
    );
  };

  // Tela de Login
  const LoginForm = () => (
    <div>
      <h1>Fazer Login</h1>
      <p>Entre com suas credenciais</p>
      
      <Alert alert={alerts.login} />
      
      <div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={loginForm.email}
            onChange={(e) => setLoginForm(prev => ({ ...prev, email: e.target.value }))}
            required
          />
        </div>
        
        <div>
          <label>Senha:</label>
          <input
            type="password"
            value={loginForm.password}
            onChange={(e) => setLoginForm(prev => ({ ...prev, password: e.target.value }))}
            required
          />
        </div>
        
        <button onClick={handleLogin} disabled={loading.login}>
          {loading.login ? 'Carregando...' : 'Entrar'}
        </button>
      </div>
      
      <p>
        Não tem conta?{' '}
        <button type="button" onClick={() => setCurrentView('register')}>
          Cadastre-se
        </button>
      </p>
    </div>
  );

  // Tela de Registro
  const RegisterForm = () => (
    <div>
      <h1>Criar Conta</h1>
      <p>Preencha os dados para se cadastrar</p>
      
      <Alert alert={alerts.register} />
      
      <div>
        <div>
          <label>Nome:</label>
          <input
            type="text"
            value={registerForm.name}
            onChange={(e) => setRegisterForm(prev => ({ ...prev, name: e.target.value }))}
            required
          />
        </div>
        
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={registerForm.email}
            onChange={(e) => setRegisterForm(prev => ({ ...prev, email: e.target.value }))}
            required
          />
        </div>
        
        <div>
          <label>Senha:</label>
          <input
            type="password"
            value={registerForm.password}
            onChange={(e) => setRegisterForm(prev => ({ ...prev, password: e.target.value }))}
            required
          />
        </div>
        
        <div>
          <label>Confirmar Senha:</label>
          <input
            type="password"
            value={registerForm.confirmpassword}
            onChange={(e) => setRegisterForm(prev => ({ ...prev, confirmpassword: e.target.value }))}
            required
          />
        </div>
        
        <button onClick={handleRegister} disabled={loading.register}>
          {loading.register ? 'Carregando...' : 'Cadastrar'}
        </button>
      </div>
      
      <p>
        Já tem conta?{' '}
        <button type="button" onClick={() => setCurrentView('login')}>
          Fazer login
        </button>
      </p>
    </div>
  );

  // Área do Usuário
  const UserArea = () => (
    <div>
      <h1>Área do Usuário</h1>
      <p>Bem-vindo ao sistema!</p>
      
      {user && (
        <div style={{ padding: '10px', margin: '10px 0', backgroundColor: '#f8f9fa', border: '1px solid #dee2e6' }}>
          <h3>Informações do Usuário</h3>
          <p><strong>ID:</strong> {user.id}</p>
          <p><strong>Nome:</strong> {user.name}</p>
          <p><strong>Email:</strong> {user.email}</p>
        </div>
      )}
      
      <Alert alert={alerts.user} />
      
      <div>
        <button onClick={loadUserData} disabled={loading.loadUser}>
          {loading.loadUser ? 'Carregando...' : 'Carregar Dados do Usuário'}
        </button>
        
        <button onClick={listAllUsers} disabled={loading.listUsers}>
          {loading.listUsers ? 'Carregando...' : 'Listar Todos os Usuários'}
        </button>
        
        <button onClick={handleLogout}>
          Sair
        </button>
      </div>
      
      <p style={{ fontSize: '0.9em', color: '#666', marginTop: '10px' }}>
        {tokenStatus}
      </p>
    </div>
  );

  // Renderizar a view atual
  const renderCurrentView = () => {
    switch (currentView) {
      case 'login':
        return <LoginForm />;
      case 'register':
        return <RegisterForm />;
      case 'userArea':
        return <UserArea />;
      default:
        return <LoginForm />;
    }
  };

  return (
    <div style={{ maxWidth: '500px', margin: '0 auto', padding: '20px' }}>
      {renderCurrentView()}
    </div>
  );
};

export default AuthSystem;

----------

Exemplo de form de login no front-end com HTML puro:

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Autenticação</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            width: 100%;
            max-width: 500px;
            transition: all 0.3s ease;
        }

        .container:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e1e5e9;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 107, 107, 0.3);
        }

        .alert {
            padding: 12px 16px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .form-switch {
            text-align: center;
            margin-top: 20px;
        }

        .form-switch a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .form-switch a:hover {
            text-decoration: underline;
        }

        .user-info {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .user-info h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .user-info p {
            color: #666;
            margin-bottom: 5px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .token-status {
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Tela de Login -->
        <div id="loginForm">
            <div class="header">
                <h1>Fazer Login</h1>
                <p>Entre com suas credenciais</p>
            </div>
            
            <div id="loginAlert"></div>
            
            <form id="loginFormElement">
                <div class="form-group">
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" required>
                </div>
                
                <div class="form-group">
                    <label for="loginPassword">Senha:</label>
                    <input type="password" id="loginPassword" required>
                </div>
                
                <button type="submit" class="btn btn-primary" id="loginBtn">
                    Entrar
                </button>
            </form>
            
            <div class="form-switch">
                <p>Não tem conta? <a href="#" id="showRegister">Cadastre-se</a></p>
            </div>
        </div>

        <!-- Tela de Registro -->
        <div id="registerForm" class="hidden">
            <div class="header">
                <h1>Criar Conta</h1>
                <p>Preencha os dados para se cadastrar</p>
            </div>
            
            <div id="registerAlert"></div>
            
            <form id="registerFormElement">
                <div class="form-group">
                    <label for="registerName">Nome:</label>
                    <input type="text" id="registerName" required>
                </div>
                
                <div class="form-group">
                    <label for="registerEmail">Email:</label>
                    <input type="email" id="registerEmail" required>
                </div>
                
                <div class="form-group">
                    <label for="registerPassword">Senha:</label>
                    <input type="password" id="registerPassword" required>
                </div>
                
                <div class="form-group">
                    <label for="confirmPassword">Confirmar Senha:</label>
                    <input type="password" id="confirmPassword" required>
                </div>
                
                <button type="submit" class="btn btn-primary" id="registerBtn">
                    Cadastrar
                </button>
            </form>
            
            <div class="form-switch">
                <p>Já tem conta? <a href="#" id="showLogin">Fazer login</a></p>
            </div>
        </div>

        <!-- Área do Usuário Logado -->
        <div id="userArea" class="hidden">
            <div class="header">
                <h1>Área do Usuário</h1>
                <p>Bem-vindo ao sistema!</p>
            </div>
            
            <div id="userInfo" class="user-info"></div>
            
            <div id="userAlert"></div>
            
            <button class="btn btn-secondary" id="loadUserBtn">
                Carregar Dados do Usuário
            </button>
            
            <button class="btn btn-secondary" id="listUsersBtn">
                Listar Todos os Usuários
            </button>
            
            <button class="btn btn-danger" id="logoutBtn">
                Sair
            </button>
            
            <div class="token-status" id="tokenStatus">
                Token válido
            </div>
        </div>
    </div>

    <script>
        class AuthSystem {
            constructor() {
                this.baseURL = 'http://localhost:3000'; // Ajuste para sua URL
                this.accessToken = null;
                this.refreshToken = null;
                this.user = null;
                this.tokenRefreshInterval = null;
                
                this.init();
            }

            init() {
                // Carregar tokens do localStorage se existirem
                this.loadTokensFromStorage();
                
                // Verificar se já está logado
                if (this.accessToken && this.refreshToken) {
                    this.showUserArea();
                    this.startTokenRefresh();
                } else {
                    this.showLoginForm();
                }
                
                this.bindEvents();
            }

            bindEvents() {
                // Alternância entre formulários
                document.getElementById('showRegister').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showRegisterForm();
                });

                document.getElementById('showLogin').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showLoginForm();
                });

                // Formulários
                document.getElementById('loginFormElement').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleLogin();
                });

                document.getElementById('registerFormElement').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleRegister();
                });

                // Botões da área do usuário
                document.getElementById('logoutBtn').addEventListener('click', () => {
                    this.handleLogout();
                });

                document.getElementById('loadUserBtn').addEventListener('click', () => {
                    this.loadUserData();
                });

                document.getElementById('listUsersBtn').addEventListener('click', () => {
                    this.listAllUsers();
                });
            }

            // Gerenciamento de tokens
            saveTokensToStorage() {
                if (this.accessToken) {
                    localStorage.setItem('accessToken', this.accessToken);
                }
                if (this.refreshToken) {
                    localStorage.setItem('refreshToken', this.refreshToken);
                }
                if (this.user) {
                    localStorage.setItem('user', JSON.stringify(this.user));
                }
            }

            loadTokensFromStorage() {
                this.accessToken = localStorage.getItem('accessToken');
                this.refreshToken = localStorage.getItem('refreshToken');
                const userData = localStorage.getItem('user');
                if (userData) {
                    this.user = JSON.parse(userData);
                }
            }

            clearTokensFromStorage() {
                localStorage.removeItem('accessToken');
                localStorage.removeItem('refreshToken');
                localStorage.removeItem('user');
            }

            // Refresh automático do token
            startTokenRefresh() {
                // Tentar renovar o token a cada 10 minutos
                this.tokenRefreshInterval = setInterval(() => {
                    this.refreshAccessToken();
                }, 10 * 60 * 1000);
            }

            stopTokenRefresh() {
                if (this.tokenRefreshInterval) {
                    clearInterval(this.tokenRefreshInterval);
                    this.tokenRefreshInterval = null;
                }
            }

            async refreshAccessToken() {
                try {
                    const response = await fetch(`${this.baseURL}/auth/refresh`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            refreshToken: this.refreshToken
                        })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        this.accessToken = data.accessToken;
                        this.user = data.user;
                        this.saveTokensToStorage();
                        this.updateTokenStatus('Token renovado automaticamente');
                    } else {
                        this.updateTokenStatus('Erro ao renovar token');
                        this.handleLogout();
                    }
                } catch (error) {
                    console.error('Erro ao renovar token:', error);
                    this.updateTokenStatus('Erro de conexão');
                }
            }

            // Requisições com interceptação automática
            async makeAuthenticatedRequest(url, options = {}) {
                const requestOptions = {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.accessToken}`,
                        ...options.headers
                    }
                };

                let response = await fetch(url, requestOptions);

                // Se o token expirou, tentar renovar
                if (response.status === 401) {
                    await this.refreshAccessToken();
                    
                    // Repetir a requisição com o novo token
                    requestOptions.headers['Authorization'] = `Bearer ${this.accessToken}`;
                    response = await fetch(url, requestOptions);
                }

                return response;
            }

            // Interface
            showLoginForm() {
                document.getElementById('loginForm').classList.remove('hidden');
                document.getElementById('registerForm').classList.add('hidden');
                document.getElementById('userArea').classList.add('hidden');
            }

            showRegisterForm() {
                document.getElementById('loginForm').classList.add('hidden');
                document.getElementById('registerForm').classList.remove('hidden');
                document.getElementById('userArea').classList.add('hidden');
            }

            showUserArea() {
                document.getElementById('loginForm').classList.add('hidden');
                document.getElementById('registerForm').classList.add('hidden');
                document.getElementById('userArea').classList.remove('hidden');
                
                if (this.user) {
                    this.displayUserInfo();
                }
            }

            displayUserInfo() {
                const userInfoDiv = document.getElementById('userInfo');
                userInfoDiv.innerHTML = `
                    <h3>Informações do Usuário</h3>
                    <p><strong>ID:</strong> ${this.user.id}</p>
                    <p><strong>Nome:</strong> ${this.user.name}</p>
                    <p><strong>Email:</strong> ${this.user.email}</p>
                `;
            }

            showAlert(elementId, message, type) {
                const alertDiv = document.getElementById(elementId);
                alertDiv.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
                
                setTimeout(() => {
                    alertDiv.innerHTML = '';
                }, 5000);
            }

            updateTokenStatus(message) {
                const statusDiv = document.getElementById('tokenStatus');
                statusDiv.textContent = message;
            }

            setLoading(buttonId, isLoading) {
                const button = document.getElementById(buttonId);
                if (isLoading) {
                    button.innerHTML = '<span class="loading"></span>Carregando...';
                    button.disabled = true;
                } else {
                    button.disabled = false;
                    // Restaurar texto original baseado no ID
                    const originalTexts = {
                        'loginBtn': 'Entrar',
                        'registerBtn': 'Cadastrar',
                        'loadUserBtn': 'Carregar Dados do Usuário',
                        'listUsersBtn': 'Listar Todos os Usuários'
                    };
                    button.innerHTML = originalTexts[buttonId] || 'Botão';
                }
            }

            // Handlers dos formulários
            async handleLogin() {
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;

                this.setLoading('loginBtn', true);

                try {
                    const response = await fetch(`${this.baseURL}/auth/login`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ email, password })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        this.accessToken = data.accessToken;
                        this.refreshToken = data.refreshToken;
                        this.user = data.user;
                        
                        this.saveTokensToStorage();
                        this.showAlert('loginAlert', 'Login realizado com sucesso!', 'success');
                        
                        setTimeout(() => {
                            this.showUserArea();
                            this.startTokenRefresh();
                        }, 1000);
                    } else {
                        this.showAlert('loginAlert', data.msg, 'danger');
                    }
                } catch (error) {
                    this.showAlert('loginAlert', 'Erro de conexão com o servidor', 'danger');
                } finally {
                    this.setLoading('loginBtn', false);
                }
            }

            async handleRegister() {
                const name = document.getElementById('registerName').value;
                const email = document.getElementById('registerEmail').value;
                const password = document.getElementById('registerPassword').value;
                const confirmpassword = document.getElementById('confirmPassword').value;

                this.setLoading('registerBtn', true);

                try {
                    const response = await fetch(`${this.baseURL}/auth/register`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ name, email, password, confirmpassword })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        this.showAlert('registerAlert', 'Cadastro realizado com sucesso! Faça login.', 'success');
                        
                        setTimeout(() => {
                            this.showLoginForm();
                        }, 2000);
                    } else {
                        this.showAlert('registerAlert', data.msg, 'danger');
                    }
                } catch (error) {
                    this.showAlert('registerAlert', 'Erro de conexão com o servidor', 'danger');
                } finally {
                    this.setLoading('registerBtn', false);
                }
            }

            async handleLogout() {
                try {
                    await fetch(`${this.baseURL}/auth/logout`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            refreshToken: this.refreshToken
                        })
                    });
                } catch (error) {
                    console.error('Erro no logout:', error);
                }

                this.accessToken = null;
                this.refreshToken = null;
                this.user = null;
                this.clearTokensFromStorage();
                this.stopTokenRefresh();
                this.showLoginForm();
            }

            async loadUserData() {
                if (!this.user || !this.user.id) {
                    this.showAlert('userAlert', 'ID do usuário não encontrado', 'danger');
                    return;
                }

                this.setLoading('loadUserBtn', true);

                try {
                    const response = await this.makeAuthenticatedRequest(
                        `${this.baseURL}/user/${this.user.id}`
                    );

                    const data = await response.json();

                    if (response.ok) {
                        this.showAlert('userAlert', 'Dados carregados com sucesso!', 'success');
                        console.log('Dados do usuário:', data.user);
                    } else {
                        this.showAlert('userAlert', data.msg, 'danger');
                    }
                } catch (error) {
                    this.showAlert('userAlert', 'Erro de conexão com o servidor', 'danger');
                } finally {
                    this.setLoading('loadUserBtn', false);
                }
            }

            async listAllUsers() {
                this.setLoading('listUsersBtn', true);

                try {
                    const response = await this.makeAuthenticatedRequest(`${this.baseURL}/user`);
                    const data = await response.json();

                    if (response.ok) {
                        this.showAlert('userAlert', `${data.msg.length} usuários encontrados!`, 'success');
                        console.log('Lista de usuários:', data.msg);
                    } else {
                        this.showAlert('userAlert', data.msg, 'danger');
                    }
                } catch (error) {
                    this.showAlert('userAlert', 'Erro de conexão com o servidor', 'danger');
                } finally {
                    this.setLoading('listUsersBtn', false);
                }
            }
        }

        // Inicializar o sistema quando a página carregar
        document.addEventListener('DOMContentLoaded', () => {
            new AuthSystem();
        });
    </script>
</body>
</html>

-------------------------

Adicionando refresh token v2: (ClaudeAI) MAIS COMPLETO???

const express = require('express')
const app = express()
app.use(express.json())
const mongoose = require('mongoose')
require("dotenv").config()
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')

const DB_CONNECTION = process.env.DB_TABELA
const PORT = process.env.DB_PORT

const User = mongoose.model('User', {
  name: String,
  email: String,
  password: String
})

// Modelo para armazenar refresh tokens
const RefreshToken = mongoose.model('RefreshToken', {
  token: String,
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  expiresAt: Date,
  createdAt: { type: Date, default: Date.now }
})

// Função para gerar tokens
function generateTokens(userId) {
  const jwt_secret = process.env.JWT_SECRET
  const refresh_secret = process.env.JWT_REFRESH_SECRET

  const accessToken = jwt.sign(
    { id: userId },
    jwt_secret,
    { expiresIn: '15m' } // Access token expira em 15 minutos
  )

  const refreshToken = jwt.sign(
    { id: userId },
    refresh_secret,
    { expiresIn: '7d' } // Refresh token expira em 7 dias
  )

  return { accessToken, refreshToken }
}

// Função para salvar refresh token no banco
async function saveRefreshToken(token, userId) {
  const expiresAt = new Date()
  expiresAt.setDate(expiresAt.getDate() + 7) // 7 dias

  const refreshTokenDoc = new RefreshToken({
    token,
    userId,
    expiresAt
  })

  await refreshTokenDoc.save()
}

// Middleware para verificar access token
function checkToken(req, res, next) {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]

  if (!token) {
    return res.status(401).json({ msg: "Access token requerido!" })
  }

  try {
    const jwt_secret = process.env.JWT_SECRET
    const decoded = jwt.verify(token, jwt_secret)
    req.userId = decoded.id
    next()
  } catch(err) {
    if (err.name === 'TokenExpiredError') {
      return res.status(401).json({ msg: "Access token expirado!", expired: true })
    }
    res.status(401).json({ msg: "Access token inválido!" })
  }
}

//Private Route
app.get('/user/:id', checkToken, async (req, res) => {
  const id = req.params.id

  //Check if user exists
  const user = await User.findById(id, '-password')
  if(!user){
    return res.status(404).json({msg: "Usuário não encontrado!"})
  }

  res.status(200).json({user})
})

app.post('/auth/register', async (req, res) => {
  const {name, email, password, confirmpassword} = req.body;

  if(!name) {
    return res.status(422).json({msg: "O nome é obrigatório!"})
  }

  if(!email) {
    return res.status(422).json({msg: "O email é obrigatório!"})
  }

  if(!password) {
    return res.status(422).json({msg: "A senha é obrigatória!"})
  }

  if(password !== confirmpassword) {
    return res.status(422).json({msg: "As senhas não conferem!"})
  }

  //Check if user exists
  const userExists = await User.findOne({ email: email})

  if(userExists){
    return res.status(422).json({msg: "Usuário já cadastrado com este email!"})
  }

  //create password
  const salt = await bcrypt.genSalt(12)
  const passwordHash = await bcrypt.hash(password, salt)

  //create user
  const user = new User({
    name,
    email,
    password: passwordHash,
  })

  try {
    const newUser = await user.save();
    res.status(201).json({
      message: "Usuário criado com sucesso!",
      data: newUser
    })
  } catch (err) {
    console.log(err)
    res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
  }
})

app.post('/auth/login', async (req, res) => {   
  const {email, password} = req.body;

  if(!email) {
    return res.status(422).json({msg: "O email é obrigatório!"})
  }

  if(!password) {
    return res.status(422).json({msg: "A senha é obrigatória!"})
  }

  //Check if user exists
  const user = await User.findOne({ email: email})
  if(!user){
    return res.status(404).json({msg: "Usuário não encontrado!"})
  }

  //Check if password match
  const checkPassword = await bcrypt.compare(password, user.password)
  if(!checkPassword) {
    return res.status(422).json({msg: "Senha inválida!"})
  }

  //Authentication
  try{
    const { accessToken, refreshToken } = generateTokens(user._id)
    
    // Salvar refresh token no banco
    await saveRefreshToken(refreshToken, user._id)

    res.status(200).json({
      msg: "Autenticação realizada com sucesso!",
      accessToken,
      refreshToken,
      user: {
        id: user._id,
        name: user.name,
        email: user.email
      }
    })
  } catch (err){
    console.log(err)
    res.status(500).json({msg: "Aconteceu um erro no servidor. Tente mais tarde!"})
  }
})

// Rota para renovar access token usando refresh token
app.post('/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body

  if (!refreshToken) {
    return res.status(401).json({ msg: "Refresh token requerido!" })
  }

  try {
    // Verificar se o refresh token existe no banco
    const tokenDoc = await RefreshToken.findOne({ token: refreshToken })
    
    if (!tokenDoc) {
      return res.status(401).json({ msg: "Refresh token inválido!" })
    }

    // Verificar se o refresh token não expirou
    if (tokenDoc.expiresAt < new Date()) {
      await RefreshToken.deleteOne({ token: refreshToken })
      return res.status(401).json({ msg: "Refresh token expirado!" })
    }

    // Verificar a assinatura do refresh token
    const refresh_secret = process.env.JWT_REFRESH_SECRET
    const decoded = jwt.verify(refreshToken, refresh_secret)

    // Gerar novos tokens
    const { accessToken, refreshToken: newRefreshToken } = generateTokens(decoded.id)

    // Remover o refresh token antigo e salvar o novo
    await RefreshToken.deleteOne({ token: refreshToken })
    await saveRefreshToken(newRefreshToken, decoded.id)

    res.status(200).json({
      msg: "Tokens renovados com sucesso!",
      accessToken,
      refreshToken: newRefreshToken
    })

  } catch (err) {
    console.log(err)
    return res.status(401).json({ msg: "Refresh token inválido!" })
  }
})

// Rota para logout (invalidar refresh token)
app.post('/auth/logout', async (req, res) => {
  const { refreshToken } = req.body

  if (!refreshToken) {
    return res.status(400).json({ msg: "Refresh token requerido!" })
  }

  try {
    // Remover refresh token do banco
    await RefreshToken.deleteOne({ token: refreshToken })
    res.status(200).json({ msg: "Logout realizado com sucesso!" })
  } catch (err) {
    console.log(err)
    res.status(500).json({ msg: "Erro no servidor!" })
  }
})

// Rota para logout de todos os dispositivos
app.post('/auth/logout-all', checkToken, async (req, res) => {
  try {
    // Remover todos os refresh tokens do usuário
    await RefreshToken.deleteMany({ userId: req.userId })
    res.status(200).json({ msg: "Logout de todos os dispositivos realizado com sucesso!" })
  } catch (err) {
    console.log(err)
    res.status(500).json({ msg: "Erro no servidor!" })
  }
})

app.get('/user', async (req, res) => {
  try {
    const findUser = await User.find()
    res.status(200).json({msg: findUser})
  } catch (err) {
    res.status(500).json({msg: "Usuário não encontrado"})
  }
})

// Limpeza automática de refresh tokens expirados (executar periodicamente)
setInterval(async () => {
  try {
    await RefreshToken.deleteMany({ expiresAt: { $lt: new Date() } })
    console.log('Refresh tokens expirados removidos')
  } catch (err) {
    console.log('Erro ao limpar refresh tokens:', err)
  }
}, 24 * 60 * 60 * 1000) // Executa a cada 24 horas

mongoose.connect(DB_CONNECTION)
  .then(() => {
    console.log(`Conectado ao MongoDB: http://localhost:${PORT}`)
    app.listen(PORT)
  })
  .catch((err) => console.log(err))

---------

Implementação no front-end do refresh token:

// Interceptor para requisições (exemplo com axios)
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401 && error.response?.data?.expired) {
      const refreshToken = localStorage.getItem('refreshToken')
      
      try {
        const response = await axios.post('/auth/refresh', { refreshToken })
        const { accessToken, refreshToken: newRefreshToken } = response.data
        
        localStorage.setItem('accessToken', accessToken)
        localStorage.setItem('refreshToken', newRefreshToken)
        
        // Repetir a requisição original
        return axios(error.config)
      } catch (refreshError) {
        // Redirect para login
        window.location.href = '/login'
      }
    }
    return Promise.reject(error)
  }
)

///////////////////////////////////////////////////////////////////// &&&

AUTENTICAÇÃO COM MONGOOSE, JWT, BCRYPT e REFRESH TOKEN (MUITO COMPLICADO!!!!!)
LINK: https://www.corbado.com/blog/nodejs-express-mongodb-jwt-authentication-roles

Instalação:
npm install express cors bcryptjs jsonwebtoken mongoose

ESTRUTURA:

root/
├── app/
│   ├── config/
│   │   ├── auth.config.js
│   │   └── db.config.js
│   ├── controllers/
│   │   ├── auth.controller.js
│   │   └── user.controller.js
│   ├── middlewares/
│   │   ├── authJwt.js
│   │   └── verifySignUp.js
│   ├── models/
│   │   ├── index.js
│   │   ├── role.model.js
│   │   └── user.model.js
│   └── routes/
│       ├── auth.routes.js
│       └── user.routes.js
├── package.json
└── server.js

--------------

-Arquivo server.js:

// server.js
import express from "express";
import cors from "cors";
import db from "./app/models/index.js";
import authRoutes from "./app/routes/auth.routes.js";
import userRoutes from "./app/routes/user.routes.js";
 
const app = express();
 
// Middleware configuration
const corsOptions = {
    origin: "http://localhost:3000",           //Dominio e porta onde está o front-end
};
 
app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
 
// Simple route for testing
app.get("/", (req, res) => {
    res.json({ message: "Welcome to the Node.js JWT Authentication application." });
});
 
// Routes
app.use("/api/auth", authRoutes);
app.use("/api/test", userRoutes);
 
// Set port and start server
const PORT = process.env.PORT || 3001;                 //Porta onde está o back-end
 
// Connect to MongoDB and start the server
db.mongoose
    .connect(`mongodb://${db.config.HOST}:${db.config.PORT}/${db.config.DB}`)
    .then(() => {
        console.log("Successfully connected to MongoDB.");
        // Initialize roles in the database
        initial();
        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}.`);
        });
    })
    .catch((err) => {
        console.error("Connection error:", err);
        process.exit();
    });
 
// Initial function to populate roles
function initial() {
    db.Role.estimatedDocumentCount()
        .then((count) => {
            if (count === 0) {
                return Promise.all([
                    new db.Role({ name: "user" }).save(),
                    new db.Role({ name: "admin" }).save(),
                    new db.Role({ name: "moderator" }).save(),
                ]);
            }
        })
        .then((roles) => {
            if (roles) {
                console.log(
                    "Added 'user', 'admin', and 'moderator' to roles collection.",
                );
            }
        })
        .catch((err) => {
            console.error("Error initializing roles:", err);
        });
}

-------------------

Configure MongoDB Database:

// app/config/db.config.js

export default {
    HOST: "localhost",
    PORT: 27017,
    DB: "node_js_jwt_auth_db",
};

-------------------

Define Mongoose Models:

// app/models/user.model.js


import mongoose from "mongoose";
 
const userSchema = new mongoose.Schema(
    {
        username: {
            type: String,
            required: true,
            unique: true,
            trim: true,
        },
        email: {
            type: String,
            required: true,
            unique: true,
            trim: true,
            lowercase: true,
        },
        password: {
            type: String,
            required: true,
            minlength: 6,
        },
        roles: [
            {
                type: mongoose.Schema.Types.ObjectId,
                ref: "Role",
            },
        ],
    },
    { timestamps: true },
);
 
const User = mongoose.model("User", userSchema);
export default User;

-------------------

Role Model:

// app/models/role.model.js


import mongoose from "mongoose";
 
const roleSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        unique: true,
    },
});
 
const Role = mongoose.model("Role", roleSchema);
export default Role;

--------------------

Index Model:

// app/models/index.js


import mongoose from "mongoose";
import dbConfig from "../config/db.config.js";
 
import User from "./user.model.js";
import Role from "./role.model.js";
 
const db = {};
 
db.mongoose = mongoose;
db.User = User;
db.Role = Role;
 
db.ROLES = ["user", "admin", "moderator"];
db.config = dbConfig;
 
export default db;


----------------

Configure Authentication Keys:

// app/config/auth.config.js

export default {
    secret: "your-secret-key", 
};

----------------

Create Middleware Functions:
Verify Sign-Up Middleware

// app/middlewares/verifySignUp.js


import db from "../models/index.js";
 
const ROLES = db.ROLES;
const User = db.User;
 
const checkDuplicateUsernameOrEmail = async (req, res, next) => {
    try {
        // Check if username exists
        const userByUsername = await User.findOne({ username: req.body.username });
        if (userByUsername) {
            return res
                .status(400)
                .json({ message: "Failed! Username is already in use!" });
        }
 
        // Check if email exists
        const userByEmail = await User.findOne({ email: req.body.email });
        if (userByEmail) {
            return res.status(400).json({ message: "Failed! Email is already in use!" });
        }
 
        next();
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};
 
const checkRolesExisted = (req, res, next) => {
    if (req.body.roles) {
        const invalidRoles = req.body.roles.filter((role) => !ROLES.includes(role));
        if (invalidRoles.length > 0) {
            return res.status(400).json({
                message: `Failed! Roles [${invalidRoles.join(", ")}] do not exist!`,
            });
        }
    }
    next();
};
 
const verifySignUp = {
    checkDuplicateUsernameOrEmail,
    checkRolesExisted,
};
 
export default verifySignUp;

----------------

Create Middleware Functions:
JWT Authentication Middleware

// app/middlewares/authJwt.js
import jwt from "jsonwebtoken";
import config from "../config/auth.config.js";
import db from "../models/index.js";
 
const User = db.User;
const Role = db.Role;
 
const verifyToken = async (req, res, next) => {
    let token = req.headers["x-access-token"] || req.headers["authorization"];
 
    if (!token) {
        return res.status(403).json({ message: "No token provided!" });
    }
 
    // Remove 'Bearer ' prefix if present
    if (token.startsWith("Bearer ")) {
        token = token.slice(7, token.length);
    }
 
    try {
        const decoded = jwt.verify(token, config.secret);
        req.userId = decoded.id;
 
        // Fetch user details
        const user = await User.findById(req.userId);
        if (!user) {
            return res.status(404).json({ message: "User not found!" });
        }
 
        req.user = user;
        next();
    } catch (err) {
        return res.status(401).json({ message: "Unauthorized!" });
    }
};
 
const isAdmin = async (req, res, next) => {
    try {
        const user = req.user;
        const roles = await Role.find({ _id: { $in: user.roles } });
 
        const hasAdminRole = roles.some((role) => role.name === "admin");
 
        if (!hasAdminRole) {
            return res.status(403).json({ message: "Require Admin Role!" });
        }
 
        next();
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};
 
const isModerator = async (req, res, next) => {
    try {
        const user = req.user;
        const roles = await Role.find({ _id: { $in: user.roles } });
 
        const hasModeratorRole = roles.some((role) => role.name === "moderator");
 
        if (!hasModeratorRole) {
            return res.status(403).json({ message: "Require Moderator Role!" });
        }
 
        next();
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};
 
const authJwt = {
    verifyToken,
    isAdmin,
    isModerator,
};
 
export default authJwt;

------------------

Index Middleware

// app/middlewares/index.js

import authJwt from "./authJwt.js";
import verifySignUp from "./verifySignUp.js";
 
export { authJwt, verifySignUp };

-----------------

Create Controllers:
Authentication Controller

// app/controllers/auth.controller.js

import config from "../config/auth.config.js";
import db from "../models/index.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";
 
const User = db.User;
const Role = db.Role;
 
export const signup = async (req, res) => {
    try {
        // Create a new user
        const user = new User({
            username: req.body.username,
            email: req.body.email,
            password: bcrypt.hashSync(req.body.password, 8),
        });
 
        const role = await Role.findOne({ name: "user" });
        user.roles = [role._id];
 
        // Save user to the database
        await user.save();
        res.status(201).json({ message: "User was registered successfully!" });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};
 
export const signin = async (req, res) => {
    try {
        // Find user by username
        const user = await User.findOne({ username: req.body.username }).populate(
            "roles",
            "-__v",
        );
 
        if (!user) {
            return res.status(404).json({ message: "User Not found." });
        }
 
        // Validate password
        const passwordIsValid = bcrypt.compareSync(req.body.password, user.password);
        if (!passwordIsValid) {
            return res.status(401).json({
                accessToken: null,
                message: "Invalid Password!",
            });
        }
 
        // Generate JWT
        const token = jwt.sign({ id: user.id }, config.secret, {
            algorithm: "HS256",
            expiresIn: 86400, // 24 hours
        });
 
        // Extract user roles
        const authorities = user.roles.map((role) => `ROLE_${role.name.toUpperCase()}`);
 
        res.status(200).json({
            id: user._id,
            username: user.username,
            email: user.email,
            roles: authorities,
            accessToken: token,
        });
    } catch (err) {
        res.status(500).json({ message: err.message });
    }
};

----------------

User Controller:

// app/controllers/user.controller.js

export const allAccess = (req, res) => {
    res.status(200).send("Public Content.");
};
 
export const userBoard = (req, res) => {
    res.status(200).send("User Content.");
};
 
export const moderatorBoard = (req, res) => {
    res.status(200).send("Moderator Content.");
};
 
export const adminBoard = (req, res) => {
    res.status(200).send("Admin Content.");
};

-----------------

Authentication Routes:

// app/routes/auth.routes.js

import express from "express";
import { signup, signin } from "../controllers/auth.controller.js";
import { verifySignUp } from "../middlewares/index.js";
 
const router = express.Router();
 
// Signup route
router.post(
    "/signup",
    [verifySignUp.checkDuplicateUsernameOrEmail, verifySignUp.checkRolesExisted],
    signup,
);
 
// Signin route
router.post("/signin", signin);
 
export default router;

----------------------

User Routes:

// app/routes/user.routes.js
import express from "express";
import {
    adminBoard,
    allAccess,
    moderatorBoard,
    userBoard,
} from "../controllers/user.controller.js";
import { authJwt } from "../middlewares/index.js";
 
const router = express.Router();
 
// Public route
router.get("/all", allAccess);
 
// User route (any authenticated user)
router.get("/user", [authJwt.verifyToken], userBoard);
 
// Moderator route
router.get("/mod", [authJwt.verifyToken, authJwt.isModerator], moderatorBoard);
 
// Admin route
router.get("/admin", [authJwt.verifyToken, authJwt.isAdmin], adminBoard);
 
export default router;

///////////////////////////////////////////////////////////////////// &&&




///////////////////////////////////////////////////////////////////// &&&

CRUD COM MYSQL E POSTMAN
LINK: https://udara-dananjaya.medium.com/building-a-basic-crud-application-with-node-js-express-and-mysql-5339ae535b4a

Iniciar:
npm init -y

Instalação das dependencias:
npm install express mysql2 axios cors dotenv

-------

Conectando:

const express = require('express');

const app = express();

app.use(express.json());

app.get('/', (req, res) => {
    res.send('TESTE');
});

app.listen(3000, () => {
    console.log('Server listening at http://localhost:5000');
});

--------

Arquivo .env:

DB_HOST = localhost
DB_USER = root
DB_PASSWORD = password
DB_DATABASE = world
DB_PORT = 3000

---------
Conectando ao MySQL:

const express = require('express')
const app = express()
app.use(express.json())

const mysql = require('mysql2');
require("dotenv").config();

const PORT = process.env.DB_PORT

const db = mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
});

db.connect((err) => {                                   
  if (err) {                                                 //OU if (err) throw err;
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

---------

Fazendo um teste GET com a tabela city do schema world no MySQL:
(Sem async)

const express = require('express')
const app = express()
app.use(express.json())

const mysql = require('mysql2');
require("dotenv").config();

const PORT = process.env.DB_PORT

const db = mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
});

db.connect((err) => {                                   
  if (err) {                                                 //OU if (err) throw err;
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.get('/city', (req, res) => {
  const sql = 'SELECT * FROM city';                
  db.query(sql, (err, result) => {
    if (err) {
      res.json({message: err});
      return; 
    }
    res.status(200).json(result[0].Name);                                  
  });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});


-----------

Com async:

app.get('/city', async (req, res) => {
  try {
    const sql = 'SELECT * FROM city';
    db.query(sql, (err, result) => {
      if (err) {
        res.status(500).json({ message: err.message });
        return;
      }
        res.status(200).json(result[0].Name);
    });
  } catch (err) {
    res.status(500).json({message: err.message});
  }
});

OU

app.get('/city', async (req, res) => {
  try {
    const sql = 'SELECT * FROM city';
    const [result] = await db.promise().query(sql);
    res.status(200).json(result[0].Name);
    return;
  } catch (err) {
    res.status(500).json({message: err.message});
  }
});

OU

app.get('/city', async (req, res) => {
  const sql = 'SELECT * FROM city';
  db.query(sql, (err, result) => {
    if (err) {
      res.status(500).json({ message: err.message});
      return;
    }
    res.status(200).json(result[0].Name);
  })
});


¨¨¨¨
Sem async:

app.get('/city', (req, res) => {
  const sql = 'SELECT * FROM city';                
  db.query(sql, (err, result) => {
    if (err) {
      res.status(500).json({message: err});
      return; 
    }
      res.status(200).json(result[0].Name);                                 
  });
});


----------

Criando a tabela no MySQL:

CREATE DATABASE user;

USE user;

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE
);

--------

-Arquivo server.js:

const express = require('express');
const app = express();
app.use(express.json());
const mysql = require('mysql2');

const db = mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
});

const PORT = process.env.DB_PORT;

db.connect((err) => {                                   
  if (err) {                                                 //OU if (err) throw err;
    console.error('Erro ao conectar ao MySQL:', err);
    return;
  }
  console.log('Conectado ao MySQL');
});

app.get('/users', async (req, res) => {
  try{
    const sql = 'SELECT * FROM users';
    db.query(sql, (err, results) => {
    if (err) {
      console.log(err);
    }
    res.send(results);
    });
  }
  catch{
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

app.post('/users', (req, res) => {
    const { name, email } = req.body;
    const sql = 'INSERT INTO users (name, email) VALUES (?, ?)';
    db.query(sql, [name, email], (err, result) => {
        if (err) throw err;
        res.status(201).send({ id: result.insertId, name, email });
    });
});

app.put('/users/:id', (req, res) => {
    const { id } = req.params;
    const { name, email } = req.body;
    const sql = 'UPDATE users SET name = ?, email = ? WHERE id = ?';
    db.query(sql, [name, email, id], (err, result) => {
        if (err) throw err;
        if (result.affectedRows === 0) {
            return res.status(404).send('User not found');
        }
        res.send({ id, name, email });
    });
});

app.delete('/users/:id', (req, res) => {
    const { id } = req.params;
    const sql = 'DELETE FROM users WHERE id = ?';
    db.query(sql, [id], (err, result) => {
        if (err) throw err;
        if (result.affectedRows === 0) {
            return res.status(404).send('User not found');
        }
        res.send('User deleted');
    });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

////////////////////////////////////////////////////////////////////// &&&

CRUD MYSQL MVC:
LINK: https://dev-to.translate.goog/manthanank/building-a-crud-application-with-nodejs-express-and-mysql-4d2m?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=pt&_x_tr_pto=tc

Iniciar:
npm init -y

Instalação: 
npm install express mysql2 dotenv 
npm install --save-dev nodemon

------

ESTRUTURA:

crud-nodejs
├── config
│   └── database.js
├── controllers
│   └── todoController.js
├── middleware
│   └── errorMiddleware.js
├── models
│   └── todo.js
├── routes
│   └── todoRoutes.js
├── .env.example
├── index.js
└── package.json

--------

Arquivo .env:

PORT = 3000
DB_HOST = localhost
DB_USER = root
DB_PASSWORD = password
DB_DATABASE = nome_do_schema

---------

Conectando ao MySQL:

-Arquivo database.js dentro da pasta config:

const mysql = require('mysql2');

require('dotenv').config();

const connection = mysql.createConnection({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE
});

connection.connect((err) => {
    if (err) throw err;
    console.log('Connected to MySQL database');
});

module.exports = connection;

-----------

Criando e configurando o Servidor e definindo as rotas e o middleware de tratamento de erros:

-Arquivo index.js (ou server.js):

const express = require('express');
const todoRoutes = require('./routes/todoRoutes');
const errorMiddleware = require('./middleware/errorMiddleware');

require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());

// Routes
app.use('/todos', todoRoutes);

// Error middleware
app.use(errorMiddleware);

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});

-------------

Definindo o modelo de tarefas para definir as funções para interagir com o banco de dados MySQL

-Arquivo todo.js, dentro da pasta models:

const db = require('../config/database');

exports.getAllTodos = function(callback) {
    db.query('SELECT * FROM todos', callback);
};

exports.getTodoById = function(id, callback) {
    db.query('SELECT * FROM todos WHERE id = ?', [id], callback);
};

exports.createTodo = function(newTodo, callback) {
    db.query('INSERT INTO todos SET ?', newTodo, callback);
};

exports.updateTodo = function(id, updatedTodo, callback) {
    db.query('UPDATE todos SET ? WHERE id = ?', [updatedTodo, id], callback);
};

exports.deleteTodo = function(id, callback) {
    db.query('DELETE FROM todos WHERE id = ?', [id], callback);
};

--------------

Criando o Controlador para definir a lógica para lidar com operações CRUD:

const Todo = require('../models/todo');

exports.getAllTodos = function(req, res) {
    Todo.getAllTodos((err, todos) => {
        if (err) throw err;
        res.json(todos);
    });
};

exports.getTodoById = function(req, res) {
    Todo.getTodoById(req.params.id, (err, todo) => {
        if (err) throw err;
        res.json(todo);
    });
};

exports.createTodo = function(req, res) {
    const newTodo = {
        title: req.body.title,
        completed: req.body.completed
    };

    Todo.createTodo(newTodo, (err, result) => {
        if (err) throw err;
        res.json({ message: 'Todo created successfully' });
    });
};

exports.updateTodo = function(req, res) {
    const updatedTodo = {
        title: req.body.title,
        completed: req.body.completed
    };

    Todo.updateTodo(req.params.id, updatedTodo, (err, result) => {
        if (err) throw err;
        res.json({ message: 'Todo updated successfully' });
    });
};

exports.deleteTodo = function(req, res) {
    Todo.deleteTodo(req.params.id, (err, result) => {
        if (err) throw err;
        res.json({ message: 'Todo deleted successfully' });
    });
};

----------------

Definindo Rotas:

-Arquivo todoRoutes.js dentro da pasta routes:

const express = require('express');
const router = express.Router();
const todoController = require('../controllers/todoController');

router.get('/', todoController.getAllTodos);
router.get('/:id', todoController.getTodoById);
router.post('/', todoController.createTodo);
router.put('/:id', todoController.updateTodo);
router.delete('/:id', todoController.deleteTodo);

module.exports = router;

----------------

Middleware de tratamento de erros:

-Arquivo errorMiddleware.js dentro da pasta middleware:

module.exports = function errorHandler(err, req, res, next) {
    console.error(err.stack);
    res.status(500).send('Something broke!');
};

////////////////////////////////////////////////////////////////////// &&&








